{"meta":{"title":"扬舲's blog","subtitle":"山重水复疑无路 柳暗花明又一村","description":"前端技术博客","author":"yangling","url":"https://jiangawait.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-05T12:50:09.000Z","updated":"2020-05-05T13:11:22.088Z","comments":false,"path":"categories/index.html","permalink":"https://jiangawait.github.io/categories/index.html","excerpt":"","text":""},{"title":"react-test","date":"2020-05-01T08:59:10.000Z","updated":"2020-05-05T09:01:45.717Z","comments":true,"path":"react-test/index.html","permalink":"https://jiangawait.github.io/react-test/index.html","excerpt":"","text":"XSS 即（Cross Site Scripting）：跨站脚本攻击 原理 恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到 web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。 分类 存储型（持久性 XSS 攻击）、反射型(非持久性 XSS 攻击）及 DOM-based 型 反射性反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。例子： 恶意链接的地址指向了 localhost:8001/?q=111&amp;p=222。然后，我再启一个简单的 Node 服务处理恶意链接的请求： 1234567891011const http = require(\"http\");function handleReequest(req, res) &#123; res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\" &#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, \"127.0.0.1\");server.on(\"request\", handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如 cookie)的脚本，这取决于攻击者的目的。 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 基于 DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 123456789101112131415161718192021222324252627&lt;h2&gt;XSS:&lt;/h2&gt;&lt;input type=\"text\" id=\"input\" /&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById(\"input\"); const btn = document.getElementById(\"btn\"); const div = document.getElementById(\"div\"); let val; input.addEventListener( \"change\", (e) =&gt; &#123; val = e.target.value; &#125;, false ); btn.addEventListener( \"click\", () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`; &#125;, false );&lt;/script&gt; 点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容 &#39;&#39; onclick=alert(/xss/) 用户提交之后，页面代码就变成了： &lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt; 此时，用户点击生成的链接，就会执行对应的脚本： SQL 注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中，从而执行恶意的 SQL 语句,一个例子： 我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 ‘or ‘123’ = ‘123 这样的。 我们在查询用户名和密码是否正确的时候，本来执行的 sql 语句是：select _ from user where username = ‘’ and password = ‘’. 这样的 sql 语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的 sql 语句就是：select _ from user where username = ‘’ and password = ‘ ‘ or ‘123’ = ‘123 ‘; 这样的了，那么会有一个 or 语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：’; drop table user;, 这样的话，那么 sql 命令就变成了：select * from user where username = ‘’ and password = ‘’; drop table user;’ , 那么这个时候我们会把 user 表直接删除了。 sql 被攻击的原因是：sql 语句伪造参数，然后对参数进行拼接后形成 xss 攻击的 sql 语句。最后会导致数据库被攻击了。 防范的方法： 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用 sql 语句伪造成参数，到了服务端的时候，这个伪造 sql 语句的参数也只是简单的字符，并不能起到攻击的作用。 数据库中密码不应明文存储的，可以对密码使用 md5 进行加密，为了加大破解成本，所以可以采用加盐的方式。 XSS 攻击的防范 cookie 安全策略 http-only: 只允许 http 或 https 请求读取 cookie、JS 代码是无法读取 cookie 的(document.cookie 会显示 http-only 的 cookie 项被自动过滤掉)。发送请求时自动发送 cookie. secure-only: 只允许 https 请求读取，发送请求时自动发送 cookie。 host-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie。 输入检查 对于用户的任何输入要进行检查、过滤和转义。 输出检查 利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 开启 CSP 网页安全政策防止 XSS 攻击 CSP 是网页安全政策(Content Security Policy)的缩写。主要用来防止 XSS 攻击。是一种由开发者定义的安全性政策申明，通过 CSP 所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#39;self&#39; &#39;unsafe-inline&#39; ; style-src &#39;self&#39; &#39;unsafe-inline&#39; *.yyy.com; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; ; &quot;&gt; CSRF(跨站请求伪造)完成一次 CSRF 攻击，需要完成如下事情： 登录受信任的网站 A，并且在本地生成 cookie。 在不登出网站 A 的情况下，继续访问危险网站 B。 CSRF 基本原理是：假设 A 网站是一个银行网站，而我是该网站的用户，当我以受信任的身份登录了该网站的时候，这时候 A 网站是通过 cookie 保留了我们的登录状态，这个时候我去登录了恶意网站 B 的时候，B 网站就会拿到我登录 A 网站的 cookie 信息到，因此 B 网站就把拿到的 cookie 信息去重新请求 A 网站的接口，但是在该接口后面的参数做一些修改，因此就这样达到攻击的目的。 CSRF 防范措施 服务端验证 HTTP Referer 字段 加验证码 使用 Token"},{"title":"标签","date":"2020-05-05T12:52:32.000Z","updated":"2020-05-05T13:12:10.066Z","comments":true,"path":"tags/index.html","permalink":"https://jiangawait.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"typeof 实现原理","slug":"basic/typeof","date":"2020-05-06T15:11:22.000Z","updated":"2020-05-06T15:12:22.278Z","comments":true,"path":"basic/typeof/","link":"","permalink":"https://jiangawait.github.io/basic/typeof/","excerpt":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如","text":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 123let s = new String(\"abc\");typeof s === \"object\"; // trues instanceof String; // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 `null`：所有机器码均为0 `undefined`：用 −2^30 整数来表示所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 1null instanceof null; // TypeError: Right-hand side of 'instanceof' is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留 bug，可以参考 typeof. 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括 symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是 Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 123456789Object.prototype.toString.call(1); // \"[object Number]\"Object.prototype.toString.call(\"hi\"); // \"[object String]\"Object.prototype.toString.call(&#123; a: \"hi\" &#125;); // \"[object Object]\"Object.prototype.toString.call([1, \"a\"]); // \"[object Array]\"Object.prototype.toString.call(true); // \"[object Boolean]\"Object.prototype.toString.call(() =&gt; &#123;&#125;); // \"[object Function]\"Object.prototype.toString.call(null); // \"[object Null]\"Object.prototype.toString.call(undefined); // \"[object Undefined]\"Object.prototype.toString.call(Symbol(1)); // \"[object Symbol]\" instanceof 操作符的实现原理之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 123let person = function () &#123;&#125;;let nicole = new person();nicole instanceof person; // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 123456let person = function () &#123;&#125;;let programmer = function () &#123;&#125;;programmer.prototype = new person();let nicole = new programmer();nicole instanceof person; // truenicole instanceof programmer; // true instanceof 实现原理： 12345678910111213function new_instance_of(leftVaule, rightVaule) &#123; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__; &#125;&#125; 总结简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangawait.github.io/tags/JavaScript/"},{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"一些 JS 关键技术的底层实现汇总","slug":"basic/js_basic_implementation","date":"2020-05-06T14:40:35.000Z","updated":"2020-05-06T15:08:11.569Z","comments":true,"path":"basic/js_basic_implementation/","link":"","permalink":"https://jiangawait.github.io/basic/js_basic_implementation/","excerpt":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。","text":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() new 的原理 reduce 实现原理 双向绑定 继承 Object.create instanceof 实现 Array.isArray 实现 getOwnPropertyNames 实现 Promise 实现 防抖/节流 函数柯里化实现 实现简单深拷贝 Function.prototype.call()call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。 语法：fun.call(thisArg, arg1, arg2, ...) 1234567891011121314151617181920212223242526272829303132/** * call的实现原理 */const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;Function.prototype.mcall = function (context) &#123; context = context ? Object(context) : getGlobal(); context.fn = this; let args = [...arguments].slice(1); let r = context.fn(...args); delete context.fn; return r;&#125;;/** * 一个用call实现继承的例子 * @param &#123;*&#125; name * @param &#123;*&#125; price */function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Fruit(name, price) &#123; Product.mcall(this, name, price); this.category = \"fruit\";&#125;var apple = new Fruit(\"apple\", 5);console.log(apple); Function.prototype.apply()apply()调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数. 语法： func.apply(thisArg, [argsArray]) 1234567891011121314151617181920212223242526272829303132333435const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * apply原理 */Function.prototype.apply = function (context, arr) &#123; context = context ? Object(context) : getGlobal(); console.log(\"context\", context); context.fn = this; // let args = [...arguments][1]; if (!arr) &#123; let r = context.fn(); delete context.fn; return r; &#125; let r = context.fn(...arr); delete context.fn; return r;&#125;;//使用例子var array = [\"a\", \"b\"];var elements = [0, 1, 2];array.push.apply(array, elements);console.log(\"array\", array); // [\"a\", \"b\", 0, 1, 2]function A(x, y) &#123; console.log(this.b + \" \" + x + \" \" + y);&#125;var B = &#123; b: 1 &#125;;A.apply(B, [2, 3]); Function.prototype.bind()bind()方法创建一个新函数, 在调用时设置 this 关键字为提供的值。 语法：fun.bind(thisArg, arg1, arg2, ...) 12345678910111213141516171819202122const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * bind实现原理 */Function.prototype.bind = function (context) &#123; context = context ? Object(context) : getGlobal(); const me = this; const args = [...arguments].slice(1); return function () &#123; me.apply(context, [...args, ...arguments]); &#125;;&#125;;function A(x, y) &#123; console.log(this.b + \", \" + x + \", \" + y);&#125;var B = &#123; b: 1 &#125;;let fnc = A.bind(B, 2); //1 2 3fnc(3); new 的原理在了解 new 原理之前先看看 js 的内部机制图 我们需要知道当 new 的时候做了什么事情 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 new 没法重写，这里是有 mockNew 函数来模拟 1234567891011121314151617181920212223242526272829303132/** * new实现原理 */function mockNew() &#123; //创建一个实例 const obj = &#123;&#125;; //获得构造器 const constructor = [].shift.call(arguments); //实现继承，实例可以访问构造器熟悉 obj.__proto__ = constructor.prototype; //调用构造器，改变this指向为实例 const res = constructor.apply(obj, arguments); //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象 return res instanceof Object ? res : obj;&#125;/** * 使用例子 * @param &#123;*&#125; color * @param &#123;*&#125; name */function Car(color, name) &#123; this.color = color; return &#123; name: name, &#125;;&#125;let car = mockNew(Car, \"black\", \"BMW\");console.log(car.color);// undefinedconsole.log(car.name);// \"BMW\" reduce 实现原理12345678910111213141516171819202122232425262728293031323334/** * 实现原理 */Array.prototype.mockReduce = function (callback) &#123; const length = this.length; let reducer = undefined, //累加器，最终返回这个值 k = 0, //数组下标 initVal = [...arguments].length &gt; 1 ? [...arguments][1] : undefined; //传入reduce的初始值 if (typeof callback !== \"function\") &#123; throw new TypeError(callback + \" is not a function\"); &#125; if (length === 0 &amp;&amp; !initVal) &#123; throw new TypeError(\"Reduce of empty array with no initial value\"); &#125; if (initVal) &#123; reducer = initVal; &#125; else &#123; reducer = this[0]; k++; &#125; while (k &lt; length) &#123; if (this.hasOwnProperty(k)) &#123; const kValue = this[k]; reducer = callback(reducer, kValue); &#125; k++; &#125; return reducer;&#125;;const rReduce = [].reduce((a, b) =&gt; a + b, 3);const mReduce = [].mockReduce((a, b) =&gt; a + b);console.log(rReduce, mReduce); 双向绑定defineProperty实现 123456789101112131415161718// 数据const data = &#123; text: \"hello\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持Object.defineProperty(data, \"text\", &#123; // 数据变化 --&gt; 修改视图 set(newVal) &#123; input.value = newVal; p.innerHTML = newVal; &#125;,&#125;);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; data.text = e.target.value;&#125;); proxy实现 12345678910111213141516171819202122// 数据const data = &#123; text: \"default\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持const handler = &#123; set(target, key, value) &#123; target[key] = value; // 数据变化 --&gt; 修改视图 input.value = value; p.innerHTML = value; return value; &#125;,&#125;;const proxy = new Proxy(data, handler);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; proxy.text = e.target.value;&#125;); 继承12345678910111213141516171819202122232425function inheritPrototype(subType, superType) &#123; var protoType = Object.create(superType.prototype); //创建对象 protoType.constructor = subType; //增强对象 subType.prototype = protoType; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; alert(this.age);&#125;;var instance = new SubType(\"Bob\", 18);instance.sayName();instance.sayAge(); Object.create1234567891011121314151617181920if (typeof Object.create !== \"function\") &#123; Object.create = function (prototype, properties) &#123; if (typeof prototype !== \"object\") &#123; throw TypeError(); &#125; function Ctor() &#123;&#125; Ctor.prototype = prototype; var o = new Ctor(); if (prototype) &#123; o.constructor = Ctor; &#125; if (properties !== undefined) &#123; if (properties !== Object(properties)) &#123; throw TypeError(); &#125; Object.defineProperties(o, properties); &#125; return o; &#125;;&#125; instanceof 实现原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null 1234567891011// L 表示左表达式，R 表示右表达式function instance_of(L, R) &#123; var O = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; // 这里重点：当 O 严格等于 L 时，返回 true if (O === L) return true; L = L.__proto__; &#125;&#125; Array.isArray 实现12345Array.myIsArray = function (o) &#123; return Object.prototype.toString.call(Object(o)) === \"[object Array]\";&#125;;console.log(Array.myIsArray([])); // true getOwnPropertyNames 实现123456789101112131415if (typeof Object.getOwnPropertyNames !== \"function\") &#123; Object.getOwnPropertyNames = function (o) &#123; if (o !== Object(o)) &#123; throw TypeError(\"Object.getOwnPropertyNames called on non-object\"); &#125; var props = [], p; for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) &#123; props.push(p); &#125; &#125; return props; &#125;;&#125; Promise 实现实现原理：其实就是一个发布订阅者模式 构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数 then 时收集依赖，将回调函数收集到 成功/失败队列 executor 函数中调用 resolve/reject 函数 resolve/reject 函数被调用时会通知触发队列中的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209const isFunction = variable =&gt; typeof variable === 'function';// 定义Promise的三种状态常量const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';class MyPromise &#123; // 构造函数，new 时触发 constructor(handle: Function) &#123; try &#123; handle(this._resolve, this._reject); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 状态 pending fulfilled rejected private _status: string = PENDING; // 储存 value，用于 then 返回 private _value: string | undefined = undefined; // 失败队列，在 then 时注入，resolve 时触发 private _rejectedQueues: any = []; // 成功队列，在 then 时注入，resolve 时触发 private _fulfilledQueues: any = []; // resovle 时执行的函数 private _resolve = val =&gt; &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; this._status = FULFILLED; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* * 如果resolve的参数为Promise对象， * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变 * 且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; runRejected(err); &#125; ); &#125; else &#123; this._value = val; runFulfilled(val); &#125; &#125;; // 异步调用 setTimeout(run); &#125;; // reject 时执行的函数 private _reject = err =&gt; &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run); &#125;; // then 方法 then(onFulfilled?, onRejected?) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 const fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; const res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 const rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; const res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // catch 方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // finally 方法 finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125; // 静态 resolve 方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 静态 reject 方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 静态 all 方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // 返回值的集合 let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125;&#125; 防抖/节流防抖函数 onscroll 结束时触发一次，延迟执行123456789101112131415function debounce(callback, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; callback.apply(context, args); &#125;, wait); &#125;;&#125;// 使用window.onscroll = debounce(function () &#123; console.log(\"debounce\");&#125;, 1000); 节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样1234567891011121314function throttle(callback, delay) &#123; var prevTime = Date.now(); return function () &#123; var curTime = Date.now(); if (curTime - prevTime &gt; delay) &#123; callback.apply(this, arguments); prevTime = curTime; &#125; &#125;;&#125;// 使用window.onscroll = throttle(function () &#123; console.log(\"throtte\");&#125;, 1000); 函数柯里化实现其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。应用场景： 延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数） 动态创建函数 （参数不够时会返回接受剩下参数的函数） 参数复用（每个参数可以多次复用） 123456789101112const curry = (fn) =&gt; (judge = (...args) =&gt; args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg));const sum = (a, b, c, d) =&gt; a + b + c + d;const currySum = curry(sum);currySum(1)(2)(3)(4); // 10currySum(1, 2)(3)(4); // 10currySum(1)(2, 3)(4); // 10 实现简单深拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; \"[object Boolean]\": \"boolean\", \"[object Number]\": \"number\", \"[object String]\": \"string\", \"[object Function]\": \"function\", \"[object Array]\": \"array\", \"[object Date]\": \"date\", \"[object RegExp]\": \"regExp\", \"[object Undefined]\": \"undefined\", \"[object Null]\": \"null\", \"[object Object]\": \"object\", &#125;; if (obj instanceof Element) &#123; // 判断是否是dom元素，如div等 return \"element\"; &#125; return map[str];&#125;function deepCopy(original) &#123; const type = getType(original); let copy; switch (type) &#123; case \"array\": return copyArray(original, copy); case \"object\": return copyObject(original, copy); case \"function\": return copyFunction(original, copy); default: return original; &#125;&#125;function copyArray(original, copy = []) &#123; for (const [index, value] of original.entries()) &#123; copy[index] = deepCopy(value); &#125; return copy;&#125;function copyObject(original, copy = &#123;&#125;) &#123; for (const [key, value] of Object.entries(original)) &#123; copy[key] = deepCopy(value); &#125; return copy;&#125;function copyFunction(original, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(original.toString()); fn.prototype = original.prototype; return fn;&#125;const arr1 = [1, 2, [3, 4], &#123; i: 6, j: 6 &#125;, (k, m) =&gt; k + m];console.log(deepCopy(arr1));","categories":[{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangawait.github.io/tags/JavaScript/"},{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"通过iframe下载文件如何判断下载完成","slug":"basic/iframe_download_complete","date":"2019-07-06T14:24:20.000Z","updated":"2020-05-06T15:07:14.549Z","comments":true,"path":"basic/iframe_download_complete/","link":"","permalink":"https://jiangawait.github.io/basic/iframe_download_complete/","excerpt":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。","text":"问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = \"http://www.example.com/file.zip\";var iframe = document.createElement(\"iframe\");iframe.src = url;iframe.style.display = \"none\";iframe.onload = function () &#123; console.debug(\"start downloading...\"); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 这里说一下 Content-disposition： Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。 解决思路二：添加 header 配置123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(\"X-Content-Type-Options\", \"nosniff\");// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(\"X-Frame-Options\", \"deny\"); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(\"iframedownload\"); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == \"complete\" || iframeDoc.readyState == \"interactive\" ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"-基础","slug":"基础","permalink":"https://jiangawait.github.io/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"文章摘录","slug":"collection","date":"2019-05-06T07:35:35.000Z","updated":"2020-05-06T07:41:32.041Z","comments":true,"path":"collection/","link":"","permalink":"https://jiangawait.github.io/collection/","excerpt":"在这里记录一些看到的好文章好博客","text":"在这里记录一些看到的好文章好博客 龙恩 0707 cdn 全栈修炼 前端进阶之道 大前端面试宝典 - 图解前端 未来可期的 TypeScript 别再说虚拟 DOM 快了，要被打脸的 深入理解虚拟 DOM，它真的不快 Deep In React 之详谈 React 16 Diff 策略(二) ReactFiber 在并发模式下的运行机制 前端浏览器输入 URL 后发生什么 大公司如何部署前端代码 Vuex、Flux、Redux、Redux-saga、Dva、MobX","categories":[{"name":"面试","slug":"面试","permalink":"https://jiangawait.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://jiangawait.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://jiangawait.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"hexo操作实录","slug":"hexo_note","date":"2019-04-03T11:18:05.000Z","updated":"2020-05-06T15:09:20.447Z","comments":true,"path":"hexo_note/","link":"","permalink":"https://jiangawait.github.io/hexo_note/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并发布到 GitHub pages 上的全过程。","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装前提安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序： Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本) Git 注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容 安装 Hexo使用 npm: 1$ npm install -g hexo-cli 使用 yarn: 1$ yarn global add hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 常用命令new新建一篇文章 1$ hexo new [layout] &lt;title&gt; generate生成静态文件。 1$ hexo generate publish发表草稿。 1$ hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 1$ hexo server deploy部署网站。 1$ hexo deploy clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 1$ hexo clean list列出网站资料。 1$ hexo list &lt;type&gt; 注： 更多命令见官网 部署 GitHub pages新建 GitHub 项目打开 GitHub 点击右上角的new repository 然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建 安装 hexo-deployer-git。1$ npm install hexo-deployer-git --save 修改_config.yml 配置1234deploy: type: git repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git branch: master 执行命令执行 hexo deploy 将生成的文件部署上去 1hexo clean &amp;&amp; hexo deploy 效果图","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://jiangawait.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://jiangawait.github.io/tags/Hexo/"}]}],"categories":[{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/categories/%E5%9F%BA%E7%A1%80/"},{"name":"-基础","slug":"基础","permalink":"https://jiangawait.github.io/categories/%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"https://jiangawait.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Hexo","slug":"Hexo","permalink":"https://jiangawait.github.io/categories/Hexo/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jiangawait.github.io/tags/JavaScript/"},{"name":"基础","slug":"基础","permalink":"https://jiangawait.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"前端","slug":"前端","permalink":"https://jiangawait.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://jiangawait.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Hexo","slug":"Hexo","permalink":"https://jiangawait.github.io/tags/Hexo/"}]}