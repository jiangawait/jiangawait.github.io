{"meta":{"title":"扬舲's blog","subtitle":"山重水复疑无路 柳暗花明又一村","description":"前端技术博客","author":"yangling","url":"http://kobin.top","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-05T20:50:09.000Z","updated":"2020-06-05T07:58:32.085Z","comments":false,"path":"categories/index.html","permalink":"http://kobin.top/categories/index.html","excerpt":"","text":""},{"title":"react-test","date":"2020-05-01T16:59:10.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"react-test/index.html","permalink":"http://kobin.top/react-test/index.html","excerpt":"","text":"XSS 即（Cross Site Scripting）：跨站脚本攻击 原理 恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到 web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。 分类 存储型（持久性 XSS 攻击）、反射型(非持久性 XSS 攻击）及 DOM-based 型 反射性反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。例子： 恶意链接的地址指向了 localhost:8001/?q=111&amp;p=222。然后，我再启一个简单的 Node 服务处理恶意链接的请求： 1234567891011const http = require(\"http\");function handleReequest(req, res) &#123; res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\" &#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, \"127.0.0.1\");server.on(\"request\", handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如 cookie)的脚本，这取决于攻击者的目的。 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 基于 DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 123456789101112131415161718192021222324252627&lt;h2&gt;XSS:&lt;/h2&gt;&lt;input type=\"text\" id=\"input\" /&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById(\"input\"); const btn = document.getElementById(\"btn\"); const div = document.getElementById(\"div\"); let val; input.addEventListener( \"change\", (e) =&gt; &#123; val = e.target.value; &#125;, false ); btn.addEventListener( \"click\", () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`; &#125;, false );&lt;/script&gt; 点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容 &#39;&#39; onclick=alert(/xss/) 用户提交之后，页面代码就变成了： &lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt; 此时，用户点击生成的链接，就会执行对应的脚本： SQL 注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中，从而执行恶意的 SQL 语句,一个例子： 我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 ‘or ‘123’ = ‘123 这样的。 我们在查询用户名和密码是否正确的时候，本来执行的 sql 语句是：select _ from user where username = ‘’ and password = ‘’. 这样的 sql 语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的 sql 语句就是：select _ from user where username = ‘’ and password = ‘ ‘ or ‘123’ = ‘123 ‘; 这样的了，那么会有一个 or 语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：’; drop table user;, 这样的话，那么 sql 命令就变成了：select * from user where username = ‘’ and password = ‘’; drop table user;’ , 那么这个时候我们会把 user 表直接删除了。 sql 被攻击的原因是：sql 语句伪造参数，然后对参数进行拼接后形成 xss 攻击的 sql 语句。最后会导致数据库被攻击了。 防范的方法： 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用 sql 语句伪造成参数，到了服务端的时候，这个伪造 sql 语句的参数也只是简单的字符，并不能起到攻击的作用。 数据库中密码不应明文存储的，可以对密码使用 md5 进行加密，为了加大破解成本，所以可以采用加盐的方式。 XSS 攻击的防范 cookie 安全策略 http-only: 只允许 http 或 https 请求读取 cookie、JS 代码是无法读取 cookie 的(document.cookie 会显示 http-only 的 cookie 项被自动过滤掉)。发送请求时自动发送 cookie. secure-only: 只允许 https 请求读取，发送请求时自动发送 cookie。 host-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie。 输入检查 对于用户的任何输入要进行检查、过滤和转义。 输出检查 利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 开启 CSP 网页安全政策防止 XSS 攻击 CSP 是网页安全政策(Content Security Policy)的缩写。主要用来防止 XSS 攻击。是一种由开发者定义的安全性政策申明，通过 CSP 所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#39;self&#39; &#39;unsafe-inline&#39; ; style-src &#39;self&#39; &#39;unsafe-inline&#39; *.yyy.com; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; ; &quot;&gt; CSRF(跨站请求伪造)完成一次 CSRF 攻击，需要完成如下事情： 登录受信任的网站 A，并且在本地生成 cookie。 在不登出网站 A 的情况下，继续访问危险网站 B。 CSRF 基本原理是：假设 A 网站是一个银行网站，而我是该网站的用户，当我以受信任的身份登录了该网站的时候，这时候 A 网站是通过 cookie 保留了我们的登录状态，这个时候我去登录了恶意网站 B 的时候，B 网站就会拿到我登录 A 网站的 cookie 信息到，因此 B 网站就把拿到的 cookie 信息去重新请求 A 网站的接口，但是在该接口后面的参数做一些修改，因此就这样达到攻击的目的。 CSRF 防范措施 服务端验证 HTTP Referer 字段 加验证码 使用 Token"},{"title":"标签","date":"2020-05-05T20:52:32.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"tags/index.html","permalink":"http://kobin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用软件大全","slug":"others-常用软件推荐","date":"2020-05-27T22:51:15.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"others-常用软件推荐/","link":"","permalink":"http://kobin.top/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"在此记录一些堪称神器的软件","text":"windows篇1. Listary它不仅可以在本地非常快速的搜索，还可以打开网站、在搜索引擎中搜索、随时随地打开快捷菜单、文件快速定位、快速打开cmd窗口等等优秀的功能； 比如输入 cmd打开cmd窗口，输入 cmda使用管理员权限打开cmd窗口，输入 wyyyy打开网易云音乐，找到某个文件的时候 Enter直接打开， Ctrl+Enter 是打开文件所在文件夹； 值得一提的是搜索关键词功能，让我们可以非常便捷的打开相应网站或在对应网站搜索，比如输入 gg我的存款呢？就可以直接使用默认浏览器在谷歌搜索中搜索了，我们还可以自定义输入其他关键字，只需把搜索链接中的关键字换成 {query} ~ 2. uTools可以作为程序启动器外，uTools最大的特点就是拥有强大的插件系统，每个插件都有简洁美观、易于操作的界面，输入plugins进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最趁手的工具合集，为各种日常操作提供便利。不断产生的新插件，也将为你带来无限可能。 个人常用图床、剪切板、todo、各种技术文档等 3. DittoDitto 是一款免费开源的windows剪切板管理工具，作为 CtrlC V工程师，复制粘贴少不了，更厉害的是，可以用它来批量的复制， Ctrl+C一堆别人的代码，一次性全粘上，岂不美哉； 使用快捷键打开剪切板历史，然后 Ctrl/Shift来选择你希望粘贴的内容， Enter即可选择性的粘贴多行内容；另外剪切板历史还可以搜索，快速找到复制内容； 只需设置寥寥几个快捷键，就可以很方便的操作剪切板，带来极大幸福~ 4. Winsnap看到上面的截图没，旁边都有很骚包的阴影，怎么做到的？不需要各种高大上的图片处理软件，只需 Winsnap ，它可以在截图的时候自动帮你加上背景阴影，然后帮你自动复制到剪切板； 它可以使用全屏、应用程序、窗口、对象等捕捉模式，更牛的是它还可以在截图的时候同时选择和捕捉多个对象，按住 Ctrl或 Shift选择多个窗口或对象…这个就比较厉害了，不信你试试？ 5. CmderCmder 是一个美观又实用的命令行工具，它支持大部分Linux命令，支持ssh连Linux，还可以在它的窗口中新建cmd和powershell，更多玩法等你来战~ 比较方便的是在安装目录下 \\config\\user-aliases.cmd设置 alias 别名，比如参见的 Git 操作： 12345678910111213ga=git add $*gb=git branch $*gc=git commit $*gch=git checkout $*gd=git diff $*gl=git log $*gs=git status $* 还可以将cmder配置到右键菜单，快捷在当前目录打开cmder，方法是先把这个地址加到系统的path环境变量里面，比如我的是 D:cmder，然后右键 Cmder.exe属性-兼容性-以管理员身份运行此程序，再重新打开 Cmder.exe输入 Cmder.exe/REGISTER ALL就行了~ 记得安装完在配置 Setting-Startup-Environment里面加上 setLANG=zh_CN.UTF8，否则输出的一些中文会乱码； 6. Typora使用过很多 Markdown 编辑器，最后选择了 Typora，与主流编辑器一边编辑一边预览的形式，Typora 是将编辑和预览合并到一起，简洁大方，目光也不需要在复杂的编辑区和预览区中来回切换了，只有当焦点移入的时候才显示 Markdown 语法； 另外 Typora 还支持 Latex、 [TOC]动态目录、拖拽图片自动生成本地预览链接、自定义主题等方便的功能； 7. Quick LookQuickLook 是在 Microsoft Store 里面下载的一个速览工具，有时候打开一个PDF、TXT、图片之类的需要等关联程序启动半天，有了它之后只要选中目标文件，按空格，就可以快速预览了，速度非常快，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML等格式； 用它来看一些代码什么的，甚至不需要 Sublime\\VSCode 启动就可以直接看了，如果只是速览一下的话是非常适合的了。 8. Myper SplashMyper Splash 也是可以在 Microsoft Store 里面下载的一款高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用，再加上简洁美观的UI/UX设计，让你体验一见钟情的感觉。 另外 MyperSplash 可以设置自动每天自动更换壁纸或锁屏，每天早晨来到办公室点亮屏幕就可以看到 Awesome 的锁屏或壁纸，让你带着好心情开启一天的工作。 9. GifCam / ScreenToGif相信大家都有过需要截一个 Gif 的时候，这里有两个免费 Gif 屏幕录制工具都很不错，小而美的 GifCam 和开源强大的 ScreenToGif ； 10. Free Download ManageFree Download Manage (FDM) 是一款免费的下载工具，如果你已经受够了国内一些软件的广告和限速，那么 FDM 是一个不错的选择，另外多线程、断点续传、计划任务等功能让 FDM 值得推介。 11. SourcetreeSourcetree 是跨平台免费的 Git 客户端管理工具，如果受够了手打各种 Git 操作命令，那么 Sourcetree 是一个不错的选择； Sourcetree 可以大大简化你的代码操作，特别是对于一些不甚熟悉 Git 命令的人来说灰常实用；一些对 Git 操作比较熟练的用户也可以用它来提升效率，减少出错。","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"software","slug":"software","permalink":"http://kobin.top/tags/software/"},{"name":"软件","slug":"软件","permalink":"http://kobin.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"centOS7安装Java环境","slug":"others-centOS7安装Java环境","date":"2020-05-22T16:28:42.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"others-centOS7安装Java环境/","link":"","permalink":"http://kobin.top/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/","excerpt":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程","text":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程 1. 选择合适的jdk版本 jdk下载地址 选择一下版本获取下载链接 2. 下载1wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b 此链接地址可能失效，请自行在步骤1中获取最新下载链接 下载后检查安装包大小是否符合预期（判断安装包是否损坏） 1ls -lht 3. 安装3.1. 创建安装目录： 1mkdir /usr/local/java/ 3.2 解压到安装目录： 1tar -zxvf jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b -C /usr/local/java 4. 配置环境变量打开profile文件 1vim /etc/profile 在末尾添加一下代码： 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_251export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量生效 1source /etc/profile 添加软链接 1ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java 验证是否安装成功 1java -version","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"java","slug":"java","permalink":"http://kobin.top/tags/java/"}]},{"title":"ECMAScript新特性","slug":"javascript-ECMAScript特性分析","date":"2020-05-22T14:59:54.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-ECMAScript特性分析/","link":"","permalink":"http://kobin.top/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/","excerpt":"2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES 2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。","text":"2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES 2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。 ES 7 新特性 功能点 说明 Array.prototype.includes 查找数组 Exponentiation operator 指数函数的中缀表示法 Array.prototype.includesincludes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（和indexOf不一样的点)。 1234567891011121314let arr = [1, 2, 3, NaN];if (arr.includes(2)) &#123; //查找2是否存在于arr数组中 console.log(\"找到了!\"); //&gt;&gt; 找到了！&#125;if (!arr.includes(2, 3)) &#123; //第二个参数3表示数组下标为3的项，也即第4项开始查找 console.warn(\"不存在!\"); //&gt;&gt; 不存在！&#125;//下面两句说明incluedes和indexOf的区别console.log(arr.includes(NaN)); //trueconsole.log(arr.indexOf(NaN) != -1); //false 指数函数用法JavaScript采用两个星符号**来表示Math.pow，相对于Math.pow的好处： 中缀表示法比函数表示法更简洁，这使它更可取。 方便数学、物理、机器人学等领域的计算。 12345678910//用法一：x ** ylet squared = 2 ** 2;//等同于: 2 * 2let cubed = 2 ** 3;//等同于: 2 * 2 * 2//用法二：x **= ylet a = 2;a **= 2;//等同于: a = a * a;let b = 3;b **= 3;//等同于: b = b * b * b; ES 8 新特性 功能点 说明 Object.values / Object.entries String padding 字符串追加 Object.getOwnPropertyDescriptors 返回指定对象自己所有的属性内容 Async functions 异步函数 Shared memory and atomics 共享内存和 Atomics 对象 Object.values() / Object.entries Object.values(obj)，obj 参数是对目标对象的操作，它可以是一个对象或者数组 12345678910const obj = &#123; x: 'xxx', y: 1 &#125;;Object.values(obj); // ['xxx', 1]const obj = ['e', 's', '8']; // 等同于 &#123; 0: 'e', 1: 's', 2: '8' &#125;;Object.values(obj); // ['e', 's', '8']//当把数字对象的当键的时候，返回的数组以键的值升序排序const obj = &#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;;Object.values(obj); // ['yyy', 'zzz', 'xxx']Object.values('es8'); // ['e', 's', '8'] Object.entries方法返回一个给定对象可枚举属性值的数组[key, value]，与Object.values类似 123456789const obj = &#123; x: 'xxx', y: 1 &#125;;Object.entries(obj); // [['x', 'xxx'], ['y', 1]]const obj = ['e', 's', '8'];Object.entries(obj); // [['0', 'e'], ['1', 's'], ['2', '8']]const obj = &#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;;Object.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']] 字符串追加在 ES 8 中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。String.padStart(targetLength,[padString])targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。padString：(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。String.padEnd(targetLength,padString]) 参数释义同上。 1234567891011'es8'.padStart(2); // 'es8''es8'.padStart(5); // ' es8''es8'.padStart(6, '1891'); // '189es8''es8'.padStart(14, 'coffe'); // 'coffecoffecoffes8''es8'.padStart(7, '0'); // '0000es8''es8'.padEnd(2); // 'es8''es8'.padEnd(5); // 'es8 ''es8'.padEnd(6, '1891'); // 'es81891''es8'.padEnd(14, 'coffe'); // 'es8coffecoffecoff''es8'.padEnd(7, '9'); // 'es89999' Object.getOwnPropertyDescriptorsgetOwnPropertyDescriptors方法返回指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。定义是：Object.getOwnPropertyDescriptors(obj)，obj 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。 12345678910111213141516171819const obj = &#123; get es7() &#123; return 7; &#125;, get es8() &#123; return 8; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123;// es7: &#123;// configurable: true,// enumerable: true,// get: function es7()&#123;&#125;, //the getter function// set: undefined// &#125;,// es8: &#123;// configurable: true,// enumerable: true,// get: function es8()&#123;&#125;, //the getter function// set: undefined// &#125;// &#125; getOwnPropertyDescriptors可以用来创建子类： 12345678function superclass() &#123;&#125;superclass.prototype = &#123; // 在这里定义方法和属性&#125;;function subclass() &#123;&#125;subclass.prototype = Object.create(superclass.prototype, Object.getOwnPropertyDescriptors(&#123; // 在这里定义方法和属性&#125;)); 异步函数Async Functions也就是我们常说的Async/Await,已经用的很频繁了，在此不再赘述。 SharedArrayBuffer &amp; AtomicsSharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。 请注意，作为对Spectre的响应，所有主流浏览器均默认于2018年1月5日禁用SharedArrayBuffer。 Chrome在启用了网站隔离功能的平台上的v67中重新启用了该功能，以防止出现Spectre风格的漏洞。 语法： 123456/** * * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。 * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */new SharedArrayBuffer(length) 共享内存能被同时创建和更新于工作者线程或主线程。依赖于系统（CPU，操作系统，浏览器），变化传递给所有上下文环境需要一段时间。需要通过 atomic 操作来进行同步。 Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。 多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。 方法名 说明 Atomics.add() 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值 Atomics.and() 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 Atomics.compareExchange() 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 Atomics.exchange() 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 Atomics.load() 返回数组中指定元素的值。 Atomics.or() 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 Atomics.store() 将数组中指定的元素设置为给定的值，并返回该值。 Atomics.sub() 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 Atomics.xor() 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 Atomics.wait() 检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。 Atomics.wake() 唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。 Atomics.isLockFree(size) 可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。 ES 9 新特性 新特性 中文说明 Asynchronous Iteration 异步迭代器 Promise.prototype.finally Lifting template literal restriction 重新修订了字面量的转义 Rest/Spread Properties Rest/Spread 属性 s (dotAll) flag for regular expressions 正则表达式dotAll模式 RegExp named capture groups 正则表达式命名捕获组 RegExp Lookbehind Assertions 正则表达式反向断言 RegExp Unicode Property Escapes 正则表达式 Unicode 转义 异步迭代器在async/await的某些时刻，你可能尝试在同步循环中调用异步函数。例如： 12345async function func(array) &#123; for (let i of array) &#123; await someFunc(i); &#125;&#125; 这段代码不会达到预期目的，下面这段同样也不会： 12345async function func(array) &#123; array.forEach(async i =&gt; &#123; await someFunc(i); &#125;);&#125; 上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。 引入异步迭代器后，就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。 12345async function func(array) &#123; for await (let i of array) &#123;//异步迭代 someFunc(i); &#125;&#125; 更多详细论述见“壹.2.12”。 Promise.prototype.finally一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，.finally()允许实现这样的目的。 1234567891011function func() &#123; promiseFunc() //返回一个Promise对象 .then(() =&gt; &#123;&#125;) .then(() =&gt; &#123;&#125;) .catch(err =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; //无论promiseFunc()运行成功还是失败，这里的代码会被调用到 &#125;);&#125; 更多详细论述见“壹.2.12”。 重新修订了字面量的转义ES9 之前，\\u表示 unicode 转义，\\x表示十六进制转义，\\后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径C:\\uuu\\xxx\\111。 要取消转义序列的语法限制，可在模板字符串之前使用标记函数String.raw。 12345let s = `\\u&#123;54&#125;` //会转义成unicode \"T\"console.log(s);//&gt;&gt; Tlet str = String.raw`\\u&#123;54&#125;`; //不会被转义console.log(str);//&gt;&gt; \\u&#123;54&#125; Rest / Spread 属性这个就是我们通常所说的三个点...，在=左边的是rest参数，放在=右边或者作为参数的是扩展运算符，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符： 12345678910111213const obj = &#123; a: 1, b: 2, c: 3&#125;;const &#123; a, ...param &#125; = obj; //这里...是rest参数console.log(a); //&gt;&gt; 1console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;function foo(&#123; a, ...param &#125;) &#123;//这里...是扩展运算符 console.log(a); //&gt;&gt; 1 console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;&#125; 正则表达式dotAll模式正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许匹配回车换行。 1234/hello.world/.test('hello\\nworld'); // false/hello.world/s.test('hello\\nworld'); // trueconsole.log(/hello.world/s.test(`helloworld`)) //&gt;&gt; true 正则表达式命名捕获组Javascript正则表达式中使用exec()匹配后，能够返回一个包含匹配字符串的类数组对象。 12345678const reDate = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/, match = reDate.exec(\"2018-08-06\");console.log(match);//&gt;&gt; [2018-08-06, 2018, 08, 06]//这样就可以直接用索引来获取年月日：let year = match[1]; //&gt;&gt; 2018let month = match[2]; //&gt;&gt; 08let day = match[3]; //&gt;&gt; 06 返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 reDate 的第 1 个分组\\d{4}相匹配的文本（如果有的话），第 2 项是与 reDate 的第 2 个分组\\d{2}相匹配的文本（如果有的话），以此类推。正则表达式的组以()包起来。 上面的案例，若是日期格式变成月日年，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例： 12345678const reDate = /(\\d&#123;2&#125;)-(\\d&#123;2&#125;)-(\\d&#123;4&#125;)/,//表达式结构变化了 match = reDate.exec(\"08-06-2018\");console.log(match);//&gt;&gt; [08-06-2018, 08, 06, 2018]//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？let year = match[3]; //&gt;&gt; 2018let month = match[1]; //&gt;&gt; 08let day = match[2]; //&gt;&gt; 06 可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号?&lt;name&gt;来命名捕获组（也即“匹配到的组”），示例如下： 123456789const reDate = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/, match = reDate.exec(\"2018-08-06\");console.log(match);//&gt;&gt; [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！let year = match.groups.year; //&gt;&gt; 2018let month = match.groups.month; //&gt;&gt; 08let day = match.groups.day; //&gt;&gt; 06 命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的groups属性中。 正则表达式后行断言先看看正则表达式先行断言示例： 123456const re1 = /\\D(\\d+)/, re2 = /\\D(?=\\d+)/,//\"?=\"是正向先行断言 match1 = re1.exec(\"$123.45\"), match2 = re2.exec(\"$123.45\");console.log(match1[0]); //&gt;&gt; $123console.log(match2[0]); //&gt;&gt; $ (?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion)代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern； (?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion)代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern； (?&lt;=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion)代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern； (?&lt;!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion)代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。 在ES9中，可以允许使用?&lt;=进行正向后行断言，可以获取货币的价格而忽略货币符号。 123const re= /(?&lt;=\\D)[\\d\\.]+/, match = re.exec(\"$123.45\");console.log(match[0]); //&gt;&gt; 123.45 上面的正向后行断言，也就是说\\D这个条件必须满足，但\\D匹配的字符不会作为结果输出（因为先行/后行断言其实只是匹配了一个位置）。如果是下面这样： 12345const re= /(?&lt;=\\D)[\\d\\.]+/, match1 = re.exec(\"123.45\"), match2 = re.exec(\"12345\");console.log(match1 &amp;&amp; match1[0]); //&gt;&gt; 45console.log(match2 &amp;&amp; match1[0]); //&gt;&gt; null 可以看到match1匹配到的是45,这是由于在.前面没有任何符合\\D的匹配内容，它会一直找到符合\\D的内容，也就是.然后返回后面的内容。而match2若是没有满足前面肯定反向断言的条件的话，则结果返回null。 正则表达式 Unicode 转义ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为\\p{...}和\\P{...}，在正则表达式中使用标记 u (unicode) 设置，在\\p的{...}内，可用键值对的方式设置需要匹配的属性而非具体内容。 123const regex = /\\p&#123;Script=Greek&#125;/u;//Greek为希腊语的意思console.log(regex.test('a')); //&gt;&gt; flaseconsole.log(regex.test('Σ')); //&gt;&gt; true ES 10 新特性 新特性 中文说明 Optional catch binding 可选的 catch 变量绑定 JSON superset JSON超集 Symbol.prototype.description Symbol 对象的 description 属性 Function.prototype.toString revision 修订Function.prototype.toString Object.fromEntries Well-formed JSON.stringify 更加友好的JSON.stringify String.prototype.{trimStart,trimEnd} Array.prototype.{flat,flatMap} 可选的 catch 变量绑定在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。 12345//之前是try &#123;&#125; catch(e) &#123;&#125;//ES10之后可以写成，try &#123;&#125; catch &#123;&#125;//省掉了变量e JSON超集什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。 ECMAScript 在标准 JSON.parse 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 U+2028 行分隔符与 U+2029 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 JSON.parse() 执行带如上特殊字符的字符串时，只会收到 SyntaxError 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 SyntaxError 。 Symbol 对象的 description 属性ES10 中为 Symbol 对象添加了只读属性 description ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加description (描述)，能够直接访问description ，对调试是很有用的。 123456789101112let sym = Symbol('foo');//添加的描述内容为“foo”console.log(sym.description);//&gt;&gt; foosym = Symbol();console.log(sym.description);//&gt;&gt; undefined//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它//会再新建一个。sym = Symbol.for('bar');console.log(sym.description);//&gt;&gt; bar 修订Function.prototype.toString函数原型上的方法toString()现在返回精确字符，包括空格和注释。 123456789101112function /* comment */ foo /* another comment */() &#123;&#125;//ES10之前不会打印注释部分console.log(foo.toString()); //&gt;&gt; function foo()&#123;&#125;//ES10里，会把注释一同打印console.log(foo.toString()); //&gt;&gt; function /* comment */ foo /* another comment */ ()&#123;&#125;//注意：//箭头函数是个例外const bar /* comment */ = /* another comment */ () =&gt; &#123;&#125;;console.log(bar.toString()); //&gt;&gt; () =&gt; &#123;&#125; Object.fromEntries在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。 12345678let map = new Map().set('foo', true).set('bar', false);let arr = Array.from(map);let set = new Set(map.values());let obj = &#123; foo: true, bar: false &#125;;//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,//形如：[[\"foo\",true],[\"bar\",false]]let newMap = new Map(Object.entries(obj)); 但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。 123456let map = new Map().set(\"foo\", true).set(\"bar\", false);let obj = Array.from(map).reduce((acc, [key, val]) =&gt; &#123; return Object.assign(acc, &#123; [key]: val &#125;);&#125;, &#123;&#125;); 该特性的目的在于为对象添加一个新的静态方法 Object.fromEntries，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。 12const map = new Map().set(\"foo\", true).set(\"bar\", false);let obj = Object.fromEntries(map); 更加友好的 JSON.stringifyES10 之前，当你使用 JSON.stringify() 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用JSON.stringify()来安全的表示这些不正常的UTF-8字符。 123456789101112let r;r = JSON.stringify(\"❤\"); //正常的UTF-8字符原样输出console.log(r); //&gt;&gt; \"❤\"r = JSON.stringify('\\u2764'); //正常的UTF-8字符编码，输出解码之后的模样console.log(r); //&gt;&gt; \"❤\"r = JSON.stringify(\"\\uDF06\\uD834\"); //不正常的UTF-8字符编码，则以unicode形式输出console.log(r); //&gt;&gt; \"\\udf06\\ud834\"r = JSON.stringify(\"\\uDEAD\"); //不正常的UTF-8字符编码，则以unicode形式输出console.log(r); //&gt;&gt; \"\\udead\" String.prototype.{trimStart,trimEnd}新增了String的trimStart()方法和trimEnd()方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。 Array.prototype.{flat,flatMap}这个特性新创造了两个方法，其中： Array.prototype.flat 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回； Array.prototype.flatMap 首先会执行一次map()方法，然后再通过类似flat()方法扁平化数组。它等同于执行完 map() 后再执行一次 flat() 方法，所以当你执行 map() 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。 来看几个例子解释一下，首先 flat() 方法支持多维数组的扁平化，其中Infinity可以将多维数组压扁成一维数组。 123456789let r;r = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat();//4维数组，默认降维1，变成3维数组console.log(r); //&gt;&gt; [ '1', '8', [ '9', ['1'] ] ]r = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat(2); //4维数组，降维2，变成2维数组console.log(r); //&gt;&gt; [ '1', '8', '9', ['1'] ]r = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat(Infinity);//4维数组，最多变成1维数组console.log(r); //&gt;&gt; [ '1', '8', '9', '1' ] 接着来看看flatMap() 123456let r;r = [\"I love\", \"coffe 1891\"].map(item =&gt; item.split(\" \"));console.log(r); //&gt;&gt; [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]r = [\"I love\", \"coffe 1891\"].flatMap(item =&gt; item.split(\" \"));console.log(r); //&gt;&gt;[ 'I', 'love', 'coffe', '1891' ] ES 11 新特性一览 新特性 中文说明 String.prototype.matchAll import() import()函数 Promise.allSettled String.prototype.matchAllmatchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 matchAll 出现之前，通过在循环中调用Regexp.exec来获取所有匹配项信息（Regexp需使用/g标志）： 12345678const regexp = RegExp('foo*','g');const str = 'coffe football, foosball';while ((matches = regexp.exec(str)) !== null) &#123; console.log(`找到 $&#123;matches[0]&#125;，下一轮循环从位置 $&#123;regexp.lastIndex&#125; 开始`); //&gt;&gt; 找到 foo，下一轮循环从位置 9 开始 //&gt;&gt; 找到 foo，下一轮循环从位置 19 开始&#125; 如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用/g标志）。使用matchAll 会得到一个迭代器的返回值，配合 for...of，array spread，Array.from() 可以更方便实现功能。 123456789101112131415161718const regexp = RegExp('foo*','g');const str = 'coffe football, foosball';let matches = str.matchAll(regexp);for (const match of matches) &#123; console.log(match);&#125;//&gt;&gt; [ \"foo\" ]//&gt;&gt; [ \"foo\" ]//注意：//matches的迭代器在for..of之后已经被消耗掉了，//需要再次调用matchAll创建一个新的迭代器matches = str.matchAll(regexp);let arr = Array.from(matches, m =&gt; m[0]);console.log(arr);//&gt;&gt; [ \"foo\", \"foo\" ] import()函数这个特性为JavaScript添加了一个类函数（function-like）的import()功能，以便可以像函数传参那样传入参数实现动态（没错，import是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用import()开启懒加载。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;nav&gt; &lt;a href&#x3D;&quot;books.html&quot; data-entry-module&#x3D;&quot;books&quot;&gt;书籍&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;movies.html&quot; data-entry-module&#x3D;&quot;movies&quot;&gt;电影&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;video-games.html&quot; data-entry-module&#x3D;&quot;video-games&quot;&gt;电视游戏&lt;&#x2F;a&gt;&lt;&#x2F;nav&gt;&lt;main&gt;内容将会加载到这里！&lt;&#x2F;main&gt;&lt;script&gt; const main &#x3D; document.querySelector(&quot;main&quot;); for (const link of document.querySelectorAll(&quot;nav &gt; a&quot;)) &#123; link.addEventListener(&quot;click&quot;, e &#x3D;&gt; &#123; e.preventDefault(); import(&#96;.&#x2F;section-modules&#x2F;$&#123;link.dataset.entryModule&#125;.js&#96;)&#x2F;&#x2F;动态引用 .then(module &#x3D;&gt; &#123;&#x2F;&#x2F;加载模块成功以后，该模块会当作then方法的参数 module.loadPageInto(main); &#125;) .catch(err &#x3D;&gt; &#123;&#x2F;&#x2F;捕捉异常 main.textContent &#x3D; err.message; &#125;); &#125;); &#125;&lt;&#x2F;script&gt; 请注意import()和import的区别： import() 可以用在script脚本区，不止是模块内； 如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）； import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数； import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如import（“/foo.js”）中，实现仍然可以执行静态分析优化。 如果模块采用default的形式对外暴露接口，则可用default属性直接获得。 1234import('./module.js').then(module =&gt; &#123; console.log(module.default);//直接通过default属性获得模块暴露的接口&#125;); Promise.allSettled为什么要有Promise.allSettled()？ 举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。 在多个promise同时进行时咱们很快会想到使用Promise.all来进行包装，但是由于Promise.all的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。 Promise.allSettled跟Promise.all类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态，而不管其是否处理成功。 123456Promise.allSettled([Promise.resolve(\"coffe\"), Promise.reject(\"1891\")]).then( arr =&gt; &#123; console.log(arr); //&gt;&gt; [ &#123; status: \"fulfilled\", value: \"coffe\"&#125;, //&gt;&gt; &#123; status: \"rejected\", reason: \"1891\" &#125; ] &#125;); 本篇结语很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"post","slug":"框架相关-virtual-dom","date":"2020-05-13T17:28:22.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"框架相关-virtual-dom/","link":"","permalink":"http://kobin.top/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3-virtual-dom/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"typeof 实现原理","slug":"javascript-typeof","date":"2020-05-06T23:11:22.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-typeof/","link":"","permalink":"http://kobin.top/javascript-typeof/","excerpt":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如","text":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 123let s = new String(\"abc\");typeof s === \"object\"; // trues instanceof String; // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 `null`：所有机器码均为0 `undefined`：用 −2^30 整数来表示所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 1null instanceof null; // TypeError: Right-hand side of 'instanceof' is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留 bug，可以参考 typeof. 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括 symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是 Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 123456789Object.prototype.toString.call(1); // \"[object Number]\"Object.prototype.toString.call(\"hi\"); // \"[object String]\"Object.prototype.toString.call(&#123; a: \"hi\" &#125;); // \"[object Object]\"Object.prototype.toString.call([1, \"a\"]); // \"[object Array]\"Object.prototype.toString.call(true); // \"[object Boolean]\"Object.prototype.toString.call(() =&gt; &#123;&#125;); // \"[object Function]\"Object.prototype.toString.call(null); // \"[object Null]\"Object.prototype.toString.call(undefined); // \"[object Undefined]\"Object.prototype.toString.call(Symbol(1)); // \"[object Symbol]\" instanceof 操作符的实现原理之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 123let person = function () &#123;&#125;;let nicole = new person();nicole instanceof person; // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 123456let person = function () &#123;&#125;;let programmer = function () &#123;&#125;;programmer.prototype = new person();let nicole = new programmer();nicole instanceof person; // truenicole instanceof programmer; // true instanceof 实现原理： 12345678910111213function new_instance_of(leftVaule, rightVaule) &#123; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__; &#125;&#125; 总结简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"一些 JS 关键技术的底层实现汇总","slug":"javascript-js-basic-implementation","date":"2020-05-06T22:40:35.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-js-basic-implementation/","link":"","permalink":"http://kobin.top/javascript-js-basic-implementation/","excerpt":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。","text":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() new 的原理 reduce 实现原理 双向绑定 继承 Object.create instanceof 实现 Array.isArray 实现 getOwnPropertyNames 实现 Promise 实现 防抖/节流 函数柯里化实现 实现简单深拷贝 Function.prototype.call()call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。 语法：fun.call(thisArg, arg1, arg2, ...) 123456789101112131415161718192021222324252627282930313233/** * call的实现原理 */const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;Function.prototype.mcall = function (context) &#123; context = context ? Object(context) : getGlobal(); const fn = Symbol(\"anything\"); //创建一个不重复的常量 context[fn] = this; let args = [...arguments].slice(1); let r = context[fn](...args); delete context[fn]; return r;&#125;;/** * 一个用call实现继承的例子 * @param &#123;*&#125; name * @param &#123;*&#125; price */function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Fruit(name, price) &#123; Product.mcall(this, name, price); this.category = \"fruit\";&#125;var apple = new Fruit(\"apple\", 5);console.log(apple); Function.prototype.apply()apply()调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数. 语法： func.apply(thisArg, [argsArray]) 1234567891011121314151617181920212223242526272829303132333435const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * apply原理 */Function.prototype.apply = function (context, arr) &#123; context = context ? Object(context) : getGlobal(); console.log(\"context\", context); const fn = Symbol(\"anything\"); //创建一个不重复的常量 context[fn] = this; // let args = [...arguments][1]; if (!arr) &#123; let r = context[fn](); delete context[fn]; return r; &#125; let r = context[fn](...arr); delete context[fn]; return r;&#125;;//使用例子var array = [\"a\", \"b\"];var elements = [0, 1, 2];array.push.apply(array, elements);console.log(\"array\", array); // [\"a\", \"b\", 0, 1, 2]function A(x, y) &#123; console.log(this.b + \" \" + x + \" \" + y);&#125;var B = &#123; b: 1 &#125;;A.apply(B, [2, 3]); Function.prototype.bind()bind()方法创建一个新函数, 在调用时设置 this 关键字为提供的值。 语法：fun.bind(thisArg, arg1, arg2, ...) 12345678910111213141516171819202122const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * bind实现原理 */Function.prototype.bind = function (context) &#123; context = context ? Object(context) : getGlobal(); const me = this; const args = [...arguments].slice(1); return function () &#123; me.apply(context, [...args, ...arguments]); &#125;;&#125;;function A(x, y) &#123; console.log(this.b + \", \" + x + \", \" + y);&#125;var B = &#123; b: 1 &#125;;let fnc = A.bind(B, 2); //1 2 3fnc(3); new 的原理在了解 new 原理之前先看看 js 的内部机制图 我们需要知道当 new 的时候做了什么事情 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 new 没法重写，这里是有 mockNew 函数来模拟 1234567891011121314151617181920212223242526272829303132/** * new实现原理 */function mockNew() &#123; //创建一个实例 const obj = &#123;&#125;; //获得构造器 const constructor = [].shift.call(arguments); //实现继承，实例可以访问构造器熟悉 obj.__proto__ = constructor.prototype; //调用构造器，改变this指向为实例 const res = constructor.apply(obj, arguments); //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象 return res instanceof Object ? res : obj;&#125;/** * 使用例子 * @param &#123;*&#125; color * @param &#123;*&#125; name */function Car(color, name) &#123; this.color = color; return &#123; name: name, &#125;;&#125;let car = mockNew(Car, \"black\", \"BMW\");console.log(car.color);// undefinedconsole.log(car.name);// \"BMW\" reduce 实现原理12345678910111213141516171819202122232425262728293031323334/** * 实现原理 */Array.prototype.mockReduce = function (callback) &#123; const length = this.length; let reducer = undefined, //累加器，最终返回这个值 k = 0, //数组下标 initVal = [...arguments].length &gt; 1 ? [...arguments][1] : undefined; //传入reduce的初始值 if (typeof callback !== \"function\") &#123; throw new TypeError(callback + \" is not a function\"); &#125; if (length === 0 &amp;&amp; !initVal) &#123; throw new TypeError(\"Reduce of empty array with no initial value\"); &#125; if (initVal) &#123; reducer = initVal; &#125; else &#123; reducer = this[0]; k++; &#125; while (k &lt; length) &#123; if (this.hasOwnProperty(k)) &#123; const kValue = this[k]; reducer = callback(reducer, kValue); &#125; k++; &#125; return reducer;&#125;;const rReduce = [].reduce((a, b) =&gt; a + b, 3);const mReduce = [].mockReduce((a, b) =&gt; a + b);console.log(rReduce, mReduce); 双向绑定defineProperty实现 123456789101112131415161718// 数据const data = &#123; text: \"hello\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持Object.defineProperty(data, \"text\", &#123; // 数据变化 --&gt; 修改视图 set(newVal) &#123; input.value = newVal; p.innerHTML = newVal; &#125;,&#125;);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; data.text = e.target.value;&#125;); proxy实现 12345678910111213141516171819202122// 数据const data = &#123; text: \"default\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持const handler = &#123; set(target, key, value) &#123; target[key] = value; // 数据变化 --&gt; 修改视图 input.value = value; p.innerHTML = value; return value; &#125;,&#125;;const proxy = new Proxy(data, handler);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; proxy.text = e.target.value;&#125;); 继承12345678910111213141516171819202122232425function inheritPrototype(subType, superType) &#123; var protoType = Object.create(superType.prototype); //创建对象 protoType.constructor = subType; //增强对象 subType.prototype = protoType; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; alert(this.age);&#125;;var instance = new SubType(\"Bob\", 18);instance.sayName();instance.sayAge(); Object.create1234567891011121314151617181920if (typeof Object.create !== \"function\") &#123; Object.create = function (prototype, properties) &#123; if (typeof prototype !== \"object\") &#123; throw TypeError(); &#125; function Ctor() &#123;&#125; Ctor.prototype = prototype; var o = new Ctor(); if (prototype) &#123; o.constructor = Ctor; &#125; if (properties !== undefined) &#123; if (properties !== Object(properties)) &#123; throw TypeError(); &#125; Object.defineProperties(o, properties); &#125; return o; &#125;;&#125; instanceof 实现原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null 1234567891011// L 表示左表达式，R 表示右表达式function instance_of(L, R) &#123; var O = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; // 这里重点：当 O 严格等于 L 时，返回 true if (O === L) return true; L = L.__proto__; &#125;&#125; Array.isArray 实现12345Array.myIsArray = function (o) &#123; return Object.prototype.toString.call(Object(o)) === \"[object Array]\";&#125;;console.log(Array.myIsArray([])); // true getOwnPropertyNames 实现123456789101112131415if (typeof Object.getOwnPropertyNames !== \"function\") &#123; Object.getOwnPropertyNames = function (o) &#123; if (o !== Object(o)) &#123; throw TypeError(\"Object.getOwnPropertyNames called on non-object\"); &#125; var props = [], p; for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) &#123; props.push(p); &#125; &#125; return props; &#125;;&#125; Promise 实现实现原理：其实就是一个发布订阅者模式 构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数 then 时收集依赖，将回调函数收集到 成功/失败队列 executor 函数中调用 resolve/reject 函数 resolve/reject 函数被调用时会通知触发队列中的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209const isFunction = variable =&gt; typeof variable === 'function';// 定义Promise的三种状态常量const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';class MyPromise &#123; // 构造函数，new 时触发 constructor(handle: Function) &#123; try &#123; handle(this._resolve, this._reject); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 状态 pending fulfilled rejected private _status: string = PENDING; // 储存 value，用于 then 返回 private _value: string | undefined = undefined; // 失败队列，在 then 时注入，resolve 时触发 private _rejectedQueues: any = []; // 成功队列，在 then 时注入，resolve 时触发 private _fulfilledQueues: any = []; // resovle 时执行的函数 private _resolve = val =&gt; &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; this._status = FULFILLED; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* * 如果resolve的参数为Promise对象， * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变 * 且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; runRejected(err); &#125; ); &#125; else &#123; this._value = val; runFulfilled(val); &#125; &#125;; // 异步调用 setTimeout(run); &#125;; // reject 时执行的函数 private _reject = err =&gt; &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run); &#125;; // then 方法 then(onFulfilled?, onRejected?) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 const fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; const res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 const rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; const res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // catch 方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // finally 方法 finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125; // 静态 resolve 方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 静态 reject 方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 静态 all 方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // 返回值的集合 let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125;&#125; 防抖/节流防抖函数 onscroll 结束时触发一次，延迟执行123456789101112131415function debounce(callback, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; callback.apply(context, args); &#125;, wait); &#125;;&#125;// 使用window.onscroll = debounce(function () &#123; console.log(\"debounce\");&#125;, 1000); 节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样1234567891011121314function throttle(callback, delay) &#123; var prevTime = Date.now(); return function () &#123; var curTime = Date.now(); if (curTime - prevTime &gt; delay) &#123; callback.apply(this, arguments); prevTime = curTime; &#125; &#125;;&#125;// 使用window.onscroll = throttle(function () &#123; console.log(\"throtte\");&#125;, 1000); 函数柯里化实现其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。应用场景： 延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数） 动态创建函数 （参数不够时会返回接受剩下参数的函数） 参数复用（每个参数可以多次复用） 123456789101112const curry = (fn) =&gt; (judge = (...args) =&gt; args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg));const sum = (a, b, c, d) =&gt; a + b + c + d;const currySum = curry(sum);currySum(1)(2)(3)(4); // 10currySum(1, 2)(3)(4); // 10currySum(1)(2, 3)(4); // 10 实现简单深拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; \"[object Boolean]\": \"boolean\", \"[object Number]\": \"number\", \"[object String]\": \"string\", \"[object Function]\": \"function\", \"[object Array]\": \"array\", \"[object Date]\": \"date\", \"[object RegExp]\": \"regExp\", \"[object Undefined]\": \"undefined\", \"[object Null]\": \"null\", \"[object Object]\": \"object\", &#125;; if (obj instanceof Element) &#123; // 判断是否是dom元素，如div等 return \"element\"; &#125; return map[str];&#125;function deepCopy(original) &#123; const type = getType(original); let copy; switch (type) &#123; case \"array\": return copyArray(original, copy); case \"object\": return copyObject(original, copy); case \"function\": return copyFunction(original, copy); default: return original; &#125;&#125;function copyArray(original, copy = []) &#123; for (const [index, value] of original.entries()) &#123; copy[index] = deepCopy(value); &#125; return copy;&#125;function copyObject(original, copy = &#123;&#125;) &#123; for (const [key, value] of Object.entries(original)) &#123; copy[key] = deepCopy(value); &#125; return copy;&#125;function copyFunction(original, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(original.toString()); fn.prototype = original.prototype; return fn;&#125;const arr1 = [1, 2, [3, 4], &#123; i: 6, j: 6 &#125;, (k, m) =&gt; k + m];console.log(deepCopy(arr1));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"循序渐进数据结构与算法 - 线性表","slug":"algorithms-线性表基础汇总","date":"2019-12-05T14:25:24.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"algorithms-线性表基础汇总/","link":"","permalink":"http://kobin.top/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/","excerpt":"数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。 本系列所有示例均采用JavaScript，旨在入门数据结构与算法。 本节主要是讲解下基础数据结构 - 线性表 相关的内容。","text":"数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。 本系列所有示例均采用JavaScript，旨在入门数据结构与算法。 本节主要是讲解下基础数据结构 - 线性表 相关的内容。 线性表 与 非线性表线性表（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是典型线性表结构。 非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。 数组 定义数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。数组的索引是从 0 开始的。 特点数组是用一组连续的内存空间来存储的。 所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。 低效的插入和删除。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n) 实现JavaScript 原生支持数组，而且提供了很多操作方法，JavaScript数组支持的方法可见下表： 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries() 返回数组的可迭代对象。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 from() 通过给定的对象中创建一个数组。 includes() 判断一个数组是否包含一个指定的值。 indexOf() 搜索数组中的元素，并返回它所在的位置。 isArray() 判断对象是否为数组。 join() 把数组的所有元素放入一个字符串。 keys() 返回数组的可迭代对象，包含原始数组的键(key)。 lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 栈 定义 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。 不包含任何元素的栈称为空栈。 栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Stack() &#123; this.data = []; /** * 添加一个（或几个）新元素到栈顶。 */ this.push = function (element) &#123; this.data.push(element); &#125;; /** * 移除栈顶的元素，同时返回被移除的元素。 */ this.pop = function () &#123; return this.data.pop(); &#125;; /** * 返回栈顶的元素，不对栈做任何修改。 */ this.peek = function () &#123; return this.data[this.data.length - 1]; &#125;; /** * 如果栈里没有任何元素就返回 true，否则返回 false */ this.isEmpty = function () &#123; return this.data.length === 1; &#125;; /** * 移除栈里的所有元素 */ this.clear = function () &#123; this.data = []; &#125;; /** * 返回栈里的元素个数。 */ this.size = function () &#123; return this.data.length; &#125;; // 打印栈里的元素 this.print = function () &#123; console.log(this.data.toString()); &#125;;&#125; 使用场景 举一个判断回文的例子： 12345678910111213141516function isPalindrome(word) &#123; var s = new Stack(); for (var i = 0; i &lt; word.length; i++) &#123; s.push(word[i]); &#125; var rword = \"\"; while (s.length() &gt; 0) &#123; rword += s.pop(); &#125; return word == rword;&#125;console.log(isPalindrome(\"level\")); // trueconsole.log(isPalindrome(\"1001\")); // trueconsole.log(isPalindrome(\"word\")); // false 队列 定义 队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。 最新添加的元素必须排在队列的末尾。 队列只有 入队 push() 和出队 pop()。 队列又可以细分为普通队列、优先队列、循环队列。 普通队列 实现 123456789101112131415161718192021222324252627282930313233343536373839// Queue类function Queue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element) &#123; this.data.push(element); &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; console.log(this.data.toString()); &#125;;&#125; 使用场景 击鼓传花游戏的实现： 1234567891011121314151617181920212223242526272829303132333435// 实现击鼓传花function hotPotato(nameList, num) &#123; var queue = new Queue(); for (var i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); &#125; var eliminated = \"\"; while (queue.size() &gt; 1) &#123; // 循环 num 次，队首出来去到队尾 for (var i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); &#125; // 循环 num 次过后，移除当前队首的元素 eliminated = queue.dequeue(); console.log(`$&#123;eliminated&#125; 在击鼓传花中被淘汰！`); &#125; // 最后只剩一个元素 return queue.dequeue();&#125;// 测试var nameList = [\"张三\", \"李四\", \"王五\", \"马六\", \"牛七\"];var winner = hotPotato(nameList, 5);console.log(`最后的胜利者是：$&#123;winner&#125;`);// =&gt; 牛七 在击鼓传花中被淘汰！// =&gt; 张三 在击鼓传花中被淘汰！// =&gt; 王五 在击鼓传花中被淘汰！// =&gt; 马六 在击鼓传花中被淘汰！// =&gt; 最后的胜利者是：李四 优先队列 定义优先队列中元素的添加和移除会根据优先级来处理 场景优先队列一个典型的场景就是机场登机，头等舱和商务舱乘客的优先级要高于经济舱乘客。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://kobin.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"zhan","slug":"zhan","permalink":"http://kobin.top/tags/zhan/"}]},{"title":"promise高级用法","slug":"javascript-promise高级用法","date":"2019-08-02T22:49:39.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-promise高级用法/","link":"","permalink":"http://kobin.top/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","excerpt":"对于Promise高级用法的使用汇总，包括多个promise串行执行、多个promise并行执行以及限制并行等","text":"实现多个promise串行执行在 async/await 以前 Promise 串行执行还是比较麻烦的，除了依赖 async、promise-fun 等工具库，我们还可以使用 Array.prototype.reduce() 自己实现一个简单的串行Promise了： 123456789/** * 核心代码 **/function runPromiseByQueue(myPromises) &#123; myPromises.reduce( (previousPromise, nextPromise) =&gt; previousPromise.then(() =&gt; nextPromise()), Promise.resolve() );&#125; 当上一个 Promise 开始执行（previousPromise.then），当其执行完毕后再调用下一个 Promise，并作为一个新 Promise 返回，下次迭代就会继续这个循环。 举个例子： 12345678910111213141516171819const createPromise = (time, id) =&gt; () =&gt; new Promise((solve) =&gt; &#123; console.time(\"time\" + id); setTimeout(() =&gt; &#123; console.log(\"promise\", id); console.timeEnd(\"time\" + id); if (id == 3) &#123; console.timeEnd(\"timeall\"); &#125; solve(); &#125;, time); &#125;);console.time(\"timeall\");runPromiseByQueue([ createPromise(3000, 1), createPromise(2000, 2), createPromise(1000, 3),]); 最后的输出结果如下： 说明确实是串行依次执行了三个promise。 实现多个promise并行执行这个目前ES官方已经实现了promise.all/promise.allSettled/promise.race等方法，以promise.all()为例： 12345678910const promise1 = Promise.resolve(3);const promise2 = 42;const promise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'foo');&#125;);Promise.all([promise1, promise2, promise3]).then((values) =&gt; &#123; console.log(values);&#125;);// expected output: Array [3, 42, \"foo\"] Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。 那么如果promises数组是包含几十个甚至几百个http请求，直接用Promise.all的话，会瞬间发出所有的http请求，造成请求拥堵甚至失败。 这时候就需要对Promise.all做并发限制。 promise.all并行限制首先需要明白的是，promise并不是在调用Promise.all才执行，而是在实例化promise对象的时候就执行了，在理解这一点的基础上，就可以从promise实例化上下手实现并发限制。具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Promise并发限制 * @param &#123;Array&#125; array * @param &#123;Number&#125; poolLimit */function LimitPromiseAll(array, poolLimit) &#123; let i = 0; //待执行元素的数组下标 const results = []; // promise.all的promises数组 const executing = []; // 存放正在执行 const enqueue = function () &#123; // 边界处理，array为空数组 if (i === array.length) &#123; return Promise.resolve(); &#125; // 每调一次enqueue，初始化一个promise const fn = array[i++]; // 如果curPromise不是Promise对象。则转成Promise 对象 // 等同于 const p = Promise.resolve(fn()); const p = Promise.resolve().then(() =&gt; fn()); // 放入promises数组 results.push(p); // promise执行完毕，从executing数组中删除 const e = p.then((res) =&gt; &#123; executing.splice(executing.indexOf(e), 1); &#125;); //正在执行的promise, 插入executing数组 executing.push(e); // 当executing数组中promise数量低于poolLimit，就实例化新的promise并执行, // 否则调用promise.race()获取到最快执行完成的promise（将其从executing数组删除，便可继续后续执行） let r = Promise.resolve(); if (executing.length &gt;= poolLimit) &#123; r = Promise.race(executing); &#125; // 递归，直到遍历完array return r.then(() =&gt; enqueue()); &#125;; return enqueue().then(() =&gt; Promise.all(results));&#125; 使用例子： 1234567891011121314151617181920console.time(\"all-time\");const timeout = (i) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(i), i));LimitPromiseAll( [ timeout.bind(null, 1000), timeout.bind(null, 5000), timeout.bind(null, 2000), timeout.bind(null, 4000), ], 2).then((res) =&gt; &#123; console.log(res); console.timeEnd(\"all-time\");&#125;);/**输出： [ 1000, 5000, 2000, 4000 ] all-time: 7037.285ms **/ 其实，目前社区里已经有一些开源包实现了这个功能，比如async-pool、es6-promise-pool、p-limit。上述实现代码也是参考async-pool的实现。 使用Promise实现fetch超时处理因为fetch默认没有请求超时设置，以及中断请求操作，在这里我们尝试使用Promise结合AbortController封装一个简单的请求超时和中断请求的fetch。 AbortController接口代表一个控制器对象，允许你在需要时中止一个或多个DOM请求目前IE外的主流浏览器基本都实现了AbortController功能； AbortController的浏览器兼容情况： 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637function TimeoutFetch(params) &#123; this.controller = new AbortController(); //实例化AbortController this.signal = this.controller.signal; //signal用来 abort 请求 this.timeout = 5000; //默认超时时间&#125;/** * 设置超时时间 */TimeoutFetch.prototype.setTimeout = function (ms) &#123; this.timeout = ms;&#125;;/** * 封装fetch请求 */TimeoutFetch.prototype.fetch = function (url, data = &#123;&#125;) &#123; const timeoutPromise = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; code: 1, msg: `timeout of $&#123;this.timeout&#125;ms`, &#125;); this.controller.abort(); &#125;, this.timeout); &#125;); const fetchPromise = fetch(url, &#123; signal: this.signal, //设置信号 ...data, &#125;); return Promise.race([fetchPromise, timeoutPromise]);&#125;;/** * 手动中断请求 */TimeoutFetch.prototype.abort = function () &#123; this.controller.abort();&#125;; 使用例子： 12345const timeoutFetch = new TimeoutFetch();timeoutFetch.setTimeout(30);timeoutFetch.fetch(\"http://localhost/data\").then((res) =&gt; &#123; console.log(res);&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"},{"name":"promise","slug":"promise","permalink":"http://kobin.top/tags/promise/"}]},{"title":"通过iframe下载文件如何判断下载完成","slug":"javascript-iframe-download-complete","date":"2019-07-06T22:24:20.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-iframe-download-complete/","link":"","permalink":"http://kobin.top/javascript-iframe-download-complete/","excerpt":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。","text":"问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = \"http://www.example.com/file.zip\";var iframe = document.createElement(\"iframe\");iframe.src = url;iframe.style.display = \"none\";iframe.onload = function () &#123; console.debug(\"start downloading...\"); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 这里说一下 Content-disposition： Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。 解决思路二：添加 header 配置123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(\"X-Content-Type-Options\", \"nosniff\");// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(\"X-Frame-Options\", \"deny\"); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(\"iframedownload\"); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == \"complete\" || iframeDoc.readyState == \"interactive\" ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"iframe","slug":"iframe","permalink":"http://kobin.top/tags/iframe/"},{"name":"download","slug":"download","permalink":"http://kobin.top/tags/download/"}]},{"title":"nginx初试","slug":"others-nginx-basic","date":"2019-05-25T18:35:46.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"others-nginx-basic/","link":"","permalink":"http://kobin.top/others-nginx-basic/","excerpt":"“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。” 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。","text":"“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。” 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。 一、初试 Nginx想要成为一个合格的大前端，又怎能不会 Nginx 呢？ Nginx 从 2004 年发展至今，从一开始的完善沉淀，再迅速蹿升为“网红”，再到现在占服务器市场中接近 1/3 份额，成为互联网网站搭建的必选技术之一。发展可谓相当迅速，之所以能取得如此成就，主要还是相对于其他 HTTP 服务器其有着不可替代的优势： 支持海量高并发：采用 IO 多路复用 epoll。官方测试 Nginx 能够支持 5 万并发链接，实际生产环境中可以支撑 2-4 万并发连接数。 内存消耗少：在主流的服务器中 Nginx 目前是内存消耗最小的了，比如我们用 Nginx+PHP，在 3 万并发链接下，开启 10 个 Nginx 进程消耗 150M 内存。 免费使用可以商业化：Nginx 为开源软件，采用的是 2-clause BSD-like 协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 而对于前端童鞋，在实际工作上，更倾向于用 Nodejs 来搭建服务器，进而实现一些需求，对 Nginx 有天然的疏远感。的确，Nginx 中的绝大部分功能，如果单纯的使用 Node.js 也可以满足和实现。但实际上，Nginx 和 Node.js 并不冲突，都有自己擅长的领域：Nginx 更擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长于上层具体业务逻辑的处理。如果将两者组合一起，则可以更加助力前端开发。 开始动手之前先交代下具体的系统环境： 系统环境说明：服务器：阿里云 ECS操作系统： CentOS 7.4 64 位Nginx 版本：nginx/1.16.1 二、Nginx 的安装首先可以查看下系统的 yum 源下是否有可用的 Nginx 包 1yum list | grep nginx 如果结果类似如图内容，说明 yum 源是存在的 如果不存在或者没有需要的 Nginx 版本，则可以自己配一个 yum 源。 打开终端，输入 1vim /etc/yum.repos.d/nginx.repo 往里面添加如下脚本： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/$&#123;OS&#125;/$&#123;OSRELEASE&#125;/$basearch/gpgcheck=0enabled=1 需要注意：OS: 操作系统名称，如：centosOSRELEASE: 操作系统版本，如： 7对应的 baseurl: baseurl=http://nginx.org/packages/centos/7/$basearch/ 保存修改后，就可以安装 Nginx 了，安装命令： 1yum install nginx 安装完成后查看安装的 Nginx 版本: 1nginx -v 三、Nginx 基本配置安装完 Nginx 后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看： 1rpm -ql nginx rpm 是 linux 的 rpm 包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到 nginx 的所有安装位置了。 下面重点罗列下一些重要的文件 nginx.conf nginx.conf 文件是 Nginx 总配置文件，在我们搭建服务器时经常调整的文件。 进入 etc/nginx 目录下，然后用 vim 进行打开 12cd /etc/nginxvim nginx.conf 下面是文件的详细注释: 12345678910111213141516171819202122232425262728293031323334#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件&#125; default.conf进入 conf.d 目录，打开 default.conf，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 四、Nginx 常用操作启动 Nginx 服务 Nginx 直接启动（CentOS7.4 以上版本） 1nginx 使用 systemctl 命令启动 1systemctl start nginx.service 查看服务运行状态 1ps aux | grep nginx 关停 Nginx 服务 立即停止服务 1nginx -s stop 这种方法比较强硬，无论进程是否在工作，都直接停止进程。 从容停止服务 1nginx -s quit 这种方法较 stop 相比就比较温和一些了，需要进程完成当前工作后再停止。 killall 方法杀死进程 1killall nginx 这种方法也是比较野蛮的，直接杀死进程。 systemctl 停止 1systemctl stop nginx.service 重启 Nginx 服务1systemctl restart nginx.service 重新载入配置文件在重新编写或者修改 Nginx 的配置文件后，需要作一下重新载入，这时候可以用这个命令。 1nginx -s reload 查看端口号如果 80 端口被占用，可以使用此命令查看端口占用情况 1netstat -tlnp 80 五、自定义错误页面以及访问控制 多错误指向一个页面 1error_page 500 502 503 504 /50x.html; 单独为错误置顶处理方式 1error_page 404 /404_error.html; 把错误码换成一个地址 1error_page 404 http://kobin.top; 简单实现访问控制 有时候我们的服务器只允许特定主机访问，比如内部 OA 系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些 IP 访问，我们可以直接在 location 里进行配置。 可以直接在 default.conf 里进行配置。 1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 指令优先级 1234location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置表示只允许45.76.202.231进行访问，其他的 IP 是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？ 会发现所有的 IP 都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。 复杂访问控制权限匹配 在工作中，访问权限的控制需求更加复杂，例如，对于网站下的 img（图片目录）是运行所有用户访问，但对于网站下的 admin 目录则只允许公司内部固定 IP 访问。这时候仅靠 deny 和 allow 这两个指令，是无法实现的。我们需要 location 块来完成相关的需求匹配。 上面的需求，配置代码如下： 123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; 使用正则表达式设置访问权限 只有精确匹配(=)有时是完不成我们的工作任务的，比如现在我们要禁止访问所有 php 的页面，php 的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。 代码如下： 123location ~\\.php$ &#123; deny all; &#125; 这样我们再访问的时候就不能访问以 php 结尾的文件了。是不是让网站变的安全很多了那？ 六、Nginx 配置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供 Web 服务，并且互不干扰。用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上。可以大大节约服务器成本与维护成本。 基于端口号配置虚拟主机 基于端口号来配置虚拟主机，算是 Nginx 中最简单的一种方式了。原理就是 Nginx 监听多个端口，根据不同的端口号，来区分不同的网站 我习惯在 conf.d 里新建一个配置文件来配置新的虚拟主机，但也可以配置在主配置 etc/nginx/nginx.conf里，也可以配置在etc/nginx/conf.d/default.conf里。 12345678server&#123; listen 8088; server_name localhost; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于 IP 的虚拟主机 基于 IP 和基于端口的配置几乎一样，只是把server_name选项，配置成 IP 就可以了。 12345678server&#123; listen 80; server_name 112.74.164.244; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于域名的虚拟主机 域名设置虚拟主机也非常简单，主要操作的是配置文件的 server_name 项 12345678910111213141516server&#123; listen 80; server_name nginx.kobin.com; location / &#123; root /usr/share/nginx/html/html; index index.html index.htm; &#125;&#125;server&#123; listen 80; server_name nginx2.kobin.com; location / &#123; root /usr/share/nginx/html/html8001; index index.html index.htm; &#125;&#125; 七、Nginx 反向代理的设置什么是反向代理？ 互联网应用基本都基于 CS 基本结构，即 client 端和 server 端。代理其实就是在 client 端和真正的 server 端之前增加一层提供特定服务的服务器，即代理服务器。 在了解反向代理前先了解什么是正向代理。 正向代理 翻墙工具就是一个典型的正向代理工具。它会把我们不能访问的墙外服务器 server 的网页请求，代理到一个可以访问该网站的代理服务器 proxy，这个代理服务器 proxy 把墙外服务器 server 上的网页内容获取，再转发给客户。具体的流程如下图。 其特点如下： 客户端和代理服务器可以直接互相访问，属于一个 LAN（局域网） 代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器 代理服务器通过代理用户端的请求来向域外服务器请求响应内容。 一句话总结： 代理的是客户端 反向代理 反向代理正好相反，客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。 其特点如下： 代理服务器和真正 server 服务器可以直接互相访问，属于一个 LAN（服务器内网） 代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作； 代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。 一句话总结： 代理的是服务器 反向代理的好处： 安全及权限使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须通过 Nginx。可以通过在 Nginx 层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。 负载均衡一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配 简单实现反向代理 举个例子，我们访问 home.kobin.top 这个网站，然后反向代理到 baidu.com 上。可做如下配置： 1234567server&#123; listen 80; server_name home.kobin.top; location / &#123; proxy_pass https://www.baidu.com; &#125;&#125; 结果如下： 其他常用的反向代理配置： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置 Nginx 与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间。 proxy_send_timeout：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的 Location 和 Refresh。 八、Nginx 适配移动端与 PC 端Nginx 通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是 PC 端，进而展示不同的页面给用户。 在 conf.d 目录下新建一个 demo.conf 文件，内容如下： 1234567891011server &#123; listen 80; server_name blog.kobin.top; location / &#123; root /yangling/app/pc; # 默认展示PC端页面 if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') &#123; # 如果匹配到mobile端的user_agent则展示mobile页面 root /yangling/app/mobile; &#125; index index.html; &#125;&#125; 九、Nginx 实现 Gzip 压缩Gzip 是网页的一种网页压缩技术，经过 gzip 压缩后，页面大小可以变为原来的 30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip 网页压缩的实现需要浏览器和服务器的支持。 gzip 是需要服务器和浏览器同事支持的。当浏览器支持 gzip 压缩时，会在请求消息中包含 Accept-Encoding:gzip,这样 Nginx 就会向浏览器发送听过 gzip 后的内容，同时在相应信息头中加入 Content-Encoding:gzip，声明这是 gzip 后的内容，告知浏览器要先解压后才能解析输出。 gzip 配置： gzip : 该指令用于开启或 关闭 gzip 模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。 gzip_comp_level : gzip 压缩比，压缩级别是 1-9，1 的压缩级别最低，9 的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的 User-Agent 不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的 Content-length 中进行获取。 gzip_http_version：识别 HTTP 协议版本，其值可以是 1.1.或 1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩。 gzip_vary : 用于在响应消息头中添加 Vary：Accept-Encoding,使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩。 简单配置： 123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用 gizp 模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和 CSS 文件进行压缩输出。 十、Nginx 与跨域请求举个例子：在 a.com 页面中有请求 b.com 的接口http://b.com/getHomeData, 出现了跨域问题。当然这种跨域问题的处理方式很多，这里主要说下用 Nginx 如何解决。 在 a.com 启个 Nginx 服务，配置如下： 12345678910server &#123; listen 80; server_name a.com; #请求跨域，这里约定代理请求url path是以/apis/开头 location ^~/apis/ &#123; # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配 rewrite ^/apis/(.*)$ /$1 break; proxy_pass https://www.b.com/; &#125;&#125; 这时请求接口 URL 换成http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。 十一、Nginx 与合并请求通过nginx-http-concat插件可以实现将多个资源请求合并为一个请求，达到性能优化目的。 十二、Nginx 与图片处理通过ngx_http_image_filter_module插件实现日常对图片的处理，包括缩放、裁剪、旋转、图片质量等的控制。","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"http://kobin.top/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"http://kobin.top/tags/nginx/"}]},{"title":"文章摘录","slug":"collection","date":"2019-05-06T15:35:35.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"collection/","link":"","permalink":"http://kobin.top/collection/","excerpt":"在这里记录一些看到的好文章好博客","text":"在这里记录一些看到的好文章好博客 龙恩 0707 cdn 全栈修炼 前端进阶之道 大前端面试宝典 - 图解前端 未来可期的 TypeScript 别再说虚拟 DOM 快了，要被打脸的 深入理解虚拟 DOM，它真的不快 Deep In React 之详谈 React 16 Diff 策略(二) ReactFiber 在并发模式下的运行机制 前端浏览器输入 URL 后发生什么 大公司如何部署前端代码 Vuex、Flux、Redux、Redux-saga、Dva、MobX累死累活做业务，绩效还不怎么样，我只能帮你到这了……","categories":[{"name":"面试","slug":"面试","permalink":"http://kobin.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kobin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"基于hexo搭建个人博客并使用GitHub Actions一键发布到GitHub pages & 阿里云ECS","slug":"others-hexo","date":"2019-04-28T15:15:23.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"others-hexo/","link":"","permalink":"http://kobin.top/others-hexo/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装前提安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序： Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本) Git 注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容 安装 Hexo使用 npm: 1$ npm install -g hexo-cli 使用 yarn: 1$ yarn global add hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 常用命令new新建一篇文章 1$ hexo new [layout] &lt;title&gt; generate生成静态文件。 1$ hexo generate publish发表草稿。 1$ hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 1$ hexo server deploy部署网站。 1$ hexo deploy clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 1$ hexo clean list列出网站资料。 1$ hexo list &lt;type&gt; 注： 更多命令见官网 部署 GitHub pages如果您只是想部署到GitHub Actions上，那么可以直接用这节的方法。如果还想部署到阿里云等私人服务器上，那么可以跳过这步，直接看下一节。 新建 GitHub 项目打开 GitHub 点击右上角的new repository 然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建 安装 hexo-deployer-git。1$ npm install hexo-deployer-git --save 修改_config.yml 配置1234deploy: type: git repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git branch: master 执行命令执行 hexo deploy 将生成的文件部署到上一步配置的仓库对应的分支上去。 1hexo clean &amp;&amp; hexo deploy 至此，已经实现了个人博客的搭建并完成了一键发布到GitHub Pages的功能，如果只需要发布到GitHub Pages，那么至此已经可以愉快地写文章了。 但是由于总所周知的原因，GitHub在国内的访问速度总是时好时坏，不够畅快。 那么如果你手里恰好有闲置的云服务器，那么接下去就更进一步吧！🙂 GitHub Actions登场GitHub Actions 是 GitHub 于2018年10月推出的持续集成服务。功能非常强大，具体的基础用法不赘述，可以参阅阮一峰老师的教程。 这里主要介绍如何配置GitHub Actions实现自动部署功能。 创建workflow 文件GitHub Actions 的配置文件叫做 workflow 文件, 存放在代码仓库的.github/workflows目录。 新建.github/workflows/deploy.yml, 具体配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152name: Hexo build and deployon: push: branches: - blog # blog分支是本人的hexo源码分支jobs: build: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v2 # If you're using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly. with: persist-credentials: false # checkout到你的hexo代码分支 ref: blog # hexo需要加载内部子模块 submodules: true # 使用 node:10 - name: use Node.js 10 uses: actions/setup-node@v1 with: node-version: 10 # 安装npm包 &amp; 生成静态文件 - name: Install and publish run: | npm install npm run build # 将静态文件部署到阿里云 - name: Deploy to aliyun server uses: easingthemes/ssh-deploy@v2.0.7 env: SSH_PRIVATE_KEY: $&#123;&#123; secrets.ALIYUN_SERVER_ACCESS_TOKEN &#125;&#125; ARGS: \"-avz --delete\" SOURCE: \"public\" REMOTE_HOST: $&#123;&#123; secrets.ALIYUN_SERVER_HOST &#125;&#125; REMOTE_USER: \"root\" TARGET: \"/code/hexo-blog\" # 静态资源存放目录 # 将静态文件部署到github pages - name: Deploy to Github Pages uses: JamesIves/github-pages-deploy-action@releases/v3 with: ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BASE_BRANCH: blog BRANCH: master FOLDER: public 配置参数说明 ALIYUN_SERVER_HOST： 阿里云服务器公网IP； ALIYUN_SERVER_ACCESS_TOKEN：阿里云.ssh下的私钥(id_rsa); 如果未生成过，可以执行如下命令：1ssh-keygen -m PEM -t rsa -b 4096 把公钥复制一份到authorized_keys中:12cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys ACCESS_TOKEN: GitHub 密钥, 按照官方文档生成一个秘钥。 以上三个参数都保存到自己仓库-&gt;settings-&gt;Secrets里面： 构建结果将整个仓库推送到GitHub，GitHub 发现了 workflow 文件以后，就会自动运行。 至此，我们已经将博客部署到GitHub Actions和阿里云上了。阿里云上我们可以使用Nginx托管静态资源： 12345678server &#123; listen 80; server_name kobin.top; location / &#123; root /code/hexo-blog/public; # 静态资源存放目录 index index.html; &#125;&#125; 一切大功告成！收工😄","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://kobin.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Event Loop详解","slug":"javascript-event-loop","date":"2018-03-01T18:55:10.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-event-loop/","link":"","permalink":"http://kobin.top/javascript-event-loop/","excerpt":"JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 –&gt; http延迟 –&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。 JavaScript用异步回调（asynchronous callback）去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。","text":"JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 –&gt; http延迟 –&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。 JavaScript用异步回调（asynchronous callback）去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。 先了解一点基础知识1. JavaScript的 Engine 和 Runtime简单来说，为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂得多）： 第一部分是Engine（JS引擎）：编译并执行 JavaScript 代码，完成内存分配、垃圾回收等；第二部分是是 Runtime（运行时）：为 JavaScript 提供一些对象或机制，使它能够与外界交互。 举个例子： Chrome浏览器 和 Node.js 都使用了 V8 Engine。V8 实现并提供了 ECMAScript 标准中的所有数据类型、操作符、对象和方法（注意并没有 DOM）。 但它们的 Runtime 并不一样：Chrome 提供了 window、DOM，而 Node.js 则是 require、process 等等。 2. 浏览器的线程现代浏览器的一个 tab ，其中的线程包括但不局限于： GUI 渲染线程 JS引擎线程 事件触发线程 定时器触发线程 异步http请求线程 JavaScript中的异步回调是通过 WebAPIs 去支持的，常见的有 XMLHttpRequest，setTimeout，事件回调（onclik, onscroll等）。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有合适的地方去处理定时器的计时、各种请求的回调。即当代码中出现这几个定义的异步任务，是由浏览器实现了它们与JS引擎的通信，与JS引擎不属与同一个线程。 另外，GUI 渲染和JavaScript执行是互斥的。虽然两者属于不同的线程，但是由于JavaScript执行结果可能会对页面产生影响，所以浏览器对此做了处理，大部分情况下JavaScript线程执行，执行渲染（render）的线程就会暂停，等JavaScript的同步代码执行完再去渲染。 Event loop的定义Event Loop（事件循环） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。Event Loop的作用很简单： 监控调用栈和任务队列（见 3），如果调用栈是空的，它就会取出队列中的第一个”callback函数”，然后将它压入到调用栈中，然后执行它。 总的来说，Event Loop 是实现异步回调的一种机制而已。 1.分两种Event Loop 分为两种，一种存在于 Browsing Context 中，还有一种在 Worker 中。 Browsing Context 是指一种用来将 Document（文档）展现给用户的环境。例如浏览器中的 tab，window 或 iframe 等，通常都包含 Browsing Context。 Worker 是指一种独立于 UI 脚本，可在后台执行脚本的 API。常用来在后台处理一些计算密集型的任务。 本篇重点介绍的是 Browsing Context 中的 Event Loop，相比 Worker 中的 Event Loop，它也更加复杂一些。 另外，Event Loop 并不是在 ECMAScript 标准中定义的，而是在 HTML 标准中定义的。在 JS引擎中（以V8为例），只是实现了 ECMAScript 标准，而并不关心什么 Event Loop。也就是说 Event Loop 是属于 JavaScript Runtime 的，是由宿主环境（比如浏览器）提供的。所以千万不要理解错了，这也是前面介绍 JavaScript Engine 和 Runtime 的原因。 2.独立每个”线程“都有自己的 Event Loop。所以，每个 web worker 拥有独立的 Event Loop，它们都可以独立运行；同源的 windows 共享一个 Event Loop，它们之间可以互相通信。 内存模型从 JavaScript 内存模型的角度，我们可以将内存划分为调用栈（Call Stack）、堆（Heap）以及任务队列（Queue）等几个部分： 1. 调用栈调用栈会记录所有的函数调用信息，当我们调用某个函数时，会将其参数与局部变量等以栈帧的形式压入栈中（入栈）；在执行完毕后，会弹出栈顶的帧。让我们来看一看下面的例子： 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 2. 堆堆则则存放了大量的非结构化数据，譬如程序分配的变量与对象。 3. 任务队列任务队列包含了一系列待处理的信息与相关联的回调函数。任务队列又分为 MacroTask Queue 和 MicroTask Queue 两种。 MacroTask 和 MicroTask1. MacroTask Queue（宏任务队列）Event Loop 会有一个或多个 MacroTask Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task（也即MacroTask）。 关于 Task，常有人通俗地称它为 MarcoTask，但其实 HTML 标准中并没有这种说法。然而，为了方便理解，本书仍沿用通俗的称谓MacroTask。 在 HTML 标准中，定义了几种常见的 Task Source： DOM manipulation（DOM 操作）； User interaction（用户交互）； Networking（网络请求）； History traversal（History API 操作）。 MacroTask Source 的定义非常的宽泛，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），以及定时器相关的 setTimeout、setInterval 等等都属于 Task Source，所有来自这些 MacroTask Source 的 MacroTask 都会被放到对应的 MacroTask Queue 中等待处理。 对于 MacroTask、MacroTask Queue 和 Task Source，有如下规定： 来自相同 Task Source 的 MacroTask，必须放在同一个 MacroTask Queue 中； 来自不同 Task Source 的 MacroTask，可以放在不同的 MacroTask Queue 中； 同一个 MacroTask Queue 内的 MacroTask 是按顺序执行的； 但对于不同的 MacroTask Queue（Task Source），浏览器会进行调度，允许优先执行来自特定 Task Source 的 MacroTask。 例如，鼠标、键盘事件和网络请求都有各自的 MacroTask Queue，当两者同时存时，浏览器可以优先从用户交互相关的 MacroTask Queue 中挑选 MacroTask 并执行，比如这里的鼠标、键盘事件，从而保证流畅的用户体验。 2. MicroTask Queue（微任务队列）MicroTask Queue 与 MacroTask Queue 类似，也是一个有序列表。不同之处在于，一个 Event Loop 只有一个 MicroTask Queue。 在 HTML 标准中，并没有明确规定 MicroTask Source，通常认为有以下几种： Promise 在 Promises/A+ Note 3.1 中提到了 then、onFulfilled、onRejected 的实现方法，但 Promise 本身属于平台代码，由具体实现来决定是否使用 Microtask，因此在不同浏览器上可能会出现执行顺序不一致的问题。不过好在目前的共识是用 Microtask 来实现事件队列。 MutationObserver Object.observe (已废弃) 这里要特别提一下：网上有很多文章把 Node.js 的 process.nextTick 和 Microtask 混为一谈，事实上虽然两者层级（运行时机）非常接近，但并不是同一个东西。process.nextTick 是 Node.js 自身定义实现的一种机制，有自己的 nextTickQueue，与 HTML 标准中的 MicroTask 不是一回事。在 Node.js 中，process.nextTick 会先于 Microtask Queue 被执行。 3. 二者关系图例Event Loop中，每一次循环称为tick，每一次tick的任务细节如下： 调用栈选择最先进入队列的MacroTask（通常是script整体代码），如果有则执行； 检查是否存在 MicroTask，如果存在则不停的执行，直至清空 MicroTask Queue； 浏览器更新渲染（render），每一次事件循环，浏览器都可能会去更新渲染； 重复以上步骤。 MacroTask Queue和MicroTask Queue二者的关系如下图： 如图所示，二者互相穿插：MacroTask –&gt; MicroTask Queue –&gt; MacroTask。 一个Event Loop会有一个或多个 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。 这句话可能比较令人费解，因为图中似乎有2 个MicroTask Queue！ 其实是这样的，每个 MacroTask Queue 都保证按照回调函数（callback）入队列的顺序依次执行MacroTask，在 MacroTask 或者 MicroTask 中产生的新 MicroTask 会被压入到 MicroTask Queue中并执行。而在 执行两个MacroTask之间，也即在执行下一个MacroTask之前，会优先执行完所有MicroTask，也即会优先清空已有的 MicroTask Queue。 因此，图中第二个MicroTask Queue产生的时候，第一个MicroTask Queue其实已经被清空了。所以Event Loop实际上仅有一个MicroTask Queue。 JavaScript Runtime 的运行机制了解了 Event Loop 和任务队列的基本概念后，就可以从相对宏观的角度先了解一下 JavaScript Runtime 的运行机制了，简化后的步骤如下： 主线程不断循环； 对于同步任务，创建执行上下文（Execution Context），按顺序进入调用栈； 对于异步任务： 与步骤 2 相同，同步执行这段代码； 将相应的 MacroTask（或 Microtask）添加到任务队列； 由其他线程来执行具体的异步操作。 其他线程是指：尽管 JavaScript 是单线程的，但浏览器内核是多线程的，它会将 GUI 渲染、定时器触发、HTTP 请求等工作交给专门的线程来处理。另外，在 Node.js 中，异步操作会优先由 OS 或第三方系统提供的异步接口来执行，然后才由线程池处理。 当主线程执行完当前调用栈中的所有任务，就会去读取 Event Loop 的任务队列，取出并执行任务； 重复以上步骤。 用一张简图来表示一下这种运行机制： 还是拿 setTimeout 举例： 主线程同步执行这个 setTimeout 函数本身。 将负责执行这个 setTimeout 的回调函数的 MacroTask 添加到 MacroTask Queue。 定时器开始工作（实际上是靠 Event Loop 不断循环检查系统时间来判断是否已经到达指定的时间点）。 主线程继续执行其他任务。 当调用栈为空，且定时器触发时，主线程取出 MacroTask 并执行相应的回调函数。 很明显，执行 setTimeout 不会导致阻塞。当然，如果主线程很忙的话（调用栈一直非空），就会出现明明时间已经到了，却也不执行回调的现象，所以类似 setTimeout 这样的回调函数都是没法保证执行时机的。 setTimeout和setInterval取的时间是不准确的，因为当调用栈若不为空，它们的回调函数永远不会别执行。所以，我们会经常碰到setTimeout和setInterval用来做动画的时候，很不流畅或者卡顿。 面试题解析在面试中我们常常会碰到如下类似的代码题，面试官要你写出输出结果，其要目的是考察对JavaScript不同任务的执行先后顺序的理解： 1234567891011// 执行顺序问题，考察频率挺高setTimeout(function() &#123; console.log(1);&#125;);new Promise(function(resolve, reject) &#123; console.log(2); resolve(3);&#125;).then(function(val) &#123; console.log(val);&#125;);console.log(4); 根据本文的解析，我们可以得到： 先执行同步代码 首先，执行new Promise中的console.log(2)，then后面的属于MicroTask所以跳过； 然后，执行console.log(4)。 执行完script这个MacroTask后，执行MicroTask（也即Promise.then） 中的console.log(val)，此时val的值由resolve(3)传递过来，值为3。后面无其他微任务。 执行另一个MacroTask也即定时器setTimeout中的console.log(1)。 根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2，4，3，1。","categories":[],"tags":[]},{"title":"javascript的继承实现","slug":"javascript-javascript的继承实现","date":"2018-03-01T17:19:23.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-javascript的继承实现/","link":"","permalink":"http://kobin.top/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/","excerpt":"抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下","text":"抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下 01.类式继承(classical inheritance) 实现本质：重写子类的原型，代之以父类的实例。 1234567891011121314151617181920212223242526272829303132//父类function User(username) &#123; this.username = username ? username : \"Unknown\"; this.books = [\"coffe\", \"1891\"];&#125;//子类function CoffeUser(username) &#123; if (username) this.username = username;&#125;//关键CoffeUser.prototype = new User();const user1 = new CoffeUser();const user2 = new CoffeUser();//instanceof是检测某个对象是否是某个类的实例console.log(user1 instanceof User);//&gt;&gt; true// 可以直接访问原型链上的属性console.log(user1.username);//&gt;&gt; Unknownconsole.log(user1.books); //&gt;&gt; [\"coffe\", \"1891\"]//修改来自原型上的引用类型的属性，则有副作用：会影响到所有实例user1.books.push(\"hello\");console.log(user1.books); //&gt;&gt; [\"coffe\", \"1891\", \"hello\"]console.log(user2.books); //&gt;&gt; [\"coffe\", \"1891\", \"hello\"]//修改来自原型上的值类型的属性，无副作用user1.username = 'U';console.log(user1.username, user2.username); //&gt;&gt; U Unknown 缺陷： 引用类型属性的误修改。原型属性中的引用类型属性会被所有实例共享，若子类实例更改从父类原型继承来的引用类型的共有属性，会影响其他子类。 无法传递参数。在创建子类型的实例时，不能向父类的构造函数中传递参数。这点如过不好理解的话，接着看下面的“构造函数式继承”。 综上，我们在实际开发中很少单独使用类式继承。 02.构造函数式继承通过call/apply调用来实现继承： 123456789101112131415161718function User(username, password) &#123; this.password = password; this.username = username; User.prototype.login = function () &#123; console.log(this.username + '要登录Github，密码是' + this.password); &#125;&#125;function CoffeUser(username, password) &#123; User.call(this, username, password);//通过call向父类的构造函数传递参数 this.articles = 3; // 文章数量&#125;const user1 = new CoffeUser('coffe1891', '123456');console.log(user1 instanceof User);//&gt;&gt; falseconsole.log(user1.username, user1.password); //&gt;&gt; coffe1891 123456console.log(user1.login()); // TypeError: user1.login is not a function 存在明显的缺陷： 无法通过instanceof的测试； 并没有继承父类原型上的方法。 03.组合式继承既然上述两种方法各有缺点，但是又各有所长，那么我们是否可以将其结合起来使用呢？即原型链继承方法，而在构造函数继承属性，这种继承方式就叫做“组合式继承”。 123456789101112131415161718function User(username, password) &#123; this.password = password; this.username = username; User.prototype.login = function () &#123; console.log(this.username + '要登录Github，密码是' + this.password); &#125;&#125;function CoffeUser(username, password) &#123; User.call(this, username, password); // 第2次执行 User 的构造函数 this.articles = 3; // 文章数量&#125;CoffeUser.prototype = new User(); // 第1次执行 User 的构造函数const user1 = new CoffeUser(\"coffe1891\", \"123456\");console.log(user1 instanceof User);//&gt;&gt; trueuser1.login();//&gt;&gt; coffe1891要登录Github，密码是123456 虽然这种方式弥补了上述两种方式的一些缺陷，但有些问题仍然存在： 父类的构造函数被调用了两次，显得多余； 污染：若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法。 综上，组合式继承也不是我们最终想要的。 04.原型继承(prototypal inheritance)原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下： 123456789function createObject(o) &#123; // 创建临时类 function F() &#123; &#125; // 修改类的原型为o, 于是f的实例都将继承o上的方法 F.prototype = o; return new F();&#125; 这不就是ES5的 Object.create 吗？没错，你可以认为是如此。 既然只是类式继承的一种封装，其使用方式自然如下： 1CoffeUser.prototype &#x3D; createObject(User) 也就仍然没有解决类式继承的一些问题。从这个角度而言，原型继承和类式继承应该直接归为一种继承。 05.寄生式继承寄生式继承是与原型继承紧密相关的一种思路，它依托于一个内部对象而生成一个新对象，因此称之为寄生。 12345678910111213141516const UserSample = &#123; username: \"coffe1891\", password: \"123456\"&#125;function CoffeUser(obj) &#123; var o = Object.create(obj);//o继承obj的原型 o.__proto__.readArticle = function () &#123;//扩展方法 console.log('Read article'); &#125; return o;&#125;var user = new CoffeUser(UserSample);user.readArticle();//&gt;&gt; Read articleconsole.log(user.username, user.password);//&gt;&gt; coffe1891 123456 06.寄生组合式继承12345678910111213141516171819202122232425262728293031323334353637//寄生组合式继承的核心方法function inherit(child, parent) &#123; // 继承父类的原型 const p = Object.create(parent.prototype); // 重写子类的原型 child.prototype = p; // 重写被污染的子类的constructor p.constructor = child;&#125;//User, 父类function User(username, password) &#123; let _password = password this.username = username&#125;User.prototype.login = function () &#123; console.log(this.username + '要登录Github，密码是' + _password); //&gt;&gt; ReferenceError: _password is not defined&#125;//CoffeUser, 子类function CoffeUser(username, password) &#123; User.call(this, username, password) // 继承属性 this.articles = 3 // 文章数量&#125;//继承inherit(CoffeUser, User);//在原型上添加新方法CoffeUser.prototype.readArticle = function () &#123; console.log('Read article');&#125;const user1 = new CoffeUser(\"Coffe1891\", \"123456\");console.log(user1); 观察chrome浏览器的输出结果： 简单说明一下： 子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性； 子类可以传递动态参数给父类； 父类的构造函数只执行了一次。 Nice！这才是我们想要的继承方法。然而，仍然存在一个美中不足的问题： 子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话若是已经存在的两个类，就不好办了。 所以，我们可以将其优化一下： 12345678function inherit(child, parent) &#123; // 继承父类的原型 const parentPrototype = Object.create(parent.prototype) // 将父类原型和子类原型合并，并赋值给子类的原型 child.prototype = Object.assign(parentPrototype, child.prototype) // 重写被污染的子类的constructor p.constructor = child&#125; 但实际上，使用Object.assign 来进行 copy 仍然不是最好的方法。因为上述的继承方法只适用于 copy 原型链上可枚举的方法，而ES6中，类的方法默认都是不可枚举的。此外，如果子类本身已经继承自某个类，以上的继承将不能满足要求。 参考文献Inheritance in JavaScript","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"http://kobin.top/tags/%E7%BB%A7%E6%89%BF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"原型与原型链","slug":"javascript-原型与原型链","date":"2018-02-05T15:45:38.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-原型与原型链/","link":"","permalink":"http://kobin.top/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。","text":"在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。 原型、prototype、__proto__ 原型是一个对象。 prototype是函数的一个属性而已，也是一个对象，它和原型没有绝对的关系（很多书、很多网络文章都模糊地将prototype表述为原型，这是严重不对的）。JavaScript里函数也是一种对象，每个对象都有一个原型，但不是所有对象都有prototype属性，实际上只有函数才有这个属性。 1234567var a = function()&#123;&#125;;var b=[1,2,3];//函数才有prototype属性console.log(a.prototype);//&gt;&gt; function()&#123;&#125;//非函数，没有prototype属性console.log(b.prototype);//&gt;&gt; undefined 每个对象(实例)都有一个属性__proto__，指向他的构造函数（constructor）的prototype属性。 一个对象的原型就是它的构造函数的prototype属性的值，因此__proto__也即原型的代名词。 对象的__proto__也有自己的__proto__，层层向上，直到__proto__为null。换句话说，原型本身也有自己的原型。这种由原型层层链接起来的数据结构成为 原型链。因为null不再有原型，所以原型链的末端是null。 让我们用更多代码来验证一下以上结论： 123456789101112131415161718var a = function()&#123;&#125;;var b=[1,2,3];//a的构造函数是「Function函数」console.log(a.__proto__ == Function.prototype);//&gt;&gt; true//b的构造函数是「Array函数」console.log(b.__proto__ == Array.prototype);//&gt;&gt; true//因为「Function函数」和「Array函数」又都是对象，其构造函数//是「Object函数」，所以，a和b的原型的原型都是Object.prototypeconsole.log(a.__proto__.__proto__ === Object.prototype);//&gt;&gt; trueconsole.log(b.__proto__.__proto__ === Object.prototype);//&gt;&gt; true//Object作为顶级对象的构造函数，它实例的原型本身就不再有原型了，因此它原型//的__proto__属性为nullconsole.log(new Object().__proto__.__proto__);//&gt;&gt; null//也即Object类型对象，其原型（Object.prototype）的__proto__为nullconsole.log(Object.prototype.__proto__);//&gt;&gt; null 三者关系图如下： 使用__proto__是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。但是，它已被不推荐使用，现在更推荐使用Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf（尽管如此，设置对象的原型是一个缓慢的操作，如果性能要求很高，应该避免设置对象的原型）。 原型继承使用最新的方法Object.setPrototypeOf（类似Reflect.setPrototypeOf）可以很方便地给对象设置原型，这个对象会继承该原型所有属性和方法。 但是，setPrototypeOf的性能很差，我们应该尽量使用 Object.create()来为某个对象设置原型。 1234567891011//obj的原型是Object.prototypevar obj=&#123; methodA()&#123; console.log(\"coffe\"); &#125;&#125;var newObj = Object.create(obj);//以obj为原型创建一个新的对象//methodA实际上是newObj原型对象obj上的方法。也即newObj继承了它的原型对象obj的属性和方法。newObj.methodA();//&gt;&gt; coffe 类(class）的prototype和protoES6之后，类(class)也有了prototype属性，为什么呢，因为class本质上是构造函数的语法糖. 1234class A &#123;&#125;typeof A;//&gt;&gt; \"function\" 说明class本质上也是函数，所以它带有prototype属性是十分正常的事。然后，在Chrome浏览器里调试如下代码： 1234class A &#123;&#125;A.prototype; 得到的结果如下图: 上面代码说明类的prototype是一个对象，它包含有constructor属性。这和函数的prototype属性表现具有一致性。 1234class A &#123;&#125;A===A.prototype.constructor;//&gt;&gt; true 上面代码说明一个重要结论：类指向自身构造函数。而且，事实上，类的所有方法都定义在类的prototype属性上面。同样可以通过Chrome调试验证。 1234567891011121314151617181920class A&#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于A.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 结果如下： 定理class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A //&gt;&gt; trueB.prototype.__proto__ === A.prototype //&gt;&gt; true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"原型","slug":"原型","permalink":"http://kobin.top/tags/%E5%8E%9F%E5%9E%8B/"}]},{"title":"闭包","slug":"javascript-闭包","date":"2018-02-03T15:04:57.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-闭包/","link":"","permalink":"http://kobin.top/javascript-%E9%97%AD%E5%8C%85/","excerpt":"闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。","text":"闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。 热身：循环中的闭包12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function test() &#123; console.log(i) //&gt;&gt; 6 6 6 6 6 &#125;, i * 1000);&#125; 本意是想每隔一秒依次输出“1 2 3 4 5”，结果变成输出“6 6 6 6 6 ”。为什么会这样呢，根据作用域链上变量查找机制，setTimeout第一个参数的函数体内的i引用了去全局作用域里面的i，当for循环完毕后，i的值为6，所以输出了“6 6 6 6 6 ”。 如何实现正确的输出呢？ 其实用闭包就能轻松解决这个问题： 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123;//包了一层IIFE形式的函数，这个函数是闭包 setTimeout(function test() &#123;//函数体内的j引用了外层匿名函数的参数j console.log(j); //&gt;&gt; 1 2 3 4 5 &#125;, j * 1000); &#125;)(i);&#125; 什么是闭包1. 闭包的定义关于JavaScript闭包的定义有很多种，每本书、每个作者都有不完全相同的描述，虽然笔者认为函数就是闭包这个定义才是最简单最直白的，但其实笔者看到过不下十种定义，到现在一种都记不住。鉴于此，我们干脆不要记住这些五花八门的定义了，只要记住了产生闭包的时机会更实际一些，面试时，把闭包产生的时机告诉面试官就可以了： 内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。让我们用代码来说事儿吧： 1234567891011function func()&#123;//func1引用了它外层的变量a，因此func成为了闭包 let a=\"coffe\"; function func1()&#123; console.log(a);//访问了外层函数func体内的变量a debugger;//断点 &#125; func1();&#125;func(); 我们在chrome浏览器的“开发者工具”里面的控制台，运行上面的代码，可以很方便看到闭包。 看上面这个图，Closure出现在Scope一栏里面，所以可以认为闭包也是一种作用域。既然闭包也是一种作用域，闭包能够解决经典的“循环中的闭包”的问题，那是不是利用作用域就能解决问题？这让人想到了关键字let，试试看吧，把本文开头的代码改造一下： 12345678for (var i = 1; i &lt;= 5; i++) &#123; &#123; let j = i; setTimeout(function test() &#123; console.log(j) //&gt;&gt; 1 2 3 4 5 &#125;, j * 1000); &#125;&#125; 果然，用let关键字包上一个作用域，也能和闭包一样解决问题达成目的。因此可以说，闭包是一种作用域，它拷贝了一套外层函数作用域中被访问的参数、变量/函数，这个拷贝都是浅拷贝 2. 写成闭包形式有什么好处呢？当然有好处！还是以之前的代码为例，变量a类似于高级语言的私有属性，无法被func外部作用域访问和修改，只有func内部的作用域（含嵌套作用域）可以访问。这样可以实现软件设计上的封装，设计出很强大的类库、框架，比如我们常用的jQuery、AngularJS、Vue.js。 看一个ES6出现之前最常见的模块化封装的例子: 12345678910111213141516171819202122//定义一个模块function module(n) &#123; //私有属性 let name = n; //私有方法 function getModuleName() &#123; return name; &#125; //私有方法 function someMethod() &#123; console.log(\"coffe1891\"); &#125; //以一个对象的形式返回 return &#123; getModuleName: getModuleName, getXXX: someMethod &#125;;&#125;let myapp = module(\"myModule\");//定义一个模块console.log(myapp.getModuleName()); //&gt;&gt; myModuleconsole.log(myapp.getXXX()); //&gt;&gt; coffe1891 3. 闭包有什么缺点吗？javascript中的垃圾回收（GC）规则是这样的：如果对象不再被引用，或者对象互相引用形成数据孤岛后且没有被孤岛之外的其他对象引用，那么这些对象将会被JS引擎的垃圾回收器回收；反之，这些对象一直会保存在内存中。 由于闭包会引用包含它的外层函数作用域里的变量/函数，因此会比其他非闭包形式的函数占用更多内存。当外层函数执行完毕退出函数调用栈（call stack）的时候，外层函数作用域里变量因为被引用着，可能并不会被JS引擎的垃圾回收器回收，因而会引起内存泄漏。过度使用闭包，会导致内存占用过多，甚至内存泄漏。 123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;//函数B保持了对count的引用&#125;var b = A();b();//&gt;&gt; 1b();//&gt;&gt; 2b();//&gt;&gt; 3 count是函数A中的一个变量，它的值在函数B中被改变，B每执行一次，count的值就在原来的基础上累加1。因此，函数A中的count一直保存在内存中，并没有因为函数A执行完毕退出函数调用栈后被JS引擎的垃圾回收器回收掉。 避免闭包导致内存泄漏的解决方法是，在函数A执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。 其他使用场景介绍除了上面介绍过的循环中的闭包、模块化封装之外，闭包还有一些其他写法。 1. 返回一个新函数123456789101112function sayHello2(name) &#123; var text = \"Hello \" + name; // 局部变量 var sayAlert = function() &#123; console.log(text); &#125;; return sayAlert;&#125;var say2 = sayHello2(\"coffe1891\");say2(); //&gt;&gt; Hello coffe1891 调用sayHello2()函数返回了sayAlert，赋值给say2。注意say2是一个引用变量，指向一个函数本身，而不是指向一个变量。 2. 扩展全局对象的方法下面这种利用闭包扩展全局对象，可以有效地保护私有变量，形成一定的封装、持久性。 12345678910111213141516171819202122232425function setupSomeGlobals() &#123; //私有变量 var num = 666; gAlertNumber = function() &#123;//没有用var和let关键字声明，会成为全局对象的方法 console.log(num); &#125;; gIncreaseNumber = function() &#123; num++; &#125;; gSetNumber = function(x) &#123; num = x; &#125;;&#125;setupSomeGlobals();gAlertNumber(); //&gt;&gt; 666gIncreaseNumber();gAlertNumber(); //&gt;&gt; 667gSetNumber(1891);gAlertNumber(); //&gt;&gt; 1891 三个全局函数gAlertNumber，gIncreaseNumber，gSetNumber指向了同一个闭包，因为它们是在同一次setupSomeGlobals()调用中声明的。它们所指向的闭包是与setupSomeGlobals()函数关联一个作用域，该作用域包括了num变量的拷贝。也就是说，这三个函数操作的是同一个num变量。 3. 延长局部变量的生命日常开发时，Image对象经常被用于数据统计的上报，示例代码如下： 12345var report = function(src) &#123; var img = new Image(); img.src = src;&#125;report('http://www.xxx.com/getClientInfo');//把客户端信息上报数据 这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报。原因是Image对象是report函数中的局部变量，当report函数调用结束后，Image对象随即被JS引擎垃圾回收器回收，而此时可能还没来得及发出http请求，所以可能导致此次上报数据的请求失败。 怎么办呢？我们可以使用闭包把Image对象封闭起来，就可以解决数据丢失的问题，代码如下： 123456789var report = (function() &#123; var imgs = [];//在内存里持久化 return function(src) &#123; var img = new Image(); imgs.push(img);//引用局部变量imgs img.src = src; &#125;&#125;());report('http://www.xxx.com/getClientInfo');//把客户端信息上报数据","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://kobin.top/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"完全理解javascript里的this","slug":"javascript-javascript里的this","date":"2018-02-01T14:03:22.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"javascript-javascript里的this/","link":"","permalink":"http://kobin.top/javascript-javascript%E9%87%8C%E7%9A%84this/","excerpt":"","text":"this是JavaScript世界最让人迷惑的关键字之一，很多人对它一知半解，本文希望详细的把this说明白。 为什么要有this？JavaScript 允许在函数体内部，引用当前执行上下文的其他变量。 123function func() &#123; console.log(a);&#125; 如上代码，函数func引用了当前执行上下文的变量a，问题是这个函数func可以在任意其他执行上下文中被调用，因此这个a可能就指向不同了。正因为如此，JS引擎需要有一个机制，可以依靠其 优雅地、准确地指向当前代码运行时所处的上下文环境（context）。 因此便催生了“this”。 何谓”优雅地“？12345678910//假设有个对象名字很长，而且有可能会改名var iAmALongLongLongNameObject=&#123; name:\"coffe\", func1()&#123; return iAmALongLongLongNameObject.name; &#125;, func2()&#123; return this.name; &#125;&#125; iAmALongLongLongNameObject的方法func2使用了this关键字，是不是优雅多了？然后即使以后对象名字变化，func2内部的代码也不用改变。func1这种确实也可以实现与func2同样的功能，但是就显得丑陋、不灵活了。 何谓“准确地”？this可以准确地指向（某个对象）而不会产生歧义。 123456789101112131415161718192021//全局变量var iAmALongLongLongNameObject = &#123; name: \"1891\"&#125;;(function() &#123; //局部变量 var iAmALongLongLongNameObject = &#123; name: \"coffe\", func1() &#123; //如果光看代码，是不是容易看成调用了全局变量的name？ return iAmALongLongLongNameObject.name; &#125;, func2() &#123; //这里光看代码就很准确地知道是调用了局部变量的name！ return this.name; &#125; &#125;; console.log(iAmALongLongLongNameObject.func1());//&gt;&gt; coffe&#125;)(); 与“Java等高级语言的this会指向对象的实例本身”不同，JavaScript的this指向函数的调用位置的对象，也即调用该函数的对象。你需要知道，JavaScript中所有的函数都有属性，就如对象有属性一样。函数执行阶段（也即执行上下文的执行阶段）会获取this属性的值，此时this就是一个变量，储存着调用该函数的对象的值。 12345var a = \"coffe\";function func() &#123; console.log(this.a);&#125;func();//&gt;&gt; coffe 上面代码中，func的调用者未通过点操作符.指明，那它的调用者就是默认的全局对象window，func函数作为window的一个方法，其体内的this.a就是明确指代window中属性a，这种指向是准确而清晰的，不会有歧义。this的这种灵活性在设计API的时候，会变得很方便和容易被复用。 调用位置调用位置就是函数在代码中被调用的位置，而不是声明的位置。研究调用位置，也即搞清“由谁在哪调用了这个函数”的问题。搞清楚了调用位置，才能准确地找到this的指向。 要找到调用位置，最重要的是要分析是被谁、在哪调用。 1234567891011var module = &#123; x: \"1891\", getX: function() &#123; return this.x; &#125;&#125;console.log(module.getX());//&gt;&gt; 1891var getX = module.getX;//注意：getX和module.getX都是指向内存中函数的地址而已，它们并没有被“()”以便执行 //这里实际上是【间接引用】的模式，见文尾【壹.2.3.6】解释console.log(getX()); //&gt;&gt; undefined 如上代码，要找到函数getX的调用位置，需要先看哪儿调用了它，很明显，有函数有两处位置调用了函数getX()，接下来分析是谁调用了它。 作为module对象的getX方法被调用。 这种情况被谁调用？很明显是被对象module调用，this是指向module。module对象里面有一个属性x，它的值是1891，因此console.log(module.getX())输出1891。 作为全局函数getX被调用。 这种情况是被谁调用？我们都知道全局函数可以看作为window对象的方法，那么，很明显现在getX是被当做全局对象window的一个方法被调用。 我们搞清楚了调用位置之后，接下来就会着手判断this的指向。 先看看很多人对this指向的一些误解this 既不指向函数自身也不指向函数的作用域，这之前是很多前端工程师容易误解的地方，现在澄清一下。 this的指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的； this 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）； 正因为在执行上下文的创建阶段this的指向就已经被确定了，在执行阶段this指向不可再被更改。 12345678910var obj = &#123; a: \"1891\"&#125;function func() &#123; this = obj; //报错，因为在执行阶段试图修改this的指向 console.log(this.a);&#125;func(); this的指向规则1. 默认指向独立函数调用（无法应用后面其他指向规则时），this指向全局对象window。 12345function func() &#123; console.log( this.a ); // this指向全局对象&#125;var a = 2;func(); //&gt;&gt; 2 对于默认指向来说，决定this指向对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会指向undefined，否则this会指向全局对象。 123456789function func() &#123; \"use strict\";//函数体处于严格模式下，this指向undefined console.log(this.a);&#125;var a = \"1891\";(function() &#123; func(); //&gt;&gt; 报错&#125;)(); 12345678910function func() &#123; console.log(this.a);&#125;var a = \"1891\";(function() &#123; \"use strict\"; func(); //&gt;&gt; 1891 //这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关&#125;)(); 还有一种默认指向，就是在SetTimeout或SetInterval结合使用时。代码示例如下。 1234567891011121314151617181920212223var num = 0;class Obj &#123; constructor(num)&#123; this.num = num; &#125; func()&#123; console.log(this.num); &#125; func1()&#123; setTimeout(function () &#123; console.log(\"setTimeout:\"+this.num); &#125;, 1000) &#125; func2()&#123; setInterval(function () &#123; console.log(this.num); &#125;, 2000) &#125;&#125;var obj = new Obj(1);obj.func();//&gt;&gt; 1 输出的是obj.numobj.func1()//&gt;&gt; setTimeout:0 输出的是window.numobj.func2()//&gt;&gt; 0 0 0 0 …… 输出的是window.num 可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。 2. 隐式指向隐式指向是日常开发中最常见的指向。 函数体内this的指向由调用位置的调用者决定。如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的this指向该对象。 1234567891011function func() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, func: func&#125;;obj.func(); //&gt;&gt; 2// 找到调用位置，由 obj 对象来调用函数func，// 此时可以说函数func被调用时，obj 对象“拥有”或者“包含”func函数，// 所以此时的 this 指向调用 func 函数的 obj 对象。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置，也就是说this指向最终调用函数的对象。这句话可能说得比较拗口，其实简单通俗地说，this指向最靠近被调用函数的对象，离得远的不是。举例来说： 12345678910111213141516function func() &#123; console.log(this.a);&#125;var obj2 = &#123; a: \"1891\", func: func&#125;;var obj1 = &#123; a: \"coffe\", obj2: obj2&#125;;//此时的 this 指向 obj2 对象，因为obj2离得近！obj1.obj2.func(); //&gt;&gt; 1891 再来看看隐式丢失： 1234567891011121314151617function func() &#123; console.log( this.a );&#125;var obj = &#123; a: \"coffe1891\", func: func&#125;;var bar = obj.func; // 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实 // 都指向内存中的函数func本身。var a = \"oops, global\"; // a 是全局对象window的属性，也是全局变量bar(); //&gt;&gt; oops, global// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a） 3. 显式指向JavaScript内置对象Function的三个原型方法call()、apply()和bind()，它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数时让this指向这个对象。 1234567891011var a = \"makai\";function func() &#123; console.log( this.a );&#125;var obj = &#123; a:\"coffe1891\"&#125;;func.call(obj); //&gt;&gt; coffe1891// 在调用 func 时强制把它的 this 绑定到 obj 上 另外，使用bind可以修正SetTimeout和SetInterval的this指向： 1234567891011121314151617181920212223var num = 0;class Obj &#123; constructor(num)&#123; this.num = num; &#125; func()&#123; console.log(this.num); &#125; func1()&#123; setTimeout(function () &#123; console.log(\"setTimeout:\"+this.num); &#125;.bind(this), 1000);//bind &#125; func2()&#123; setInterval(function () &#123; console.log(this.num); &#125;.bind(this), 2000);//bind &#125;&#125;var obj = new Obj(1);obj.func();//&gt;&gt; 1 输出的是obj.numobj.func1()//&gt;&gt; setTimeout:1 输出的是obj.numobj.func2()//&gt;&gt; 1 1 1 1 …… 输出的是obj.num 4. “new”操作符指向在JavaScript 中，构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们只是被new操作符调用的普通函数而已。 使用new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： 创建（或者说构造）一个全新的对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性、方法等）； 如果函数没有返回其他对象，那么返回这个新对象。 123456function func(a) &#123; this.a = a;&#125;var bar = new func(\"coffe1891\");console.log(bar.a); //&gt;&gt; coffe1891// 使用new 来调用func(..)时，我们会构造一个新对象并把它绑定到func(..)调用中的this上 可以将函数的返回值分成三种情况： 返回一个对象 没有返回值，即默认返回undefined 返回基本数据类型 12345678910111213141516171819202122232425262728293031323334353637381、返回一个对象function Foo(name,age) &#123; this.name = name; return &#123; age &#125;&#125;var bar = new Foo(\"kobin\",\"18\");bar.name; // undefinedbar.age; // 182、没有返回值function Foo(name,age) &#123; this.name = name;&#125;var bar = new Foo(\"kobin\",\"18\");bar.name; // kobinbar.age; // undefined3、返回基本数据类型function Foo(name,age) &#123; this.name = name; return 123&#125;var bar = new Foo(\"kobin\",\"18\");bar.name; // kobinbar.age; // undefined 所以使用new绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么this会绑定到返回的对象上 如何利用规则判断this的指向this的指向判断，可以按照下面的优先级顺序来判断函数在某个调用位置应用的是哪条规则 1. 函数是否在new 中被调用（new 操作符指向）？如果是的话，this 绑定的是新创建的对象。 123456789function func(name) &#123; this.name = name; this.getName = function() &#123; return this.name; &#125;;&#125;var obj = new func(\"coffe\"); //this会指向objconsole.log(obj.getName()); //&gt;&gt; coffe 2. 函数是否通过call、apply、bind显式指向？如果是的话，this指向的是call、apply、bind三个方法的第一个参数指定的对象。 12345678var obj1 = &#123; name: \"coffe\"&#125;;function func() &#123; return this.name; //这里的this本来指向window&#125;var str = func.call(obj1); //改变了func函数里面this的指向，指向obj1console.log(str); //&gt;&gt; coffe 3. 函数是否被当做某个对象的方法而调用（隐式指向）？如果是的话，this指向的是这个对象。 123456789var obj1 = &#123; name: \"coffe\", func() &#123; return this.name; //指向obj1 &#125;&#125;;//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1console.log(obj1.func()); //&gt;&gt; coffe 4. 若以上都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 12345678var a = \"coffe\"; //为全局对象window添加一个属性afunction func() &#123; \"use strict\";//开启严格模式 return this.a;&#125;//严格模式下，this指向undefinedconsole.log(func()); //&gt;&gt; TypeError 几个例外情况1. 被忽略的thisnull 或者undefined作为this指向的对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认指向规则。 1234567function func() &#123; console.log(this.a);&#125;var a = 2;func.call(null); //&gt;&gt; 2 //this指向了window 2. 间接引用间接引用最容易在赋值时发生；间接引用时，调用这个函数会应用默认指向规则。 12345678910function func() &#123; console.log(this.a);&#125;var a = 2;var o = &#123; a: 3, func: func &#125;;var p = &#123; a: 4 &#125;;o.func(); //&gt;&gt; 3(p.func = o.func)(); //&gt;&gt; 2// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用// 因此调用位置是 func() 而不是 p.func() 或者 o.func() 3. 箭头函数箭头函数并不是使用function关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。 箭头函数不遵守this的四种指向规则，而是根据函数定义时的作用域来决定 this 的指向。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。 看下面代码加深理解： 1234567891011121314151617181920function func() &#123; // 返回一个箭头函数 return a =&gt; &#123; //this 继承自 func() console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = func.call(obj1);bar.call(obj2); //&gt;&gt; 2 不是 3 ！// func() 内部创建的箭头函数会捕获调用时 func() 的 this。// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！） 这个特性甚至被mozilla的MDN称作“没有this”，这种说法很费解。其实应该这么理解：一般而言，this的指向是在函数运行之后才确定的，而箭头函数的this指向在定义时也即调用之前就定死了，在运行之后无法更改，那相当于当成一个固定值的变量，此时this失去了原来作为“指向当前代码运行时所处的上下文环境（context）”的意义，所以MDN说箭头函数没有了this，我觉得翻译成“把this阉割了”更贴切 🤣 。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"word-wrap,word-break,white-space强制换行和不换行总结","slug":"css-强制换行与不换行","date":"2017-05-15T17:30:05.000Z","updated":"2020-06-05T07:58:32.085Z","comments":true,"path":"css-强制换行与不换行/","link":"","permalink":"http://kobin.top/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/","excerpt":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的","text":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的 word-wrap 语法： word-wrap: normal(默认) | break-word normal: 允许内容顶开指定的容器边界 break-word: 内容将在边界内换行。必要时会触发 word-break 说明word-wrap 是控制是否“为词断行”的，设置或检索当前行超过指定容器的边界时是否断开转行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。 范例congratulation 这个单词属于长串英文，word-wrap:break-word 整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断，这就是对于长串文字不起作用的解释。word-wrap:normal 是默认情况，英文单词不被拆开。 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（如果为 td,th 加上宽度 word-wrap 在 IE 下是能够发挥效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。 word-break word-break: normal(默认) | break-all | keep-all normal: 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。 break-all: 该行为与亚洲语言的 normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本。 keep-all: 与所有非亚洲语言的 normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 说明word-break:break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题（恰恰弥补了上面 word-wrap:break-word 对于长串文字不起作用的缺陷） 范例继续以上面 congratulation 这个单词属于长串英文，word-break:break-all 它会把单词截断，该行末端就会变成类似 conra(congratulation 的前端部分)，下一行为 tulation（conguatulation）的后端部分了。word-break:keep-all，是指 Chinese, Japanese, and Korean 不断词。即只用此时，不用 word-wrap，中文就不会换行了。（英文语句正常。） 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（经测试 Chrome 下 word-break:break-all 是有效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。Firefox,Opera 是无法识别 word-break 的，更不用提 Firefox 下的 th,td 中使用 word-break 的效果了。 white-space white-space: normal(默认) | pre | nowrap normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 说明 对于 pre 属性，其实就是 HTML 中连续的多个空白符会被合并，然后为了不让他合并（最常用的场合就是表示代码文字缩进）让其中的空白符继续保留而不需要我们增加额外的样式和标签来控制它的缩进和换行。pre 标签的原理也是一样的内部默认有了个 white-space:pre。 对于 nowrap 属性，这个是强制不换行核心，一般强制不换行就是利用这个属性。Firefox 的 div 和 td 中，以及 IE 的 div 中，均没有问题。唯一的瑕疵就是在 IE 的 td 中会有一个问题，如果 td 没有指定宽度，则 nowrap 仍然有效，如果 td 有宽度，并且文字中无标点、无空格（例如中文长串文字），nowrap 则不再有效。解决方式就是可以加 word-break:keep-all;可以解决此问题。 总结强制换行 div（块级元素） word-wrap:break-word; word-break:break-all; td,th 这类 table 元素 先为 table 设定 table-layout:fixed，基本上设定完这个属性后基本的换行问题都能够解决而不会出现 table 中 td,th 因为里面各个内容的多寡发生抢夺其他 td,th 宽度的情形发生。这时如果你依旧有强制换行问题，那么在此 td 中内部加一层 div，那么情况就会像上面讨论的方式来解决。 总结强制不换行 white-space:nowrap 在文字与 td 之间再套一层 div，然后使用 nowrap overflow:hidden 防止文字溢出","categories":[{"name":"css","slug":"css","permalink":"http://kobin.top/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kobin.top/tags/css/"}]}],"categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/categories/%E9%9D%A2%E8%AF%95/"},{"name":"css","slug":"css","permalink":"http://kobin.top/categories/css/"}],"tags":[{"name":"software","slug":"software","permalink":"http://kobin.top/tags/software/"},{"name":"软件","slug":"软件","permalink":"http://kobin.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"java","slug":"java","permalink":"http://kobin.top/tags/java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"数组","permalink":"http://kobin.top/tags/%E6%95%B0%E7%BB%84/"},{"name":"zhan","slug":"zhan","permalink":"http://kobin.top/tags/zhan/"},{"name":"promise","slug":"promise","permalink":"http://kobin.top/tags/promise/"},{"name":"iframe","slug":"iframe","permalink":"http://kobin.top/tags/iframe/"},{"name":"download","slug":"download","permalink":"http://kobin.top/tags/download/"},{"name":"全栈","slug":"全栈","permalink":"http://kobin.top/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"http://kobin.top/tags/nginx/"},{"name":"前端","slug":"前端","permalink":"http://kobin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/tags/%E9%9D%A2%E8%AF%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://kobin.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"继承","slug":"继承","permalink":"http://kobin.top/tags/%E7%BB%A7%E6%89%BF/"},{"name":"原型","slug":"原型","permalink":"http://kobin.top/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"闭包","slug":"闭包","permalink":"http://kobin.top/tags/%E9%97%AD%E5%8C%85/"},{"name":"css","slug":"css","permalink":"http://kobin.top/tags/css/"}]}