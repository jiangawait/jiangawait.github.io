{"meta":{"title":"扬舲's blog","subtitle":"山重水复疑无路 柳暗花明又一村","description":"前端技术博客","author":"yangling","url":"http://kobin.top","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-05T20:50:09.000Z","updated":"2020-10-14T10:18:00.457Z","comments":false,"path":"categories/index.html","permalink":"http://kobin.top/categories/index.html","excerpt":"","text":""},{"title":"react-test","date":"2020-05-01T16:59:10.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"react-test/index.html","permalink":"http://kobin.top/react-test/index.html","excerpt":"","text":"XSS 即（Cross Site Scripting）：跨站脚本攻击 原理 恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到 web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。 分类 存储型（持久性 XSS 攻击）、反射型(非持久性 XSS 攻击）及 DOM-based 型 反射性反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。例子： 恶意链接的地址指向了 localhost:8001/?q=111&amp;p=222。然后，我再启一个简单的 Node 服务处理恶意链接的请求： 1234567891011const http = require(\"http\");function handleReequest(req, res) &#123; res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\" &#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, \"127.0.0.1\");server.on(\"request\", handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如 cookie)的脚本，这取决于攻击者的目的。 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 基于 DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 123456789101112131415161718192021222324252627&lt;h2&gt;XSS:&lt;/h2&gt;&lt;input type=\"text\" id=\"input\" /&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById(\"input\"); const btn = document.getElementById(\"btn\"); const div = document.getElementById(\"div\"); let val; input.addEventListener( \"change\", (e) =&gt; &#123; val = e.target.value; &#125;, false ); btn.addEventListener( \"click\", () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`; &#125;, false );&lt;/script&gt; 点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容 &#39;&#39; onclick=alert(/xss/) 用户提交之后，页面代码就变成了： &lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt; 此时，用户点击生成的链接，就会执行对应的脚本： SQL 注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中，从而执行恶意的 SQL 语句,一个例子： 我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 ‘or ‘123’ = ‘123 这样的。 我们在查询用户名和密码是否正确的时候，本来执行的 sql 语句是：select _ from user where username = ‘’ and password = ‘’. 这样的 sql 语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的 sql 语句就是：select _ from user where username = ‘’ and password = ‘ ‘ or ‘123’ = ‘123 ‘; 这样的了，那么会有一个 or 语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：’; drop table user;, 这样的话，那么 sql 命令就变成了：select * from user where username = ‘’ and password = ‘’; drop table user;’ , 那么这个时候我们会把 user 表直接删除了。 sql 被攻击的原因是：sql 语句伪造参数，然后对参数进行拼接后形成 xss 攻击的 sql 语句。最后会导致数据库被攻击了。 防范的方法： 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用 sql 语句伪造成参数，到了服务端的时候，这个伪造 sql 语句的参数也只是简单的字符，并不能起到攻击的作用。 数据库中密码不应明文存储的，可以对密码使用 md5 进行加密，为了加大破解成本，所以可以采用加盐的方式。 XSS 攻击的防范 cookie 安全策略 http-only: 只允许 http 或 https 请求读取 cookie、JS 代码是无法读取 cookie 的(document.cookie 会显示 http-only 的 cookie 项被自动过滤掉)。发送请求时自动发送 cookie. secure-only: 只允许 https 请求读取，发送请求时自动发送 cookie。 host-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie。 输入检查 对于用户的任何输入要进行检查、过滤和转义。 输出检查 利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 开启 CSP 网页安全政策防止 XSS 攻击 CSP 是网页安全政策(Content Security Policy)的缩写。主要用来防止 XSS 攻击。是一种由开发者定义的安全性政策申明，通过 CSP 所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#39;self&#39; &#39;unsafe-inline&#39; ; style-src &#39;self&#39; &#39;unsafe-inline&#39; *.yyy.com; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; ; &quot;&gt; CSRF(跨站请求伪造)完成一次 CSRF 攻击，需要完成如下事情： 登录受信任的网站 A，并且在本地生成 cookie。 在不登出网站 A 的情况下，继续访问危险网站 B。 CSRF 基本原理是：假设 A 网站是一个银行网站，而我是该网站的用户，当我以受信任的身份登录了该网站的时候，这时候 A 网站是通过 cookie 保留了我们的登录状态，这个时候我去登录了恶意网站 B 的时候，B 网站就会拿到我登录 A 网站的 cookie 信息到，因此 B 网站就把拿到的 cookie 信息去重新请求 A 网站的接口，但是在该接口后面的参数做一些修改，因此就这样达到攻击的目的。 CSRF 防范措施 服务端验证 HTTP Referer 字段 加验证码 使用 Token"},{"title":"标签","date":"2020-05-05T20:52:32.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"tags/index.html","permalink":"http://kobin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IntersectionObserver原理分析","slug":"Chrome源码-IntersectionObserver","date":"2020-10-14T16:35:29.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"Chrome源码-IntersectionObserver/","link":"","permalink":"http://kobin.top/Chrome%E6%BA%90%E7%A0%81-IntersectionObserver/","excerpt":"在介绍IntersectionObserver的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其polyfill来作部分功能的兼容。 IntersectionObserver-polyfill是w3c官方创建的https://github.com/w3c/IntersectionObserver。我们可以在浏览器不支持IntersectionObserver的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行polyfill。","text":"在介绍IntersectionObserver的时候曾提到过这个接口目前使用的最大问题就是浏览器的兼容性问题。所以，我们平时在使用的时候切记不要忘记判断这个API在我们的宿主环境中是否存在。如果不存在，我们可以通过引入其polyfill来作部分功能的兼容。 IntersectionObserver-polyfill是w3c官方创建的https://github.com/w3c/IntersectionObserver。我们可以在浏览器不支持IntersectionObserver的情况下引入它。当然，你也可以直接引入它，其内部也只会在浏览器不支持其的情况下进行polyfill。 IntersectionObserver的使用前面做了简单的叙述 1234567891011const target = document.getElementById('target')const observer = new IntersectionObserver((entries) =&gt; &#123; const [entry] = entries if (entry.isIntersecting) &#123; console.log('元素曝光了') &#125;&#125;)observer.observe(target) 下面我们就从其polyfill的源码中来了解其基本原理 IntersectionObserver1234567891011121314151617181920212223242526272829function IntersectionObserver(callback, opt_options) &#123; var options = opt_options || &#123;&#125;; if (typeof callback != 'function') &#123; throw new Error('callback must be a function'); &#125; if (options.root &amp;&amp; options.root.nodeType != 1) &#123; throw new Error('root must be an Element'); &#125; // Binds and throttles `this._checkForIntersections`. this._checkForIntersections = throttle( this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT); // Private properties. this._callback = callback; this._observationTargets = []; this._queuedEntries = []; this._rootMarginValues = this._parseRootMargin(options.rootMargin); // Public properties. this.thresholds = this._initThresholds(options.threshold); this.root = options.root || null; this.rootMargin = this._rootMarginValues.map(function(margin) &#123; return margin.value + margin.unit; &#125;).join(' '); &#125; IntersectionObserver是一个构造函数。当我们创建其实例的时候，可以传递两个参数。第一个参数必须是一个函数，否则会抛出一个错误。第二个参数是一个可选的对象，唯一的要求就是我们指定的root属性的值必须是一个Element。构造函数会在创建实例的时候添加很多私有属性。有些属性后面用到的时候会讲解，这里我们先看几个用来保存我们传递的选项的属性。 在创建IntersectionObserver实例的时候，我们可以在第二个参数对象中传入以下几个属性 12345&#123; root: Element, rootMargin: string, threshold: number | number[]&#125; 在构造函数中首先会调用私有方法解析我们传入的rootMargin属性，下面是这个方法的基本实现 1234567891011121314151617IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) &#123; var marginString = opt_rootMargin || '0px'; var margins = marginString.split(/\\s+/).map(function(margin) &#123; var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin); if (!parts) &#123; throw new Error('rootMargin must be specified in pixels or percent'); &#125; return &#123;value: parseFloat(parts[1]), unit: parts[2]&#125;; &#125;); // Handles shorthand. margins[1] = margins[1] || margins[0]; margins[2] = margins[2] || margins[0]; margins[3] = margins[3] || margins[1]; return margins;&#125; 这个方法就是将我们传入的rootMargin解析成数组，这个数组包含四个元素代表的分别是上，右，下，左边距的值和单位。rootMargin设置的时候和css margin设置的方式一样，可以传入1,2,3,4个值。比如 rootMargin: &apos;10px&apos; --&gt; _parseRootMargin(rootMargin) --&gt; [{value: 10, unit: &apos;px&apos;},{value: 10, unit: &apos;px&apos;},{value: 10, unit: &apos;px&apos;},{value: 10, unit: &apos;px&apos;}] // 传入2，3，4个值的解析规则和css margin的解析规则其实是一样的解析完rootMargin后，私有属性this._rootMarginValues就是如下形式 [ {value: 10, unit: &apos;px&apos;}, {value: 10, unit: &apos;px&apos;}, {value: 10, unit: &apos;px&apos;}, {value: 10, unit: &apos;px&apos;} ]后面又将其转化为this.rootMargin的值 123this.rootMargin = this._rootMarginValues.map(function(margin) &#123; return margin.value + margin.unit; &#125;).join(' '); 所以，无论我们传入的rootMargin是什么样的形式，构造函数执行结束后都会变成10px 10px 10px 10px的形式。 在构造函数中还有一个步骤是初始化我们传入的threshold。我们知道，threshold可以是一个数字，也可以是由数字组成的数组。构造函数执行的时候，会统一将其转换成数组的形式并保存在this.thresholds属性中 1this.thresholds = this._initThresholds(options.threshold); 下面是解析threshold的_initThreshold方法的实现 1234567891011IntersectionObserver.prototype._initThresholds = function(opt_threshold) &#123; var threshold = opt_threshold || [0]; if (!Array.isArray(threshold)) threshold = [threshold]; return threshold.sort().filter(function(t, i, a) &#123; if (typeof t != 'number' || isNaN(t) || t &lt; 0 || t &gt; 1) &#123; throw new Error('threshold must be a number between 0 and 1 inclusively'); &#125; return t !== a[i - 1]; &#125;);&#125; 这个方法接收我们传入的options.threshold选项的值作为参数，如果我们没有传入这个值，则默认为0。如果我们传入的不是一个数组，就将其转化为数组。下面的filter是对一个数组进行去重的方法，即如果我们对threshold传入了重复的值，只会取一个。而且threshold中的每一个值都必须是数字，并且在[0, 1]之间。所以，this.threshold最终保存的值是如下形式 this.threshold = [0] this.threshold = [0.25, 0.5, 1]上面就是IntersectionObserver构造函数大致的执行过程，实例创建好后，我们会调用observe方法监测元素。下面我们看一下observe方法的具体实现 observeobserve方法定义在IntersectionObserver.prototype上 123456789101112131415161718IntersectionObserver.prototype.observe = function(target) &#123; var isTargetAlreadyObserved = this._observationTargets.some(function(item) &#123; return item.element == target; &#125;); if (isTargetAlreadyObserved) &#123; return; &#125; if (!(target &amp;&amp; target.nodeType == 1)) &#123; throw new Error('target must be an Element'); &#125; this._registerInstance(); this._observationTargets.push(&#123;element: target, entry: null&#125;); this._monitorIntersections(); this._checkForIntersections();&#125; 接收的参数就是我们需要监测的dom元素。首先会遍历this._observationTargets，这个属性是一个数组，它也是在初始化IntersectionObserver的时候创建的 this._observationTargets = [];对这个属性的遍历，其实就是为了判断当前的observer是否已经通过observe方法监测过target元素。如果已经监测过，就直接return，防止同一个observer实例对同一个target元素进行多次监测。 如果没有监测过target元素，这里同样会对target的类型进行判断。如果不是一个dom结点，同样会抛出一个错误。 接着，会调用this._registerInstance方法。这个方法的主要作用就是将当前的observer实例添加到全局数组registry中，主要是为了防止我们的observer实例被垃圾回收进行清除 12345IntersectionObserver.prototype._registerInstance = function() &#123; if (registry.indexOf(this) &lt; 0) &#123; registry.push(this); &#125;&#125; 然后，将我们target元素保存在this._observationTargets中。从上面代码中可以看到，this._observationTargets并不只是保存target元素。它会将target元素作为一个对象的element属性的值进行保存，同时这个对象还有一个entry属性。这个属性初始的时候是一个null，后续是IntersectionObserverEntry的一个实例对象。 之后调用this._monitorIntersections方法，这个方法后面我们会说。它的作用主要就是采用什么样的方式来检测target的状态。 最后调用this._checkForIntersections方法，这个方法同样会在后面讲解。这里它主要就是对target元素的状态进行一次初始的判断。如果target元素在初始的时候已经满足了和root元素的交集的状态，在调用这个方法的时候就会触发我们的回调函数。 _monitorIntersections调用observe方法之后，我们就能够监测target元素的状态了。对target元素状态的监测，就是通过调用上面我们所提到的this._monitorIntersections方法。这里我们来看一下这个方法是怎么实现对元素的监测的 1234567891011121314151617181920212223242526IntersectionObserver.prototype._monitorIntersections = function() &#123; if (!this._monitoringIntersections) &#123; this._monitoringIntersections = true; // If a poll interval is set, use polling instead of listening to // resize and scroll events or DOM mutations. if (this.POLL_INTERVAL) &#123; this._monitoringInterval = setInterval( this._checkForIntersections, this.POLL_INTERVAL); &#125; else &#123; addEvent(window, 'resize', this._checkForIntersections, true); addEvent(document, 'scroll', this._checkForIntersections, true); if (this.USE_MUTATION_OBSERVER &amp;&amp; 'MutationObserver' in window) &#123; this._domObserver = new MutationObserver(this._checkForIntersections); this._domObserver.observe(document, &#123; attributes: true, childList: true, characterData: true, subtree: true &#125;); &#125; &#125; &#125;&#125; 这个方法提供了两种方式用来监测元素状态的变化。第一种很简单，也很粗暴 – polling。这种方式默认是关闭的 IntersectionObserver.prototype.POLL_INTERVAL = null;如果你想使用polling的方式监测元素的状态，则需要在创建IntersectionObserver实例之后，调用observe方法之前设置observer.POLL_INTERVAL属性，比如 12345const observer = new IntersectionObserver(() =&gt; &#123;&#125;)observer.POLL_INTERVAL = 300observer.observe(target) 如果按照上面代码的设置，浏览器就会开启一个定时器，每300毫秒判断一下元素的状态 12this._monitoringInterval = setInterval( this._checkForIntersections, this.POLL_INTERVAL); 但是，这种方式不推荐；所以在polyfill的源码中默认将这种方式关闭，采用更高效的事件监听的方式来监测元素状态的变化。首先需要监听window的resize和document的scroll事件。监听这两种事件能够满足大多数对元素状态判断的情况。如果一个元素自身的属性没有变化，当窗口滚动或者大小改变的时候都会影响元素和”视窗”的交集。但是，在某些业务场景下这两种事件是无法监测到元素状态的变化的。比如选项卡切换，元素自身的显示和隐藏等。对于这种情况，polyfill中同样采用一种粗暴的方法 123456789if (this.USE_MUTATION_OBSERVER &amp;&amp; 'MutationObserver' in window) &#123; this._domObserver = new MutationObserver(this._checkForIntersections); this._domObserver.observe(document, &#123; attributes: true, childList: true, characterData: true, subtree: true &#125;);&#125; 通过MutationObserver接口监测document元素下所有节点的attributes，childList和characterData的变化。每当有子节点状态变化的时候都会去检测target元素和root元素的交集状态。这种方式很粗暴，但是某些业务场景下我们也不得不这样做。 上面监测元素所有的方式中，其回调函数都是this._checkForIntersections方法。这个方法在上面也提到过，在调用observe方法的时候同样也会调用这个方法。这个方法到底做了什么，下面就详细的看一下。 _checkForIntersections在详细讲解这个方法之前，先来简单的总结一下这个方法会在什么样的条件下被调用 调用observer.observe(target)方法的时候 采用轮询的方式监测元素，作为setInterval回调函数 采用事件的方式监测元素，作为document的scroll事件的回调函数 采用事件的方式监测元素，作为window的resize事件的回调函数 采用事件的方式监测元素，作为MutationObserver的回调函数 总之，在this._checkForIntersections方法被调用的时候，主要就是为了判断target元素和root元素的交集状态有没有发生变化，如果交集状态发生了变化，就会触发我们的回调函数。下面就详细的看一下这个方法到底做了哪些事情 123456789101112131415161718192021222324252627282930313233343536373839404142IntersectionObserver.prototype._checkForIntersections = function() &#123; var rootIsInDom = this._rootIsInDom(); var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect(); this._observationTargets.forEach(function(item) &#123; var target = item.element; var targetRect = getBoundingClientRect(target); var rootContainsTarget = this._rootContainsTarget(target); var oldEntry = item.entry; var intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp; this._computeTargetAndRootIntersection(target, rootRect); var newEntry = item.entry = new IntersectionObserverEntry(&#123; time: now(), target: target, boundingClientRect: targetRect, rootBounds: rootRect, intersectionRect: intersectionRect &#125;); if (!oldEntry) &#123; this._queuedEntries.push(newEntry); &#125; else if (rootIsInDom &amp;&amp; rootContainsTarget) &#123; // If the new entry intersection ratio has crossed any of the // thresholds, add a new entry. if (this._hasCrossedThreshold(oldEntry, newEntry)) &#123; this._queuedEntries.push(newEntry); &#125; &#125; else &#123; // If the root is not in the DOM or target is not contained within // root but the previous entry for this target had an intersection, // add a new record indicating removal. if (oldEntry &amp;&amp; oldEntry.isIntersecting) &#123; this._queuedEntries.push(newEntry); &#125; &#125; &#125;, this); if (this._queuedEntries.length) &#123; this._callback(this.takeRecords(), this); &#125;&#125; 首先会判断root元素是不是在dom结构中 1234567891011121314151617181920212223242526272829IntersectionObserver.prototype._rootIsInDom = function() &#123; return !this.root || containsDeep(document, this.root);&#125;function containsDeep(parent, child) &#123; var node = child; while (node) &#123; if (node == parent) return true; node = getParentNode(node); &#125; return false;&#125;function getParentNode(node) &#123; var parent = node.parentNode; if (parent &amp;&amp; parent.nodeType == 11 &amp;&amp; parent.host) &#123; // If the parent is a shadow root, return the host element. return parent.host; &#125; if (parent &amp;&amp; parent.assignedSlot) &#123; // If the parent is distributed in a &lt;slot&gt;, return the parent of a slot. return parent.assignedSlot.parentNode; &#125; return parent;&#125; 上面的代码主要就是用来判断root元素是不是在dom结构中。所以这就要求我们传入的options.root选项一定要是target的祖先元素。 接着会获取root元素的区域数据 12345678910111213141516171819IntersectionObserver.prototype._getRootRect = function() &#123; var rootRect; if (this.root) &#123; rootRect = getBoundingClientRect(this.root); &#125; else &#123; // Use &lt;html&gt;/&lt;body&gt; instead of window since scroll bars affect size. var html = document.documentElement; var body = document.body; rootRect = &#123; top: 0, left: 0, right: html.clientWidth || body.clientWidth, width: html.clientWidth || body.clientWidth, bottom: html.clientHeight || body.clientHeight, height: html.clientHeight || body.clientHeight &#125;; &#125; return this._expandRectByRootMargin(rootRect);&#125; 如果我们自己传递了root元素，就会通过root.getBoundingClientRect方法获取到root的区域数据。如果采用默认的document元素，则会使用视窗的区域数据。后面又调用了_expandRectByRootMargin方法，这个方法主要是用来将我们传入的rootMargin和rootRect数据结合得出新的newRootRect数据。 12345678910111213141516IntersectionObserver.prototype._expandRectByRootMargin = function(rect) &#123; var margins = this._rootMarginValues.map(function(margin, i) &#123; return margin.unit == 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100; &#125;); var newRect = &#123; top: rect.top - margins[0], right: rect.right + margins[1], bottom: rect.bottom + margins[2], left: rect.left - margins[3] &#125;; newRect.width = newRect.right - newRect.left; newRect.height = newRect.bottom - newRect.top; return newRect;&#125; _expandRectByRootMargin方法很好理解，就是将rootRect和rootMargin结合计算出新的rootRect区域的大小。 在root的区域确定后，会遍历this._observationTargets属性。这个属性上面我们也提过，它用来保存被observer所监测的所有的target元素。遍历的过程先不看，后面还有一小段代码 123if (this._queuedEntries.length) &#123; this._callback(this.takeRecords(), this);&#125; this._queuedEntries这个属性一个数组，其中每一个元素都是IntersectionObserverEntry实例对象。只有当这个属性的长度大于0的时候，才会触发回调函数。在讲解IntersectionObserver方法的基本使用的时候我们曾经说过，callback的第一个参数是由IntersectionObserverEntry实例组成的数组，那这里是通过this.takeRecords()方法获取的，这个方法做了什么？ 12345IntersectionObserver.prototype.takeRecords = function() &#123; var records = this._queuedEntries.slice(); this._queuedEntries = []; return records;&#125; 这个方法很简单，就是通过slice方法对this._queuedEntries数据做个备份，然后清空this._queuedEntries。这表示在这个时间段内和root发生交集变化的target会在调用this._checkForIntersections后交给我们的callback统一处理。也就是说，每个时间段都是重新收集发生变化的target的。 下面我们来看一下对this._observationTargets的遍历会做哪些事情？估计大家也能想到，它主要就是用来收集在这个阶段中和root元素发生交集变化的target元素，并将新的交集状态(IntersectionObserverEntry实例对象) 保存在this._queuedEntries队列中 123456789101112131415161718192021222324252627282930313233this._observationTargets.forEach(function(item) &#123; var target = item.element; var targetRect = getBoundingClientRect(target); var rootContainsTarget = this._rootContainsTarget(target); var oldEntry = item.entry; var intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp; this._computeTargetAndRootIntersection(target, rootRect); var newEntry = item.entry = new IntersectionObserverEntry(&#123; time: now(), target: target, boundingClientRect: targetRect, rootBounds: rootRect, intersectionRect: intersectionRect &#125;); if (!oldEntry) &#123; this._queuedEntries.push(newEntry); &#125; else if (rootIsInDom &amp;&amp; rootContainsTarget) &#123; // If the new entry intersection ratio has crossed any of the // thresholds, add a new entry. if (this._hasCrossedThreshold(oldEntry, newEntry)) &#123; this._queuedEntries.push(newEntry); &#125; &#125; else &#123; // If the root is not in the DOM or target is not contained within // root but the previous entry for this target had an intersection, // add a new record indicating removal. if (oldEntry &amp;&amp; oldEntry.isIntersecting) &#123; this._queuedEntries.push(newEntry); &#125; &#125;&#125;, this); 在遍历的过程中，首先获取每个target元素的区域数据，然后调用this._rootContainsTarget方法，这个方法就是用来判断root元素是不是target元素的祖先元素 123IntersectionObserver.prototype._rootContainsTarget = function(target) &#123; return containsDeep(this.root || document, target);&#125; 下面，我们先看一下这段代码做了啥，后面再看看item.entry是什么 12var intersectionRect = rootIsInDom &amp;&amp; rootContainsTarget &amp;&amp; this._computeTargetAndRootIntersection(target, rootRect); 如果rootIsInDom为真（表示root元素在dom结构中）且rootContainsTarget为真（表示root是target元素的祖先元素），就调用this._computeTargetAndRootIntersection方法。这个方法从名称上应该都能理解它的作用：计算target元素和root元素的相交区域。其实就是用来计算相交面积intersectionRect的大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445IntersectionObserver.prototype._computeTargetAndRootIntersection = function(target, rootRect) &#123; // If the element isn't displayed, an intersection can't happen. if (window.getComputedStyle(target).display == 'none') return; var targetRect = getBoundingClientRect(target); var intersectionRect = targetRect; var parent = getParentNode(target); var atRoot = false; while (!atRoot) &#123; var parentRect = null; var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : &#123;&#125;; // If the parent isn't displayed, an intersection can't happen. if (parentComputedStyle.display == 'none') return; if (parent == this.root || parent == document) &#123; atRoot = true; parentRect = rootRect; &#125; else &#123; // If the element has a non-visible overflow, and it's not the &lt;body&gt; // or &lt;html&gt; element, update the intersection rect. // Note: &lt;body&gt; and &lt;html&gt; cannot be clipped to a rect that's not also // the document rect, so no need to compute a new intersection. if (parent != document.body &amp;&amp; parent != document.documentElement &amp;&amp; parentComputedStyle.overflow != 'visible') &#123; parentRect = getBoundingClientRect(parent); &#125; &#125; // If either of the above conditionals set a new parentRect, // calculate new intersection data. if (parentRect) &#123; intersectionRect = computeRectIntersection(parentRect, intersectionRect); if (!intersectionRect) break; &#125; parent = getParentNode(parent); &#125; return intersectionRect;&#125; 这个方法接收的两个参数分别是target元素和root元素区域的大小。如果元素是隐藏的，是不可能存在相交的，所以直接返回就行了。接着会获取target区域数据和其parentNode元素，并设置一个标志位用来表示下面的while循环是否循环到了this.root或者是document。在while循环中先会判断target.parentNode是否显示，如果其隐藏的话，target和root元素同样是不可能存在交集的。这里我们先假设我们采用默认的root即document，而且parentNode就是document，那么循环将会进入if分支，并将parentRect设置rootRect的大小，atRoot设置为true。接着会执行如下代码 123456if (parentRect) &#123; intersectionRect = computeRectIntersection(parentRect, intersectionRect); if (!intersectionRect) break;&#125;parent = getParentNode(parent); 在这个分支中会执行computeRectIntersection函数，这个函数才是真正的计算target和root相交区域的大小 1234567891011121314151617function computeRectIntersection(rect1, rect2) &#123; var top = Math.max(rect1.top, rect2.top); var bottom = Math.min(rect1.bottom, rect2.bottom); var left = Math.max(rect1.left, rect2.left); var right = Math.min(rect1.right, rect2.right); var width = right - left; var height = bottom - top; return (width &gt;= 0 &amp;&amp; height &gt;= 0) &amp;&amp; &#123; top: top, bottom: bottom, left: left, right: right, width: width, height: height &#125;;&#125; 我们将这段代码用下面的图片来表示，就能看出它到底在做啥 上图中红色的线段就是相交区域的上，下，左，右的长度。所以，相交区域的大小就是图中橙色实心部分的大小。如果target位于root的区域外，则表示width或者height至少有一个&lt;=0。那么计算出来的相交区域的大小也就为0。 假设target.parentNode不是document，那么while循环会执行else分支。其中执行else分支有一个条件parentComputedStyle.overflow != &#39;visible&#39;。如果parentComputedStyle.overflow的值为visible，那么target和root最大的交叉面积就是target的大小，如果parentComputedStyle.overflow的值不为visible，那么target和root最大的交叉面积是多少呢？最大的交叉面积就是target最大能显示出来的面积的大小。 交叉面积计算出来后，我们接着分析下面的代码 123456789var oldEntry = item.entry;var newEntry = item.entry = new IntersectionObserverEntry(&#123; time: now(), target: target, boundingClientRect: targetRect, rootBounds: rootRect, intersectionRect: intersectionRect&#125;); 先看对newEntry的赋值。我们上面说过this._observationTargets保存的数据的结构为{element: target, entry: null}这种类型。从这里就能看到entry就是通过new IntersectionObserverEntry就是创建的实例对象。那oldEntry是什么呢？oldEntry就是上一次调用this._checkForIntersections方法的时候所创建的entry对象。这里为什么取新老两次entry对象，后面我们会分析。这里我们先看一下IntersectionObserverEntry构造函数的执行流程 123456789101112131415161718192021222324function IntersectionObserverEntry(entry) &#123; this.time = entry.time; this.target = entry.target; this.rootBounds = entry.rootBounds; this.boundingClientRect = entry.boundingClientRect; this.intersectionRect = entry.intersectionRect || getEmptyRect(); this.isIntersecting = !!entry.intersectionRect; // Calculates the intersection ratio. var targetRect = this.boundingClientRect; var targetArea = targetRect.width * targetRect.height; var intersectionRect = this.intersectionRect; var intersectionArea = intersectionRect.width * intersectionRect.height; // Sets intersection ratio. if (targetArea) &#123; // Round the intersection ratio to avoid floating point math issues: // https://github.com/w3c/IntersectionObserver/issues/324 this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4)); &#125; else &#123; // If area is zero and is intersecting, sets to 1, otherwise to 0 this.intersectionRatio = this.isIntersecting ? 1 : 0; &#125;&#125; IntersectionObserverEntry函数的执行流程十分简单，就是计算出其各个属性的值。其它的属性我们就不多说了，这里我们主要看以下三个属性值 1234567891011this.intersectionRect = entry.intersectionRect || getEmptyRect();this.isIntersecting = !!entry.intersectionRect;if (targetArea) &#123; // Round the intersection ratio to avoid floating point math issues: // https://github.com/w3c/IntersectionObserver/issues/324 this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4)); &#125; else &#123; // If area is zero and is intersecting, sets to 1, otherwise to 0 this.intersectionRatio = this.isIntersecting ? 1 : 0; &#125; 其中this.intersectionRect就是上面通过this._computeTargetAndRootIntersection方法计算出来的。this.isIntersecting的判定也十分简单，如果存在相交面积，就表示相交。不存在相交面积，就表示不想交。最后是相交比this.intersectionRatio的计算，正常情况下(target的width和height都不为0)就是intersectionArea和target区域面积的比值。 然后就会判断oldEntry是否存在，oldEntry在什么状态下不会存在？在初始调用，也就是调用observer.observe方法监测target元素的时候item.entry是不存在的。然后就会将newEntry添加到this._queuedEntries队列中，当执行到 123if (this._queuedEntries.length) &#123; this._callback(this.takeRecords(), this);&#125; 的时候，就会调用我们传入的回调函数。 如果不是在初始状态下，在rootIsInDom &amp;&amp; rootContainsTarget为真的时候，会调用this._hasCrossedThreshold方法，那这个方法是干啥的？我们在介绍IntersectionObserver的时候曾经提到在创建IntersectionObserver实例的时候，我们传入一个选项，可以通过这个选项的threshold属性指定相交比达到什么样的条件才需要触发我们的回调函数。this._hasCrossedThreshold就是用来判断这种情况的。 123456789101112131415161718192021222324IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry) &#123; // To make comparing easier, an entry that has a ratio of 0 // but does not actually intersect is given a value of -1 var oldRatio = oldEntry &amp;&amp; oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1; var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1; // Ignore unchanged ratios if (oldRatio === newRatio) return; for (var i = 0; i &lt; this.thresholds.length; i++) &#123; var threshold = this.thresholds[i]; // Return true if an entry matches a threshold or if the new ratio // and the old ratio are on the opposite sides of a threshold. if (threshold == oldRatio || threshold == newRatio || threshold &lt; oldRatio !== threshold &lt; newRatio) &#123; return true; &#125; &#125;&#125; 从_hasCrossedThreshold代码中我们可以看到。如果target完全没有显示oldRatio === newRatio === -1，直接return。这种情况下是不会执行我们的回调函数的。如果target完全显示oldRatio === newRatio === newEntry.intersectionRatio，这种情况下也不会执行我们的回调函数。那什么时候才会执行我们的回调函数呢，从这段代码的for循环中我们可以总结出只有当threshold设置的值在oldRatio和newRatio之间的时候才会执行我们的回调。这里大家可以画图分析一下。 上面就是关于怎么监测target和执行回调函数时机的分析，下面我们看一下unobserve的过程 unobserve1234567891011IntersectionObserver.prototype.unobserve = function(target) &#123; this._observationTargets = this._observationTargets.filter(function(item) &#123; return item.element != target; &#125;); if (!this._observationTargets.length) &#123; this._unmonitorIntersections(); this._unregisterInstance(); &#125;&#125; unobserve的执行流程十分简单，首先是从this._observationTargets将target删除。如果this._observationTargets队列长度为0，表示当前的observer没有监听任何target，那么就可以将当前observer从全局的registry数组中删除。如果registry也为空，那么就可以卸载相关事件。这个过程主要是通过this._unmonitorIntersections和this._unregisterInstance方法来实现的 1234567891011121314151617181920212223IntersectionObserver.prototype._unmonitorIntersections = function() &#123; if (this._monitoringIntersections) &#123; this._monitoringIntersections = false; clearInterval(this._monitoringInterval); this._monitoringInterval = null; removeEvent(window, 'resize', this._checkForIntersections, true); removeEvent(document, 'scroll', this._checkForIntersections, true); if (this._domObserver) &#123; this._domObserver.disconnect(); this._domObserver = null; &#125; &#125;&#125;IntersectionObserver.prototype._unregisterInstance = function() &#123; var index = registry.indexOf(this); if (index != -1) registry.splice(index, 1);&#125; disconnectdisconnect可以一次性取消observer对所有target的监测，这个方法的实现同样很简单 12345IntersectionObserver.prototype.disconnect = function() &#123; this._observationTargets = []; this._unmonitorIntersections(); this._unregisterInstance();&#125; 上面就是对IntersectionObserver polyfill源码的大致分析。如有错误，欢迎指正。 使用IntersectionObserver实现一个简单的无限滚动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .img-area &#123; width: 500px; height: 320px; margin: 0 auto; &#125; .my-photo &#123; width: 500px; height: 300px; opacity: 0; -webkit-transition: opacity 0.25s ease-in-out; -moz-transition: opacity 0.25s ease-in-out; -o-transition: opacity 0.25s ease-in-out; transition: opacity 0.25s ease-in-out; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class=\"body\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;div class=\"img-area\"&gt;&lt;img class=\"my-photo\" alt=\"loading\" data-src=\"./img/1.png\" /&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt; &lt;!-- 页尾标志，判断是否需要新添加节点到文档流中 --&gt; &lt;script&gt; function loadItems(io, count = 10) &#123; let container = document.querySelector('.container') const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; count; i++) &#123; const li = document.createElement('div') li.className = 'img-area'; const img = document.createElement('img') img.className = 'my-photo' img.alt = 'loading' img.dataset.src = './img/1.png' li.appendChild(img); fragment.appendChild(li); io.observe(img) &#125; container.appendChild(fragment) &#125; function lazyLoad(imgClassName) &#123; const imgList = Array.from(document.querySelectorAll(imgClassName)); var opts = &#123; root: document, rootMargin: \"500px 0px\" &#125;; const io = new IntersectionObserver(function (ioes) &#123; ioes.forEach(function (ioe) &#123; const el = ioe.target; const cn = el.className; // const intersectionRatio = ioe.intersectionRatio; if (cn === 'footer') &#123; if (!ioe.isIntersecting) return; loadItems(io); console.log('loaded new items'); &#125; else if (ioe.isIntersecting) &#123; //对于图片节点，当其进入范围内，则load其src if (!el.src) &#123; el.src = el.dataset.src; el.onload = function (e) &#123; el.style.opacity = 1 &#125; io.unobserve(el); //加载图片后停止观察该节点 &#125; &#125; &#125;) &#125;, opts); imgList.forEach(function (item) &#123; io.observe(item) &#125;); io.observe(document.querySelector(\".footer\")) //观察footer节点，判断添加新节点的时机 &#125; lazyLoad('.my-photo'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果图：","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://kobin.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"IntersectionObserver","slug":"IntersectionObserver","permalink":"http://kobin.top/tags/IntersectionObserver/"}]},{"title":"男士洗面奶","slug":"生活-男士洗面奶推荐","date":"2020-09-30T17:37:27.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"生活-男士洗面奶推荐/","link":"","permalink":"http://kobin.top/%E7%94%9F%E6%B4%BB-%E7%94%B7%E5%A3%AB%E6%B4%97%E9%9D%A2%E5%A5%B6%E6%8E%A8%E8%8D%90/","excerpt":"作为全虎扑拥有洗面奶最多的男人，我评价一款洗面奶永远不是嘴上说好用不好用那么简单。好用要有好用的理由，不好用也要说出不好用的地方。","text":"作为全虎扑拥有洗面奶最多的男人，我评价一款洗面奶永远不是嘴上说好用不好用那么简单。好用要有好用的理由，不好用也要说出不好用的地方。 今天就虎扑权威男性洗面奶排行榜，来说一说到底哪些洗面奶值得买。我会从成分分析、酸碱测试、使用体验和适用肤质4个方面来具体盘一盘。 不懂选择的，对比虎扑洗面奶排行榜，参考文章，对应肤质和预算，直接入就完事了！ OK，上菜单： 个人建议，选择购入产品，直接选择天猫官方店，价格透明，买的放心，其他平台容易出假，仿货！ ◎NO.1芙丽芳丝 （150元/100g）1【成分分析】 成分分析这块儿讲的会有点小枯燥，不喜欢看的直接跳到下一趴！ 这几年芙丽芳丝应该没少在广告上砸钱，洁面界第一网红的称号不是白来的。 宣传适合敏感肌的洁面，没有刺激性香精防腐剂，靠柠檬酸+丁二醇来防腐，还算靠谱。 清洁方面主要靠的是氨基酸表活-椰油酰甘氨酸钾，中等偏上清洁力。甘油排位第一为了保湿。添加有两种致痘风险的乳化剂，从消费者反馈来说，有一定致痘风险，我自己用着期间，还没长嘿嘿。 从烟酰胺开始的各种活性成分，添加量很低很低，而且不在脸上停留，不说也罢！ 2【酸碱测试】 PH值介于6-7之间，还算过关！比较温和，对肌肤基本没什么刺激。我换季过敏用都毫无压力。 3【使用体验】 乳膏质地，洗出来的泡泡跟棉花一样，细密温和。味道有点像宝宝身上的奶香味儿，个人能接受，但是看淘宝评价有人说像塑料……让人有点方。 洗的干净，洗完不绷，是一款过敏或日常用都可的安全洗面奶。 4【适用肤质】 除了塔克拉玛干和大庆油田，基本所有肤质都适用。但是含有烟酰胺，重敏皮要避雷。 ◎NO.2 简男六角瓶 （39.9元） 这是我多次回购的，油性肌肤用它没错了！ 1【成分分析】 作为新型氨基酸粉末洁面，有着比传统乳状洗面奶更明显的优势，溶解速度快，上脸不黏腻，不担心像乳状一样可能会残留，用着舒心方便 备案没有任何乱七八糟的防腐剂香精成分，巨巨巨温和！甘露糖醇复配聚乙二醇负责保湿，氨基酸表活负责清洁，用之后才知道什么叫真正嫩滑不拔干，学术派护肤党我爱了。 2【酸碱测试】 跟皮肤贴合的完美酸碱值，接近于6，上脸一点刺激也没有。 3【使用体验】 相比于膏状和乳状以及泡泡洁面，粉状洁面使用感上升了好几个档次，用过的人都懂。 每次洗脸用一小盒，携带方便，干净卫生，出差日常都可。清洁效果的确挺神奇，每次都能感到颗粒感的粉质能够搓出来一些死皮和附着在毛孔表面的小白头，太加分了！ 没有用过洁颜粉的，墙裂建议试试。 4【适用肤质】 尤其适合油皮男士！ ◎NO3. 旁氏米粹洗面奶（29.9-59元之间）上榜的那位，虽然便宜量足。但是含有二氧化钛，洗完假白。相对来说旁氏米粹洁面泡泡这个亲兄弟更值得入。 不吹说，也就旁氏泡泡能摊得上便宜大碗，30块钱这么大一管，其他牌子就别来凑热闹了行么？ 因为便宜，表活用的也是最便宜的椰油酰甘氨酸钾，氨基酸类，温和。 插一句，氨基酸洗面奶真的是很普通的一种洗面奶类型，工作关系总是看到各种洗面奶用氨基酸给自己抬身价，没啥稀罕的呀。 2【酸碱测试】 作为一款老实本分的温和型洁面，pH在6～7之间，接近皮肤本身的pH值，无论油皮干皮敏感肌都可以放心pick。 3【使用体验】 按压出来就是泡泡，不像珂润，旁氏的泡泡挤出来啥样上脸还啥样，不会变虚变薄。洗的时候有淡淡的淘米水味，搞得我每次洗脸都感到有点饿怎么肥四。洗完不干不紧绷，价格也很学生党，是我大学时期回购次数最多的洗面奶，谁让我穷呢～～ 4【适用肤质】 只要不是两极分化的大庆油田或撒哈拉沙漠，大部分肤质都可。有香精，重敏的人不要用。 篇幅有限，其他洗面奶就来简单说一说。 ◎NO4. 日本UNO洗面奶 （55元）NUO？我傻了。 UNO吾诺男士洗面奶有黑管、蓝管、绿管三种颜色，这76个泡泡值估计都是投给黑管的。 成分分析：皂基表活，清洁力强大。添加辣薄荷，洗感清凉。 使用体验：一个字爽，两个字凉爽。夏天用还好，秋冬真的有种抹风油精的感觉。洗完略紧绷，需要及时补水。 适用肤质：油性耐受肌。 ◎NO5. 碧欧泉洗面奶说实话，碧欧泉排行第五有点亏，可能价格有点小贵，用的人不多。所以给他投票的人也不多。 成分分析：同为皂基表活，但是整体比UNO要温和得多，添加了很多活性成分，贵有贵的理由。 使用体验：调香高级，淡淡的茶香，清洁力、温和性也平衡得很好，洗完完全不会感到拔干。 适用肤质：中性-油性耐受肌。 ◎NO.6 Elta MD（80-188元）这款洗面奶JR用得不多，但在小红书上可是火的一塌糊涂。是美国各大皮肤科医生也会推荐的温和型洁面。 成分分析：典型的氨基酸洁面，加入了沸点很低的醚类，上脸30秒后可自动起泡。 使用体验：成也萧何，败也萧何。虽然这款洗面奶的亮点是可以自动发泡。但麻烦的是每次用完都要旋转泵头锁住洗面奶，不然它会吐泡泡到你怀疑人生。 适用肤质：全肤质适用。 ◎NO.7理肤泉洗面奶相信很多人都是从理肤泉雅漾这类外国牌子开始接触药妆的。这款理肤泉特安洁面，从名字就能看出来非常适合敏感肌。 成分分析：宣传适合敏感肌的洁面却含有5种皂基表活成分，我有点方。感觉这个洁面更适合油皮才对。 适用体验：清洁力好，无香精防腐剂，虽然是皂基表活，但还算温和。 适用肤质：油皮、油皮敏感肌 ◎NO.8欧莱雅火山泥在JR心中是永远的神和永远的shi。 成分分析：典型的皂基表活，含有水杨酸，红色质地来自于高岭土。 使用体验：所谓男性去油系列，就是挂掉你脸上的油，刮油效果不是盖的，用完绷的感觉自己像干尸。油皮瞬间变干皮。对付直男就是要狠。但是这种刮油的方式只会加重痘痘，刺激痘痘，搞不好就会引起外油内干的情况出现。 适用肤质：油皮，不推荐。 ◎NO.9雅诗兰黛白金洗面奶雅诗兰黛白金洗面奶号称可以温和卸妆。这款分为有泡板和无泡板。看包装，有泡foam，无泡creme. 成分分析：氨基酸系贵妇洗面奶。大牌们可能是商量好的，只要出氨基酸洗面奶就要可着劲儿的添加活性成分，不管这些活性成分有没有用，加上去就能宣传卖高价。 适用体验：贵妇洗面奶使用感就是好呀，质地、泡沫、调香没得说。但是这些活性成分没卵用，要知道洗面奶只在脸上停留几十秒钟，这么短的时间内，活性成分是不可能被吸收的。 适用肤质：全肤质适用 ◎NO.10丝塔芙洗面奶没有想到丝塔芙这种毫无清洁力的洗面奶，还能在JR心中占有一席之地。 成分分析：备案成分一共8种。清洁剂一种，防腐剂三种，神了。清洁剂虽然是我们常说的刺激性较大的SLS，但是添加量较低，对皮肤造不成什么伤害。 使用体验：个人油性皮肤，对这种几乎无泡无清洁力的洗面奶不感冒，洗完感觉滑滑的，一点都没洗干净。可能干皮会比较喜欢它的温和吧。 适用肤质：干皮 Source","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://kobin.top/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"npm依赖管理中容易被忽略细节","slug":"node-2020-09-15-npm依赖管理中容易被忽略细节","date":"2020-09-15T23:38:27.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"node-2020-09-15-npm依赖管理中容易被忽略细节/","link":"","permalink":"http://kobin.top/node-2020-09-15-npm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%AD%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%BB%86%E8%8A%82/","excerpt":"提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。","text":"提起 npm，大家第一个想到的应该就是 npm install 了，但是 npm install 之后生成的 node_modules 大家有观察过吗？package-lock.json 文件的作用大家知道吗？除了 dependencies 和 devDependencies，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。 npm 安装机制A 和 B 同时依赖 C，C 这个包会被安装在哪里呢？C 的版本相同和版本不同时安装会有什么差异呢？package.json 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。 A 和 B 同时依赖 C，这个包会被安装在哪里呢？假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。\b执行完毕后，我们会看到 ./node_modules这层目录只含有这两个子目录： node_modules/├─┬ A│ ├── C├─┬ B│ └── C 如果使用 npm 3 来进行安装的话，./node_modules 下的目录将会包含三个子目录： node_modules/├─┬ A├─┬ B├─┬ C 为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了： npm 2 和 npm 3 模块安装机制的差异虽然目前最新的 npm 版本是 npm 6，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异​。 npm 2 在安装依赖包时，采用\b简单的递归安装方法。执行 npm install 后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。\b执行完毕后，我们会看到 ./node_modules 这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树： 这样的目录有较为明显的好处： 层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录； 在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置； 如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录； 但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行 npm install 后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误； ​ 为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。 npm 3 对于同一依赖的不同版本会怎么处理呢？npm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2): 但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况： 由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。 为什么会出现 package-lock.json 呢？为什么会有 package-lock.json 文件呢？这个我们就要先从 package.json 文件说起了。 package.json 的不足之处npm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因： 1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 A: ‘^1.0.5’ ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的 semver-range version 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug； 2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 A: ‘1.0.5’ 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。 针对 package.json 不足的解决方法为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。 package-lock.json 文件的结构package-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 package-lock-json官方文档，主要的结构如下： version ：包版本，即这个包当前安装在 node_modules 中的版本 resolved ：包具体的安装来源 integrity ：包 hash 值，验证已安装的软件包是否被改动过、是否已失效 requires ：对应子依赖的依赖，与子依赖的 package.json 中 dependencies 的依赖项相同 dependencies ：结构和外层的 dependencies 结构相同，存储安装在子依赖 node_modules 中的依赖包 需要注意的是，并不是所有的子依赖都有 dependencies 属性，只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，才会有这个属性。 package-lock.json 文件的作用 在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树； node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。 由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。 在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。 依赖的区别与使用场景npm 目前支持以下几类依赖包管理包括 dependencies devDependencies optionalDependencies 可选择的依赖包 peerDependencies 同等依赖 bundledDependencies 捆绑依赖包 下面我们来看一下这几种依赖的区别以及各自的应用场景： dependenciesdependencies 是无论在开发环境还是在生产环境都必须使用的依赖，是我们最常用的依赖包管理对象，例如 React，Loadsh，Axios 等，通过 npm install XXX 下载的包都会默认安装在 dependencies 对象中，也可以使用 npm install XXX –save 下载 dependencies 中的包； devDependenciesdevDependencies 是指可以在开发环境使用的依赖，例如 eslint，debug 等，通过 npm install packageName –save-dev 下载的包都会在 devDependencies 对象中； dependencies 和 devDependencies 最大的区别是在打包运行时，执行 npm install 时默认会把所有依赖全部安装，但是如果使用 npm install --production 时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。 optionalDependenciesoptionalDependencies 指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中，但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。 optionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。 12345678910try &#123; var axios = require('axios') var fooVersion = require('axios/package.json').version&#125; catch (er) &#123; foo = null&#125;// .. then later in your program ..if (foo) &#123; foo.doFooThings()&#125; peerDependenciespeerDependencies 用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子🌰：我们常用的 react 组件库 ant-design@3.x 的 package.json 中的配置如下： 1234\"peerDependencies\": &#123; \"react\": \"&gt;=16.9.0\", \"react-dom\": \"&gt;=16.9.0\" &#125;, 假设我们创建了一个名为 project 的项目，在此项目中我们要使用 ant-design@3.x 这个插件，此时我们的项目就必须先安装 React &gt;= 16.9.0 和 React-dom &gt;= 16.9.0 的版本。​ 在 npm 2 中，当我们下载 ant-design@3.x 时，peerDependencies 中指定的依赖会随着 ant-design@3.x 一起被强制安装，所以我们不需要在宿主项目的 package.json 文件中指定 peerDependencies 中的依赖，但是在 npm 3 中，不会再强制安装 peerDependencies 中所指定的包，而是通过警告的方式来提示我们，此时就需要手动在 package.json 文件中手动添加依赖； bundledDependencies这个依赖项也可以记为 bundleDependencies，与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如： 12345678&#123; \"name\": \"project\", \"version\": \"1.0.0\", \"bundleDependencies\": [ \"axios\", \"lodash\" ]&#125; 当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 npm install project-1.0.0.tgz 下载包时，Axios 和 Lodash 这两个依赖也会被安装。需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。 12345678\"bundleDependencies\": [ \"axios\", \"lodash\"],\"dependencies\": &#123; \"axios\": \"*\", \"lodash\": \"*\"&#125; 如果我们使用常规的 npm publish 来发布的话，这个属性是不会生效的，所以日常情况中使用的较少。 总结本文介绍的是 npm 2，npm 3，package-lock.json 以及几种依赖的区别和使用场景，希望能够让大家对 npm 的了解更加多一点，有什么不清楚的地方或者不足之处欢迎大家在评论区留言。 原文转载自：https://www.zoo.team/article/npm-details","categories":[{"name":"npm","slug":"npm","permalink":"http://kobin.top/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://kobin.top/tags/npm/"}]},{"title":"在 React 中实现 keep alive","slug":"framework-react-keep-alive","date":"2020-09-15T23:25:43.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"framework-react-keep-alive/","link":"","permalink":"http://kobin.top/framework-react-keep-alive/","excerpt":"本文介绍一种在react中实现Vue的keep alive功能的方案。","text":"本文介绍一种在react中实现Vue的keep alive功能的方案。 什么是 keep alive在 Vue 中，我们可以使用 keep-alive 包裹一个动态组件，从而缓存不活跃的实例，而不是直接销毁他们： 123&lt;keep-alive&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这对于某些路由切换等场景非常好用，例如，如果我们需要实现一个列表页和详情页，但在用户从详情页返回列表的时候，我们不希望重新请求接口获取，也不希望重置列表的过滤、排序等条件，那这时就可以对列表页的组件用 keep-alive 包裹一下，这样，当路由切换时，Vue 会将这个组件“失活”并缓存起来，而不是直接卸载掉。 最简单的方案而在 React 中，其实一直以来都没有官方的 keep alive 解决方案，大部分开发者可能都会直接使用 display: none 来将 DOM 隐藏： 123&lt;div style=&#123;shouldHide ? &#123;display: 'none'&#125; : &#123;&#125;&#125;&gt; &lt;Foo/&gt;&lt;/div&gt; 但这种方案其实只是在“视觉上”将元素隐藏起来了，并没有真正的移除，那有没有可能把 DOM 树真的移除掉，同时又让组件不被销毁呢？ Portal实现 Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。 这是 React 官方文档上对 Portal 特性的介绍，值得注意的是，这里只是说“父组件以外的 DOM 节点”，但没有要求这个 DOM 节点是真的在页面上，还是只是存在于内存中。 因此，我们可以先通过 document.createElement 在内存中创建一个元素，然后再通过 React.createPoral 把 React 子节点渲染到这个元素上，这样就实现了“空渲染”。 12const targetElement = document.createElement('div')ReactDOM.createPortal(child, targetElement) 基于这种方案，我们可以进一步封装出一个 Conditional 组件，从而实现通用性的条件渲染逻辑： 12345678910111213141516171819export const Conditional = props =&gt; &#123; const [targetElement] = useState(() =&gt; document.createElement('div')) const containerRef = useRef() useLayoutEffect(() =&gt; &#123; if (props.active) &#123; containerRef.current.appendChild(targetElement) &#125; else &#123; try &#123; containerRef.current.removeChild(targetElement) &#125; catch (e) &#123;&#125; &#125; &#125;, [props.active]) return ( &lt;&gt; &lt;div ref=&#123;containerRef&#125; /&gt; &#123;ReactDOM.createPortal(props.children, targetElement)&#125; &lt;/&gt; )&#125; 首先，我们创建了一个 targetElement ，并且通过 createPortal 将 children 渲染到 targetElement 。 然后，我们会创建一个容器 div 元素，并且通过 containerRef 拿到它的引用。 最后，当 active 为 true 时，我们会把 targetElement 手动添加到 containerRef.current 的内部，反之，则会从其内部移除掉 targetElement 。 实际使用的方式如下： 123&lt;Conditional active=&#123;!shouldHide&#125;&gt; &lt;Foo/&gt;&lt;/Conditional&gt; 懒加载细心的读者可能会发现，目前我们的 Conditional 组件还有一点小小的瑕疵：当组件初次渲染时，不论当前的 active 是 true 还是 false ， Conditional 组件都会将 props.children 渲染。这对大型应用可能会带来非常明显的性能问题，所以，我们可以为其增加“懒加载”的特性： 1234567891011121314151617181920212223242526export const Conditional = props =&gt; &#123; const [targetElement] = useState(() =&gt; document.createElement('div')) const containerRef = useRef() // 增加一个 ref 记录组件是否“被激活过” const activatedRef = useRef(false) activatedRef.current = activatedRef.current || props.active useLayoutEffect(() =&gt; &#123; if (props.active) &#123; containerRef.current.appendChild(targetElement) &#125; else &#123; try &#123; containerRef.current.removeChild(targetElement) &#125; catch (e) &#123;&#125; &#125; &#125;, [props.active]) return ( &lt;&gt; &lt;div ref=&#123;containerRef&#125; /&gt; &#123;activatedRef.current &amp;&amp; ( // 如果“被激活过”，才渲染 children ReactDOM.createPortal(props.children, targetElement) )&#125; &lt;/&gt; )&#125; 一些遗憾不得不承认的是，基于 Portal 方案的 Conditional 组件并不能包治百病，和 Vue 的 keep-alive 相比，也存在不少缺憾： 需要手动控制 active ，不能直接基于子组件销毁/创建的生命周期事件 缺少失活/激活的生命周期时间，子组件无法感知自己是不是被缓存起来了 依赖了 ReactDOM ，对 SSR 不够友好 原文转载自知乎：在 React 中实现 keep alive","categories":[{"name":"react","slug":"react","permalink":"http://kobin.top/categories/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://kobin.top/tags/react/"},{"name":"keep alice","slug":"keep-alice","permalink":"http://kobin.top/tags/keep-alice/"}]},{"title":"前端如何学数据结构与算法 - 一篇讲完经典排序算法","slug":"algorithms-sort-knowledge","date":"2020-06-30T16:48:08.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"algorithms-sort-knowledge/","link":"","permalink":"http://kobin.top/algorithms-sort-knowledge/","excerpt":"本文基于JavaScript，实现常见的经典排序算法。","text":"本文基于JavaScript，实现常见的经典排序算法。 如何分析一个排序算法学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。 分析一个排序算法，要从 执行效率、内存消耗、稳定性 三方面入手。 执行效率 最好情况、最坏情况、平均情况时间复杂度 我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。 除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。 时间复杂度的系数、常数 、低阶 我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。 但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。 比较次数和交换（或移动）次数 这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。 所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。 内存消耗也就是看空间复杂度。 还需要知道如下术语： 内排序：所有排序操作都在内存中完成；外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；原地排序：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。 稳定性稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 前面；不稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序改变。 比如：a 原本在 b 前面，而 a = b，排序之后， a 在 b 后面； 十大经典排序算法1. 冒泡排序给定一个N个元素的数组，冒泡法排序将：如果元素大小关系不正确，交换这两个数（在本例中为a&gt; b），比较一对相邻元素（a，b），重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1。 思路 冒泡排序只会比较相邻的两个数据。 每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。 特点 优点：排序算法的基础，简单实用易于理解。 缺点：比较次数多，效率较低。 实现 1234567891011121314151617181920212223const bubbleSort = (array) =&gt; &#123; console.time(\"冒泡排序\"); for (let i = 0, len = array.length; i &lt; len - 1; i++) &#123; let hasSwap = false;// 提前退出冒泡循环的标志位 // j &lt; len - 1 - i 是因为内层的 len - 1 - i 到 length-1 的位置已经排好了，不需要再比较一次。 for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; const temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; hasSwap = true &#125; &#125; // 如果本次没有冒泡了，说明数组已经有序，提前退出 if (!hasSwap) break; &#125; console.log(\"排序后数组\", array); console.timeEnd(\"冒泡排序\") return array;&#125;const array = [9, 10, 7, 8, 4, 5, 6, 2, 3, 1];bubbleSort(array)","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数据结构与算法知识点汇总","slug":"algorithms-开篇","date":"2020-06-22T18:09:54.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"algorithms-开篇/","link":"","permalink":"http://kobin.top/algorithms-%E5%BC%80%E7%AF%87/","excerpt":"数据结构与算法知识点汇总","text":"","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"LeetCode题解记录","slug":"algorithms-leetcode","date":"2020-06-21T21:56:01.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"algorithms-leetcode/","link":"","permalink":"http://kobin.top/algorithms-leetcode/","excerpt":"汇集LeetCode题解思路，方便日后回忆","text":"leetCode题解记录 leetCode题解记录 数组类 常用方法总结： 两数之和 15. 三数之和 16. 最接近的三数之和 最大子序和 239. 滑动窗口最大值 合并两个有序数组 14. 最长公共前缀 链表类 常用方法总结： 合并两个有序链表 141. 环形链表 142. 环形链表 II 反转链表 19. 删除链表的倒数第N个节点 876. 链表的中间结点 动态规划类 309. 最佳买卖股票时机含冷冻期 面试题 17.13. 恢复空格 96. 不同的二叉搜索树 数组类常用方法总结： 结合Object(Map/set)等数据结构来解题； 滑动窗口方法（最小（大）子集等问题适用） Trie 树 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法一： 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123; let result = []; for(let i = 0, length = nums.length; i &lt; length; i++)&#123; const left = target - nums[i]; const leftIndex = nums.lastIndexOf(left); if(leftIndex &gt; i)&#123; result = [i ,leftIndex]; break; &#125; &#125; return result;&#125;; 复杂度分析： 时间复杂度：O(n2) 空间复杂度：o(1) 方法二： 1234567891011var twoSum = function(nums, target) &#123; let map = new Map() for(let i = 0; i&lt; nums.length; i++) &#123; let k = target-nums[i] if(map.has(k)) &#123; return [map.get(k), i] &#125; map.set(nums[i], i) &#125; return [];&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：o(n) 15. 三数之和解题思路： 首先对数组从大到小进行排序； 遍历数组，设置左右俩指针初始位置在数组左右边界（first = i + 1,last = length -1）; 如果i, first, last 三个数值大于0，则last左移，如果小于0，则first右移； 使得最终三数之和等于0，则成功找出一组。重复步骤2。 实现代码: 1234567891011121314151617181920212223242526var threeSum = function (nums) &#123; let res = []; let length = nums.length; nums.sort((a, b) =&gt; a - b); // 先排个队，最左边是最弱（小）的，最右边是最强(大)的 if (nums[0] &gt; 0 || nums[length - 1] &lt; 0) &#123; return res; &#125; for (let i = 0; i &lt; length - 2; i) &#123; if (nums[i] &gt; 0) break; let first = i + 1, last = length - 1, sum; while (first &lt; last) &#123; sum = nums[i] + nums[first] + nums[last]; if (sum === 0) &#123; res.push([nums[i], nums[first], nums[last]]); while (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125; &#125; else if (sum &lt; 0) &#123; while (first &lt; last &amp;&amp; nums[first] === nums[++first]) &#123; &#125; &#125; else &#123; while (first &lt; last &amp;&amp; nums[last] === nums[--last]) &#123; &#125; &#125; &#125; while (nums[i] === nums[++i]) &#123; &#125; &#125; return res;&#125;; 复杂度分析 时间复杂度： O(n2) 16. 最接近的三数之和解题思路 思路同上一题类似，不同点在于此题是求最接近给定值的解。 实现代码 123456789101112131415161718var threeSumClosest = function (nums, target) &#123; nums.sort((a, b) =&gt; a - b); let length = nums.length; let result = nums[0] + nums[1] + nums[length - 1]; for (let i = 0; i &lt; length - 2; i++) &#123; let first = i + 1; let last = length - 1; let sum; while (first &lt; last) &#123; sum = nums[i] + nums[first] + nums[last]; sum &gt; target ? last-- : first++; if (Math.abs(target - result) &gt; Math.abs(target - sum)) &#123; result = sum; &#125; &#125; &#125; return result;&#125;; 复杂度分析 时间复杂度： O(n2) 最大子序和算法： 在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（DP）在线性时间内解决。有两种标准 DP 方法适用于数组： 常数空间，沿数组移动并在原数组修改。 线性空间，首先沿 left-&gt;right 方向移动，然后再沿 right-&gt;left 方向移动。 合并结果。 我们在这里使用第一种方法，因为可以修改数组跟踪当前位置的最大和。下一步是在知道当前位置的最大和后更新全局最大和。 1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maxSubArray = function (nums) &#123; if (nums.length === 1) &#123; return nums[0]; &#125; let maxSum = nums[0]; for (let i = 1, length = nums.length; i &lt; length; i++) &#123; if (nums[i - 1] &gt; 0) nums[i] += nums[i - 1]; // index位上的值变为到这位为止的最大值 maxSum = Math.max(nums[i], maxSum); // 取当前位与历史位的最大值 &#125; return maxSum;&#125;; 复杂度分析: 时间复杂度：O(N)。只遍历了一次数组。 空间复杂度：O(1)，使用了常数的空间。 239. 滑动窗口最大值解题思路 使用 队列 方式维护一个滑动窗口内的数值索引，并确保队列队首值是当前滑动窗口的最大值索引 对应索引i来说，在i前面并且比i的值小的数值是没有价值的，可以剔除掉 实现代码 1234567891011121314151617181920var maxSlidingWindow = function (nums, k) &#123; //queue保存 SlidingWindow 数据，其中首位是最大值的索引 const queue = [], result = []; for (let i = 0; i &lt; nums.length; i++) &#123; //剔除SlidingWindow外的数据 if (i - queue[0] &gt;= k) &#123; queue.shift(); &#125; // 剔除queue元素，确保queue首位保存的是最大值的索引 while (nums[i] &gt; nums[queue[queue.length - 1]]) &#123; queue.pop() &#125; queue.push(i) //从k-1开始输出结果 if (i &gt;= k - 1) &#123; result.push(nums[queue[0]]) &#125; &#125; return result;&#125; 合并两个有序数组给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 思路分析：nums1 、 nums2 有序，若把 nums2 全部合并到 nums1 ，则合并后的 nums1 长度为 m+n我们可以从下标 m+n-1 的位置填充 nums1，循环比较 nums1[len1] 与 nums2[len2] 的大小，将最大值写入 nums1[len]。边界条件： 若 len1 &lt; 0， len2 &gt;= 0 ，此时 nums1 已重写入， nums2 还未合并完，只需将 nums2 的剩余元素写入 nums1 即可，写入后，合并完成； 若 len2 &lt; 0，此时 nums2 已全部合并到 nums1 ，合并完成。 实现代码： 123456789101112131415161718192021/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function (nums1, m, nums2, n) &#123; let len1 = m - 1, len2 = n - 1, len = m + n - 1; //若len2 &lt; 0,说明 nums2 已全部合并到 nums1 ，合并完成 while (len2 &gt;= 0) &#123; if (len1 &lt; 0) &#123; // 此时 nums1 已重写入， nums2 还未合并完，仅仅需要将 nums2 的剩余元素写入 nums1 即可 nums1[len--] = nums2[len2--]; continue; &#125; nums1[len--] = nums1[len1] &gt;= nums2[len2] ? nums1[len1--] : nums2[len2--] &#125;&#125;; 复杂度分析： 时间复杂度为 O(m+n) 空间复杂度为 O(1） 14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。示例 1: 12输入: [\"flower\",\"flow\",\"flight\"]输出: \"fl\" 示例 2: 123输入: [\"dog\",\"racecar\",\"car\"]输出: \"\"解释: 输入不存在公共前缀。 解题思路： 本题的解题方法很多，比如： 直接逐个比较; 寻找最大字符串与最小字符串，将问题化解为比较这两个字符串的大小（ace &gt; acd &gt; abc =&gt; 这三个字符串的最长公共前缀一定是ace与abc两者的最长公共前缀） 分治/归并策略： 将问题分解为每两个字符串的最长公共前缀，再归并为一，求得最后值。如下图： 利用Trie 树（字典树）Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。 下面以Trie树方式为例来实现，思路如下：构建一个 Trie 树，字符串数组的最长公共序列就为从根节点开始遍历树，直到： 遍历节点存在超过一个子节点的节点 或遍历节点为一个字符串的结束字符 为止，走过的字符为字符串数组的最长公共前缀。 如图，以[“flower”,”flow”,”flight”]为例，最终结果为&quot;fl&quot; 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var longestCommonPrefix = function (strs) &#123; if (strs === null || strs.length === 0) return \"\"; // 初始化 Trie 树 let trie = new Trie() // 构建 Trie 树 for (let i = 0; i &lt; strs.length; i++) &#123; if (!trie.insert(strs[i])) return \"\" &#125; // 返回最长公共前缀 return trie.searchLongestPrefix()&#125;;var TrieNode = function () &#123; // next 放入当前节点的子节点 this.next = &#123;&#125;; // 当前是否是结束节点 this.isEnd = false;&#125;;// Trie 树var Trie = function () &#123; this.root = new TrieNode()&#125;;Trie.prototype.insert = function (word) &#123; if (!word) return false let node = this.root for (let i = 0; i &lt; word.length; i++) &#123; if (!node.next[word[i]]) &#123; node.next[word[i]] = new TrieNode() &#125; node = node.next[word[i]] &#125; node.isEnd = true return true&#125;;Trie.prototype.searchLongestPrefix = function () &#123; let node = this.root let prevs = '' while (node.next) &#123; let keys = Object.keys(node.next) if (keys.length !== 1) break; //超过一个子节点的节点 if (node.next[keys[0]].isEnd) &#123; //节点为一个字符串的结束字符 prevs += keys[0] break &#125; prevs += keys[0] node = node.next[keys[0]] &#125; return prevs&#125;const res = longestCommonPrefix([\"flower\", \"flow\", \"flight\"])console.log(res); 链表类常用方法总结： 快慢指针 标记位法 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路从链表头开始比较，l1 与 l2 是有序递增的，所以比较 l1.val 与 l2.val 的较小值就是合并后链表的最小值，次小值就是小节点的 next.val 与大节点的 val 比较的较小值，依次递归，直到递归到 l1 l2 均为 null 确定边界条件： 当递归到任意链表为 null ，直接将 next 指向另外的链表即可，不需要继续递归了 代码实现： 123456789101112131415function mergeTwoLists(l1, l2) &#123; if(l1 === null) &#123; return l2 &#125; if(l2 === null) &#123; return l1 &#125; if(l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2) return l1 &#125; else &#123; l2.next = mergeTwoLists(l2.next, l1) return l2 &#125;&#125; 141. 环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 方法一：标志法给每个已遍历过的节点加标志位，遍历链表，当出现下一个节点已被标志时，则证明单链表有环 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; while(head)&#123; if(head.flag)&#123; return true; &#125; head.flag = 1; head = head.next; &#125; return false&#125;; 方法二： 快慢指针法设置快慢两个指针，遍历单链表，快指针一次走两步，慢指针一次走一步，如果单链表中存在环，则快慢指针终会指向同一个节点，否则直到快指针指向 null 时，快慢指针都不可能相遇。 1234567891011121314var hasCycle = function(head) &#123; if(!head || !head.next) &#123; return false &#125; let fast = head.next.next, slow = head.next; while(fast &amp;&amp; fast.next)&#123; // fast.next为null说明fast是链表终点，无环 if(fast === slow )&#123; return true &#125; fast = fast.next.next; slow = slow.next; &#125; return false;&#125;; 方法三： 利用 JSON.stringify() 不能序列化含有循环引用的结构 123456789var hasCycle = function(head) &#123; try&#123; JSON.stringify(head); return false; &#125; catch(err)&#123; return true; &#125;&#125;; 142. 环形链表 II给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 解题思路： 本题与上一题类似，增加的难度在于需要返回入环点。所以无法基于JSON.stringify()来实现了。方法一： 标志法此方法实现代码与上一题基本一样，只是返回值有所区别。 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var detectCycle = function (head) &#123; while(head)&#123; if(head.flag)&#123; return head; &#125; head.flag = 1; head = head.next; &#125; return null;&#125;; 方法二： 快慢指针法 上一题中快慢指针相遇点（即fast === slow）肯定是环内某一点（注意不一定是入环点，所以本题不能直接返回这个节点）。 所以接下去主要工作是如何判断入环点？ 基于上一题，我们设置fast指针速度是2，slow指针速度是1, fast速度是slow速度的2倍，所以最终相遇（fast === slow）时，fast走的距离也是slow走的距离的2倍。具体分析如下： 123456A - 起点B - 第一次相遇点X - 入环点d1 - A-X距离d2 - X-B距离d3 - B-X距离 最后得出d1 = d3。那么就可以在上题基础上进行寻找入环点： 当fast和slow在B点相遇后，将fast重回A点。将两个指针均以速度1向前走，最终会在X点相遇（距离一样，速度一样，所以到X点的时间也一样），相遇时返回节点即可。 实现代码： 12345678910111213141516171819var detectCycle = function (head) &#123; if(!head || !head.next) &#123; return null &#125; let fast = head.next.next, slow = head.next; while(fast &amp;&amp; fast.next)&#123;//fast.next为null说明fast是链表终点，无环 if(fast === slow )&#123; fast = head; while(fast !== slow)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125; fast = fast.next.next; slow = slow.next; &#125; return null;&#125;; 反转链表解题思路： 定义一个反转链表prev, 循环head指针，将当前head指向prev，实现反转效果。 123456789101112131415161718192021222324/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123; let prev = null; while(head)&#123; //临时存放下一个指针 let next = head.next; //将当前节点指向prev，实现反转效果 head.next = prev; // 变更prev、head prev = head; head = next; &#125; return prev;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1) 19. 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 解题思路：需要删除链表中的倒数第 n 个节点，我们需要知道的就是倒数第 n+1 个节点，然后删除删除倒数第 n+1 节点的后继节点即可. 使用快慢指针思想来解决此问题： 12345678910111213141516var removeNthFromEnd = function(head, n) &#123; let fast = head, slow = head // 快先走 n - 1 步 while(--n) &#123; fast = fast.next &#125; if(!fast.next) return head.next;//说明列表长度为n,删除头结点 fast = fast.next // fast、slow 一起前进 while(fast &amp;&amp; fast.next) &#123; fast = fast.next slow = slow.next &#125; slow.next = slow.next.next return head&#125;; 876. 链表的中间结点解题思路：使用快慢指针方法： 快指针速度2，慢指针速度1，当快指针到达终点时，慢指针刚好在中间节点。 12345678var middleNode = function(head) &#123; let fast = head, slow = head; while(fast &amp;&amp; fast.next)&#123; fast = fast.next.next; slow = slow.next; &#125; return slow;&#125;; 复杂度分析： 时间复杂度：O(n) 空间复杂度：O(1) 动态规划类309. 最佳买卖股票时机含冷冻期分析： 第i天主要有三种情况，当天收益取三者最大值： 当天持有此股票，那么股票可能是：a. 前一天就持有的, 取值(dp[i - 1][0])，b. 或者当天刚买的,取值(dp[i - 1][2] - prices[i]))，这种情况的最大收益为： Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]); 当天卖出股票，则收益为前一天的持有收益 + 当天的股票价格收益， 即： dp[i - 1][0] + prices[i]; 当天未持有，并且当天未卖出过，则有两种情况：a. 前一天卖出过，dp[i-1][1]b. 前一天未卖出， dp[i-1][2]。这种情况的最大收益为： Math.max(dp[i - 1][1], dp[i - 1][2]); 第一天的初始值：dp[0] = [-prices[0], 0, 0]; 代码实现： 1234567891011121314151617181920/* * 最终的收益是当天的三种情况取最大 * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function (prices) &#123; const len = prices.length; if (len &lt; 2) return 0 const dp = []; dp.push([-prices[0], 0, 0]); let t0, t1, t2; for (let i = 1; i &lt; len; i++) &#123; t0 = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]); // 当天持有此股票 t1 = dp[i - 1][0] + prices[i]; // 当天未持有，并且当天卖出 t2 = Math.max(dp[i - 1][1], dp[i - 1][2]); //当天未持有，并且不是当天卖出 dp.push([t0, t1, t2]); &#125; return Math.max(...dp.pop())&#125;; 面试题 17.13. 恢复空格分析： 遍历 sentence，如果i-1结尾的子字符串 等于 dictionary的某个word, 说明dp[i] 可以等于 dp[i - word.length]； 代码实现： 12345678910111213141516171819202122/** * @param &#123;Array&#125; dictionary * @param &#123;String&#125; sentence * @return &#123;number&#125; */const respace = (dictionary, sentence) =&gt; &#123; const len = sentence.length; if (len === 0) return 0; const dp = new Array(len + 1); dp[0] = 0; for (let i = 1; i &lt;= len; i++) &#123; //i代表 Length(sentence) dp[i] = dp[i - 1] + 1; for (const word of dictionary) &#123; if (word === sentence.substring(i - word.length, i)) &#123; dp[i] = Math.min(dp[i], dp[i - word.length]) &#125; &#125; &#125; return dp[len]&#125;; 96. 不同的二叉搜索树 思路:标签：动态规划假设n个节点存在二叉排序树的个数是dp(n)，令f(i)为以i为根的二叉搜索树的个数，则dp(n) = f(1) + f(2) + f(3) + f(4) + … + f(n) 当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则f(i) = dp(i-1)*dp(n-i) 综合两个公式可以得到 卡特兰数 公式dp(n) = dp(0)dp(n-1)+dp(1)(n-2)+…+dp(n-1)*dp(0) 代码实现： 1234567891011var numTrees = function (n) &#123; const dp = new Array(n + 1).fill(0); dp[0] = 1; dp[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; for (let j = 1; j &lt;= i; j++) &#123; //以j为顶点的个数计算 dp[i] += dp[j - 1] * dp[i - j]; &#125; &#125; return dp[n];&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://kobin.top/tags/LeetCode/"}]},{"title":"从Chrome源码看JS Array的底层实现","slug":"Chrome源码-array-knowledge","date":"2020-06-17T22:41:59.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"Chrome源码-array-knowledge/","link":"","permalink":"http://kobin.top/Chrome%E6%BA%90%E7%A0%81-array-knowledge/","excerpt":"作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。 知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。","text":"作为前端er，我们都知道，JS 的数组可以存放不同类型的元素、并且数组长度是可变的。不像其他的语言，比如C，创建的时候要决定数组的大小，如果数组满了，就要重新申请内存空间。 知道归知道，但是要想弄清楚其中原因，就得从Chrome源码去探究了。 JS Array为什么可以保存不同类型先看下Chrome V8对JSArray的定义： 123456789101112131415// The JSArray describes JavaScript Arrays// Such an array can be in one of two modes:// - fast, backing storage is a FixedArray and length &lt;= elements.length();// Please note: push and pop can be used to grow and shrink the array.// - slow, backing storage is a HashTable with numbers as keys.class JSArray: public JSObject &#123; public: // [length]: The length property. DECL_ACCESSORS(length, Object) // ... // Number of element slots to pre-allocate for an empty array. static const int kPreallocatedArrayElements = 4;&#125;; 我们可以看到 JSArray 是继承自 JSObject 的，所以在 JavaScript 中，数组可以是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。 JS Array如何存储从上述 V8 源码注释中可以看出，JSArray有两种存储方式： fast：存储结构是 FixedArray ，并且数组长度 &lt;= elements.length() ，push 或 pop 时可能会伴随着动态扩容或减容，源码里叫 FastElements; slow：存储结构是 HashTable，并且数组下标作为 key,源码里叫 SlowElements; 快数组（FastElements）FixedArray 是 V8 实现的一个类似于数组的类，它表示一段连续的内存，可以使用索引直接定位。新创建的空数组默认就是快数组。当数组满（数组的长度达到数组在内存中申请的内存容量最大值）的时候，继续 push 时， JSArray 会进行动态的扩容，以存储更多的元素。 慢数组（SlowElements）慢数组以哈希表的形式存储在内存空间里，它不需要开辟连续的存储空间,节省了内存，但需要额外维护一个哈希表，性能相对较差。 什么时候会从 fast 转变为 slow 123456789101112131415161718192021222324252627282930313233343536373839404142434445// src/objects/js-objects.hstatic const uint32_t kMaxGap = 1024;// src/objects/dictionary.h// JSObjects prefer dictionary elements if the dictionary saves this much// memory compared to a fast elements backing store.static const uint32_t kPreferFastElementsSizeFactor = 3;// src/objects/js-objects-inl.h// If the fast-case backing storage takes up much more memory than a dictionary// backing storage would, the object should have slow elements.// staticstatic inline bool ShouldConvertToSlowElements(uint32_t used_elements, uint32_t new_capacity) &#123; uint32_t size_threshold = NumberDictionary::kPreferFastElementsSizeFactor * NumberDictionary::ComputeCapacity(used_elements) * NumberDictionary::kEntrySize; // 快数组新容量是扩容后的容量3倍之多时，也会被转成慢数组 return size_threshold &lt;= new_capacity;&#125;static inline bool ShouldConvertToSlowElements(JSObject object, uint32_t capacity, uint32_t index, uint32_t* new_capacity) &#123; STATIC_ASSERT(JSObject::kMaxUncheckedOldFastElementsLength &lt;= JSObject::kMaxUncheckedFastElementsLength); if (index &lt; capacity) &#123; *new_capacity = capacity; return false; &#125; // 当加入的索引值（例如例3中的2000）比当前容量capacity 大于等于 1024时， // 返回true，转为慢数组 if (index - capacity &gt;= JSObject::kMaxGap) return true; *new_capacity = JSObject::NewElementsCapacity(index + 1); DCHECK_LT(index, *new_capacity); // TODO(ulan): Check if it works with young large objects. if (*new_capacity &lt;= JSObject::kMaxUncheckedOldFastElementsLength || (*new_capacity &lt;= JSObject::kMaxUncheckedFastElementsLength &amp;&amp; ObjectInYoungGeneration(object))) &#123; return false; &#125; return ShouldConvertToSlowElements(object.GetFastElementsUsage(), *new_capacity);&#125; 从上述源码看出，当处于以下情况时，快数组会被转变为慢数组： 当加入的索引值 index 比当前容量 capacity 差值大于等于 1024 时（index - capacity &gt;= 1024） 快数组新容量是扩容后的容量 3 倍之多时 增加一个2000的索引时，array就会被转成慢数组: 12var array = [1, 2, 3]array[2000] = 1000; 什么时候会从 slow 转变为 fast 123456789101112131415161718192021222324static bool ShouldConvertToFastElements(JSObject object, NumberDictionary dictionary, uint32_t index, uint32_t* new_capacity) &#123; // If properties with non-standard attributes or accessors were added, we // cannot go back to fast elements. if (dictionary.requires_slow_elements()) return false; // Adding a property with this index will require slow elements. if (index &gt;= static_cast&lt;uint32_t&gt;(Smi::kMaxValue)) return false; if (object.IsJSArray()) &#123; Object length = JSArray::cast(object).length(); if (!length.IsSmi()) return false; *new_capacity = static_cast&lt;uint32_t&gt;(Smi::ToInt(length)); &#125; else if (object.IsJSArgumentsObject()) &#123; return false; &#125; else &#123; *new_capacity = dictionary.max_number_key() + 1; &#125; *new_capacity = Max(index + 1, *new_capacity); uint32_t dictionary_size = static_cast&lt;uint32_t&gt;(dictionary.Capacity()) * NumberDictionary::kEntrySize; // Turn fast if the dictionary only saves 50% space. return 2 * dictionary_size &gt;= *new_capacity;&#125; 当慢数组的元素可存放在快数组中且长度在 smi 之间且仅节省了50%的空间(用慢数组节省的空间不大于50%),则会转变为快数组 smi在64位平台为-231 到 231 -1，在32位平台为-230 到 230 -1 12345let a = [1,2];a[1030] = 1;for (let i = 200; i &lt; 1030; i++) &#123; a[i] = i;&#125; 在 1030 的位置上面添加一个值，会造成多于 1024 个空洞，数组变成慢数组；然后往这个数组中 200-1029 这些位置上赋值，使慢数组不再比快数组节省 50% 的空间，则数组变成快数组。 总结 快数组就是以空间换时间的方式，申请了大块连续内存，提高效率。 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。 数组的动态扩容与减容默认空数组初始化大小为 4 : 12// Number of element slots to pre-allocate for an empty array.static const int kPreallocatedArrayElements = 4; 在 Chrome 源码中， push 的操作是用汇编实现的，在 c++ 里嵌入的汇编，以提高执行效率，并且在汇编的基础上用 c++ 封装了一层，在编译执行的时候，会将这些 c++ 代码转成汇编代码。 计算新容量的函数： 12345678910111213// js-objects.hstatic const uint32_t kMinAddedElementsCapacity = 16;// code-stub-assembler.ccNode* CodeStubAssembler::CalculateNewElementsCapacity(Node* old_capacity, ParameterMode mode) &#123; CSA_SLOW_ASSERT(this, MatchesParameterMode(old_capacity, mode)); Node* half_old_capacity = WordOrSmiShr(old_capacity, 1, mode); Node* new_capacity = IntPtrOrSmiAdd(half_old_capacity, old_capacity, mode); Node* padding = IntPtrOrSmiConstant(JSObject::kMinAddedElementsCapacity, mode); return IntPtrOrSmiAdd(new_capacity, padding, mode);&#125; 所以扩容后新容量计公式为： 1new_capacity = old_capacity /2 + old_capacity + 16 即老的容量的 1.5 倍加上 16 。初始化为 4 个，当 push 第 5 个的时候，容量将会变成： 1new_capacity = 4 / 2 + 4 + 16 = 22 接着申请一块这么大的内存，把老的数据拷过去，把新元素放在当前 length 位置，然后将数组的 length + 1，并返回 length。 整个过程，用户是无感知的，不像 C，需用用户手动申请内存空间。 当数组执行 pop 操作时，会判断 pop 后数组的容量，是否需要进行减容。 不同于数组的 push 使用汇编实现的， pop 使用 c++ 实现的。 判断是否进行减容： 1234567if (2 * length &lt;= capacity) &#123; // If more than half the elements won't be used, trim the array. isolate-&gt;heap()-&gt;RightTrimFixedArray(*backing_store, capacity - length);&#125; else &#123; // Otherwise, fill the unused tail with holes. BackingStore::cast(*backing_store)-&gt;FillWithHoles(length, old_length);&#125; 所以，当数组 pop 后，如果数组容量大于等于 length 的 2 倍，则进行容量调整，使用 RightTrimFixedArray 函数，计算出需要释放的空间大小，做好标记，等待 GC 回收；如果数组容量小于 length 的 2 倍，则用 holes 对象填充。 总结JavaScript 中， JSArray 继承自 JSObject ，是一个特殊的对象，内部是以 key-value 形式存储数据，所以 JavaScript 中的数组可以存放不同类型的值。 JSArray有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当快数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。 当数组中 hole 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。 一道面试题 - 数组扁平化假如有个数组： 1var arr = [ [1, 2, 2], [3, 4, [5, 5]], 10] 如何将其扁平化为： 1[1, 2, 2, 3, 4, 5, 5, 10] 核心思想： 遍历数组arr，若arr[i]为数组则递归遍历，直至arr[i]不为数组然后与之前的结果concat。 ES6 flat 1arr.flat(Infinity) reduce 12345function flatten(arr) &#123; return arr.reduce((result, item)=&gt; &#123; return result.concat(Array.isArray(item) ? flatten(item) : item); &#125;, []);&#125; toString / join 12345function flatten(arr) &#123; return arr.toString().split(',').map(function(item) &#123; return Number(item); &#125;)&#125; 递归 1234567891011function flatten(arr) &#123; var res = []; arr.map(item =&gt; &#123; if(Array.isArray(item)) &#123; res = res.concat(flatten(item)); &#125; else &#123; res.push(item); &#125; &#125;); return res;&#125; 扩展运算符 es6的扩展运算符能将二维数组变为一维 123456function flatten(arr) &#123; while(arr.some(item=&gt;Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 参考链接：前端进阶算法2：从Chrome V8源码看JavaScript数组","categories":[{"name":"Chrome源码","slug":"Chrome源码","permalink":"http://kobin.top/categories/Chrome%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"array","slug":"array","permalink":"http://kobin.top/tags/array/"}]},{"title":"常用系统命令汇总","slug":"others-常用系统命令汇总","date":"2020-06-12T18:50:05.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"others-常用系统命令汇总/","link":"","permalink":"http://kobin.top/others-%E5%B8%B8%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/","excerpt":"各个系统常用终端命令汇总之地","text":"端口检查 linux 1telnet 192.168.1.102 3306 mac 1nc -vz -w 2 192.168.1.104 3306 查看端口占用 Centos7+ 1234567891011lsof -i tcp:80 # 查看80端口占用情况netstat -ntlp # 列出所有端口firewall-cmd --query-port=3306/tcp # 查询是否开启3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanent # 开启端口firewall-cmd --zone=public --remove-port=3306/tcp --permanent # 关闭端口firewall-cmd --reload #重启防火墙 杀掉进程 Centos 123netstat -tpnul # 查看当前所有正在运行的进程ps aux |grep httpd # 查看 httpd 进程kill -9 6732 # 6732为httpd进程对应的进程ID","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"命令","slug":"命令","permalink":"http://kobin.top/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"Vulter + v2ray / Trojan 使用教程","slug":"others-v2ray-manual","date":"2020-06-11T18:25:33.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"others-v2ray-manual/","link":"","permalink":"http://kobin.top/others-v2ray-manual/","excerpt":"最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。","text":"最近一直在使用的梯子服务临近到期，想要续费发现价格又涨了一波，再加上平时使用中并不是很稳定。就萌生了自建一个梯子的想法。 前言要想自建梯子有两个前提： 境外VPS服务器(虚拟专用服务器) 科学上网工具 VPS服务器对比了阿里云国际版、谷歌云、AWS等巨头产品，以及VULTR、搬瓦工等服务商，最终选择了VULTR，主要原因在于： 价格便宜： 最便宜的有$2.5/月的服务，价格是王道； 机房众多：拥有日本、美国、欧洲等 17 个机房； 架构优秀：全部采用 KVM 架构、SSD 固态硬盘、500G/月流量起步； 后台强大 ：拥有系统快照、一键装机部署脚本、备份、防火墙等强大功能，从 VPS 这点丝毫不输给阿里云。 计费灵活 : 采用小时计费模式，可以任意的添加和删除机器 , 并且是单向流量收费 , 也就是只计算下载的的流量; 支持支付宝/微信支付，国内用户购买方便； 注册购买请进入官网自行操作：vultr官网 科学上网工具本文主要实现v2ray 和 Trojan 两个工具的搭建 SSH免密登录vultr服务器 在本机生成密钥（如果已经有了不用重复生成）： 1ssh-keygen -t rsa 将本地公钥拷贝到服务器的~/.ssh/authorized_keys目录中： 12345678910111213# 方法一ssh-copy-id user@ip# 法二# 将 本机 ~/.ssh目录中的 id_rsa.pub 这个文件拷贝到服务器 的~/.ssh目录中scp ~/.ssh/id_rsa.pub user@ip:~/.ssh/# 在服务器运行以下命令来将公钥导入到~/.ssh/authorized_keys这个文件中cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys# authorized_keys的权限要是600。chmod 600 .ssh/authorized_keys user: 服务器用户名，默认为rootip: 服务器公网IP 至此，就可以用下面命令免密登录了： 1ssh user@ip v2ray安装与配置登录了云服务后，就可以开始下载安装v2ray了，执行以下命令： 12345wget https://install.direct/go.shchmod +x go.sh./go.sh 执行成功后，会输出 V2Ray v4.24.2 is installed. 等字样。 安装V2Ray后， 会在/etc/v2ray/config.json默认生成配置文件，我们需要编辑这个文件： 1vi /etc/v2ray/config.json 然后连续按 d 键，将原本的文件内容清空，然后按 i 键开启编辑模式，复制以下配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; \"log\": &#123; \"access\": \"/var/log/v2ray/access.log\", \"error\": \"/var/log/v2ray/error.log\", \"loglevel\": \"warning\" &#125;, \"inbound\": &#123; \"port\": 9751, \"protocol\": \"vmess\", \"settings\": &#123; \"clients\": [ &#123; \"id\": \"392029fa-a9e0-42e3-93cb-97a9288795ed\", \"level\": 1, \"alterId\": 100 &#125; ] &#125;, \"streamSettings\": &#123; \"network\": \"tcp\" &#125;, \"detour\": &#123; \"to\": \"vmess-detour-118345\" &#125; &#125;, \"outbound\": &#123; \"protocol\": \"freedom\", \"settings\": &#123;&#125; &#125;, \"inboundDetour\": [ &#123; \"protocol\": \"vmess\", \"port\": \"10000-10010\", \"tag\": \"vmess-detour-118345\", \"settings\": &#123;&#125;, \"allocate\": &#123; \"strategy\": \"random\", \"concurrency\": 5, \"refresh\": 5 &#125;, \"streamSettings\": &#123; \"network\": \"kcp\" &#125; &#125; ], \"outboundDetour\": [ &#123; \"protocol\": \"blackhole\", \"settings\": &#123;&#125;, \"tag\": \"blocked\" &#125; ], \"routing\": &#123; \"strategy\": \"rules\", \"settings\": &#123; \"rules\": [ &#123; \"type\": \"field\", \"ip\": [ \"0.0.0.0/8\", \"10.0.0.0/8\", \"100.64.0.0/10\", \"127.0.0.0/8\", \"169.254.0.0/16\", \"172.16.0.0/12\", \"192.0.0.0/24\", \"192.0.2.0/24\", \"192.168.0.0/16\", \"198.18.0.0/15\", \"198.51.100.0/24\", \"203.0.113.0/24\", \"::1/128\", \"fc00::/7\", \"fe80::/10\" ], \"outboundTag\": \"blocked\" &#125; ] &#125; &#125;&#125; 上述配置中可根据自己的喜好进行相应修改，也可直接使用不做修改。 保存并退出编辑模式，再启动v2ray服务，服务端的配置就完成了。 1systemctl start v2ray v2ray进程管理命令： 1234567891011# 查看 v2ray 进程状态systemctl status v2ray# 启动systemctl start v2ray# 重启systemctl restart v2ray# 关闭systemctl stop v2ray 配置防火墙CentOS 7 系统默认会开启防火墙，需要开放上面配置的端口： 123firewall-cmd --permanent --add-service=https# 或者firewall-cmd --zone=public --add-port=9751/tcp --permanent – zone #作用域 – add-port=80/tcp #添加端口，格式为：端口/通讯协议 – permanent #永久生效，没有此参数重启后失效 防火墙其他相关命令： 12345678systemctl status firewalld # 查看防火墙状态firewall-cmd --reload #重启firewallsystemctl restart firewalld # 重启2systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）firewall-cmd --list-ports # 查看已经开放的端口 至此，服务端部分就算完成了。下面开始客户端配置。 V2Ray 客户端 Mac端 Mac端使用的是ClashX客户端。安装下载后打开配置文件夹： 新建一个.yaml配置文件，具体配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481port: 7890socks-port: 7891redir-port: 7892allow-lan: falsemode: Rulelog-level: infoexternal-controller: 127.0.0.1:9090secret: \"\"cfw-bypass: - localhost - 127.* - 10.* - 172.16.* - 172.17.* - 172.18.* - 172.19.* - 172.20.* - 172.21.* - 172.22.* - 172.23.* - 172.24.* - 172.25.* - 172.26.* - 172.27.* - 172.28.* - 172.29.* - 172.30.* - 172.31.* - 192.168.* - &lt;local&gt;cfw-latency-timeout: 3000Proxy: - name: V2-NewJersey type: vmess server: 208.167.222.200 # 服务器公网IP port: \"9751\" # v2ray配置的端口 uuid: 392029fa-a9e0-42e3-93cb-97a9288795ed # v2ray的uuid alterId: \"100\" # v2ray的额外ID cipher: auto network: tcp # 传输协议Proxy Group: - name: CroLAX type: select proxies: - V2-NewJerseyRule: - DOMAIN,hls.itunes.apple.com,CroLAX - DOMAIN,itunes.apple.com,CroLAX - DOMAIN,itunes.com,CroLAX - DOMAIN-SUFFIX,icloud.com,DIRECT - DOMAIN-SUFFIX,icloud-content.com,DIRECT - DOMAIN-SUFFIX,me.com,DIRECT - DOMAIN-SUFFIX,mzstatic.com,DIRECT - DOMAIN-SUFFIX,akadns.net,DIRECT - DOMAIN-SUFFIX,aaplimg.com,DIRECT - DOMAIN-SUFFIX,cdn-apple.com,DIRECT - DOMAIN-SUFFIX,apple.com,DIRECT ## 国内网站 - DOMAIN-SUFFIX,cn,DIRECT - DOMAIN-KEYWORD,-cn,DIRECT - DOMAIN-SUFFIX,126.com,DIRECT - DOMAIN-SUFFIX,126.net,DIRECT - DOMAIN-SUFFIX,127.net,DIRECT - DOMAIN-SUFFIX,163.com,DIRECT - DOMAIN-SUFFIX,360buyimg.com,DIRECT - DOMAIN-SUFFIX,36kr.com,DIRECT - DOMAIN-SUFFIX,acfun.tv,DIRECT - DOMAIN-SUFFIX,air-matters.com,DIRECT - DOMAIN-SUFFIX,aixifan.com,DIRECT - DOMAIN-SUFFIX,akamaized.net,DIRECT - DOMAIN-KEYWORD,alicdn,DIRECT - DOMAIN-KEYWORD,alipay,DIRECT - DOMAIN-KEYWORD,taobao,DIRECT - DOMAIN-SUFFIX,amap.com,DIRECT - DOMAIN-SUFFIX,autonavi.com,DIRECT - DOMAIN-KEYWORD,baidu,DIRECT - DOMAIN-SUFFIX,bdimg.com,DIRECT - DOMAIN-SUFFIX,bdstatic.com,DIRECT - DOMAIN-SUFFIX,bilibili.com,DIRECT - DOMAIN-SUFFIX,caiyunapp.com,DIRECT - DOMAIN-SUFFIX,clouddn.com,DIRECT - DOMAIN-SUFFIX,cnbeta.com,DIRECT - DOMAIN-SUFFIX,cnbetacdn.com,DIRECT - DOMAIN-SUFFIX,cootekservice.com,DIRECT - DOMAIN-SUFFIX,csdn.net,DIRECT - DOMAIN-SUFFIX,ctrip.com,DIRECT - DOMAIN-SUFFIX,dgtle.com,DIRECT - DOMAIN-SUFFIX,dianping.com,DIRECT - DOMAIN-SUFFIX,douban.com,DIRECT - DOMAIN-SUFFIX,doubanio.com,DIRECT - DOMAIN-SUFFIX,duokan.com,DIRECT - DOMAIN-SUFFIX,easou.com,DIRECT - DOMAIN-SUFFIX,ele.me,DIRECT - DOMAIN-SUFFIX,feng.com,DIRECT - DOMAIN-SUFFIX,fir.im,DIRECT - DOMAIN-SUFFIX,frdic.com,DIRECT - DOMAIN-SUFFIX,g-cores.com,DIRECT - DOMAIN-SUFFIX,godic.net,DIRECT - DOMAIN-SUFFIX,gtimg.com,DIRECT - DOMAIN-SUFFIX,hongxiu.com,DIRECT - DOMAIN-SUFFIX,hxcdn.net,DIRECT - DOMAIN-SUFFIX,iciba.com,DIRECT - DOMAIN-SUFFIX,ifeng.com,DIRECT - DOMAIN-SUFFIX,ifengimg.com,DIRECT - DOMAIN-SUFFIX,ipip.net,DIRECT - DOMAIN-SUFFIX,iqiyi.com,DIRECT - DOMAIN-SUFFIX,jd.com,DIRECT - DOMAIN-SUFFIX,jianshu.com,DIRECT - DOMAIN-SUFFIX,knewone.com,DIRECT - DOMAIN-SUFFIX,le.com,DIRECT - DOMAIN-SUFFIX,lecloud.com,DIRECT - DOMAIN-SUFFIX,lemicp.com,DIRECT - DOMAIN-SUFFIX,licdn.com,DIRECT - DOMAIN-SUFFIX,linkedin.com,DIRECT - DOMAIN-SUFFIX,luoo.net,DIRECT - DOMAIN-SUFFIX,meituan.com,DIRECT - DOMAIN-SUFFIX,meituan.net,DIRECT - DOMAIN-SUFFIX,mi.com,DIRECT - DOMAIN-SUFFIX,miaopai.com,DIRECT - DOMAIN-SUFFIX,microsoft.com,DIRECT - DOMAIN-SUFFIX,microsoftonline.com,DIRECT - DOMAIN-SUFFIX,miui.com,DIRECT - DOMAIN-SUFFIX,miwifi.com,DIRECT - DOMAIN-SUFFIX,mob.com,DIRECT - DOMAIN-SUFFIX,netease.com,DIRECT - DOMAIN-SUFFIX,office.com,DIRECT - DOMAIN-KEYWORD,officecdn,DIRECT - DOMAIN-SUFFIX,office365.com,DIRECT - DOMAIN-SUFFIX,oschina.net,DIRECT - DOMAIN-SUFFIX,ppsimg.com,DIRECT - DOMAIN-SUFFIX,pstatp.com,DIRECT - DOMAIN-SUFFIX,qcloud.com,DIRECT - DOMAIN-SUFFIX,qdaily.com,DIRECT - DOMAIN-SUFFIX,qdmm.com,DIRECT - DOMAIN-SUFFIX,qhimg.com,DIRECT - DOMAIN-SUFFIX,qhres.com,DIRECT - DOMAIN-SUFFIX,qidian.com,DIRECT - DOMAIN-SUFFIX,qihucdn.com,DIRECT - DOMAIN-SUFFIX,qiniu.com,DIRECT - DOMAIN-SUFFIX,qiniucdn.com,DIRECT - DOMAIN-SUFFIX,qiyipic.com,DIRECT - DOMAIN-SUFFIX,qq.com,DIRECT - DOMAIN-SUFFIX,qqurl.com,DIRECT - DOMAIN-SUFFIX,rarbg.to,DIRECT - DOMAIN-SUFFIX,ruguoapp.com,DIRECT - DOMAIN-SUFFIX,segmentfault.com,DIRECT - DOMAIN-SUFFIX,sinaapp.com,DIRECT - DOMAIN-SUFFIX,smzdm.com,DIRECT - DOMAIN-SUFFIX,sogou.com,DIRECT - DOMAIN-SUFFIX,sogoucdn.com,DIRECT - DOMAIN-SUFFIX,sohu.com,DIRECT - DOMAIN-SUFFIX,soku.com,DIRECT - DOMAIN-SUFFIX,speedtest.net,DIRECT - DOMAIN-SUFFIX,sspai.com,DIRECT - DOMAIN-SUFFIX,suning.com,DIRECT - DOMAIN-SUFFIX,taobao.com,DIRECT - DOMAIN-SUFFIX,tencent.com,DIRECT - DOMAIN-SUFFIX,tenpay.com,DIRECT - DOMAIN-SUFFIX,tianyancha.com,DIRECT - DOMAIN-SUFFIX,tmall.com,DIRECT - DOMAIN-SUFFIX,tudou.com,DIRECT - DOMAIN-SUFFIX,umetrip.com,DIRECT - DOMAIN-SUFFIX,upaiyun.com,DIRECT - DOMAIN-SUFFIX,upyun.com,DIRECT - DOMAIN-SUFFIX,v2ex.com,DIRECT - DOMAIN-SUFFIX,veryzhun.com,DIRECT - DOMAIN-SUFFIX,weather.com,DIRECT - DOMAIN-SUFFIX,weibo.com,DIRECT - DOMAIN-SUFFIX,xiami.com,DIRECT - DOMAIN-SUFFIX,xiami.net,DIRECT - DOMAIN-SUFFIX,xiaomicp.com,DIRECT - DOMAIN-SUFFIX,ximalaya.com,DIRECT - DOMAIN-SUFFIX,xmcdn.com,DIRECT - DOMAIN-SUFFIX,xunlei.com,DIRECT - DOMAIN-SUFFIX,yhd.com,DIRECT - DOMAIN-SUFFIX,yihaodianimg.com,DIRECT - DOMAIN-SUFFIX,yinxiang.com,DIRECT - DOMAIN-SUFFIX,ykimg.com,DIRECT - DOMAIN-SUFFIX,youdao.com,DIRECT - DOMAIN-SUFFIX,youku.com,DIRECT - DOMAIN-SUFFIX,zealer.com,DIRECT - DOMAIN-SUFFIX,zhihu.com,DIRECT - DOMAIN-SUFFIX,zhimg.com,DIRECT - DOMAIN-SUFFIX,zimuzu.tv,DIRECT - DOMAIN-KEYWORD,netflix,CroLAX - DOMAIN-KEYWORD,nflx,CroLAX ## 抗 DNS 污染 - DOMAIN-KEYWORD,amazon,CroLAX - DOMAIN-KEYWORD,google,CroLAX - DOMAIN-KEYWORD,gmail,CroLAX - DOMAIN-KEYWORD,youtube,CroLAX - DOMAIN-KEYWORD,facebook,CroLAX - DOMAIN-SUFFIX,fb.me,CroLAX - DOMAIN-SUFFIX,fbcdn.net,CroLAX - DOMAIN-KEYWORD,twitter,CroLAX - DOMAIN-KEYWORD,instagram,CroLAX - DOMAIN-KEYWORD,dropbox,CroLAX - DOMAIN-SUFFIX,twimg.com,CroLAX - DOMAIN-KEYWORD,blogspot,CroLAX - DOMAIN-SUFFIX,youtu.be,CroLAX - DOMAIN-KEYWORD,whatsapp,CroLAX ## 国外网站 - DOMAIN-SUFFIX,9to5mac.com,CroLAX - DOMAIN-SUFFIX,abpchina.org,CroLAX - DOMAIN-SUFFIX,adblockplus.org,CroLAX - DOMAIN-SUFFIX,adobe.com,CroLAX - DOMAIN-SUFFIX,alfredapp.com,CroLAX - DOMAIN-SUFFIX,amplitude.com,CroLAX - DOMAIN-SUFFIX,ampproject.org,CroLAX - DOMAIN-SUFFIX,android.com,CroLAX - DOMAIN-SUFFIX,angularjs.org,CroLAX - DOMAIN-SUFFIX,aolcdn.com,CroLAX - DOMAIN-SUFFIX,apkpure.com,CroLAX - DOMAIN-SUFFIX,appledaily.com,CroLAX - DOMAIN-SUFFIX,appshopper.com,CroLAX - DOMAIN-SUFFIX,appspot.com,CroLAX - DOMAIN-SUFFIX,arcgis.com,CroLAX - DOMAIN-SUFFIX,archive.org,CroLAX - DOMAIN-SUFFIX,armorgames.com,CroLAX - DOMAIN-SUFFIX,aspnetcdn.com,CroLAX - DOMAIN-SUFFIX,att.com,CroLAX - DOMAIN-SUFFIX,awsstatic.com,CroLAX - DOMAIN-SUFFIX,azureedge.net,CroLAX - DOMAIN-SUFFIX,azurewebsites.net,CroLAX - DOMAIN-SUFFIX,bing.com,CroLAX - DOMAIN-SUFFIX,bintray.com,CroLAX - DOMAIN-SUFFIX,bit.com,CroLAX - DOMAIN-SUFFIX,bit.ly,CroLAX - DOMAIN-SUFFIX,bitbucket.org,CroLAX - DOMAIN-SUFFIX,bjango.com,CroLAX - DOMAIN-SUFFIX,bkrtx.com,CroLAX - DOMAIN-SUFFIX,blog.com,CroLAX - DOMAIN-SUFFIX,blogcdn.com,CroLAX - DOMAIN-SUFFIX,blogger.com,CroLAX - DOMAIN-SUFFIX,blogsmithmedia.com,CroLAX - DOMAIN-SUFFIX,blogspot.com,CroLAX - DOMAIN-SUFFIX,blogspot.hk,CroLAX - DOMAIN-SUFFIX,bloomberg.com,CroLAX - DOMAIN-SUFFIX,box.com,CroLAX - DOMAIN-SUFFIX,box.net,CroLAX - DOMAIN-SUFFIX,cachefly.net,CroLAX - DOMAIN-SUFFIX,chromium.org,CroLAX - DOMAIN-SUFFIX,cl.ly,CroLAX - DOMAIN-SUFFIX,cloudflare.com,CroLAX - DOMAIN-SUFFIX,cloudfront.net,CroLAX - DOMAIN-SUFFIX,cloudmagic.com,CroLAX - DOMAIN-SUFFIX,cmail19.com,CroLAX - DOMAIN-SUFFIX,cnet.com,CroLAX - DOMAIN-SUFFIX,cocoapods.org,CroLAX - DOMAIN-SUFFIX,comodoca.com,CroLAX - DOMAIN-SUFFIX,crashlytics.com,CroLAX - DOMAIN-SUFFIX,culturedcode.com,CroLAX - DOMAIN-SUFFIX,d.pr,CroLAX - DOMAIN-SUFFIX,danilo.to,CroLAX - DOMAIN-SUFFIX,dayone.me,CroLAX - DOMAIN-SUFFIX,db.tt,CroLAX - DOMAIN-SUFFIX,deskconnect.com,CroLAX - DOMAIN-SUFFIX,disq.us,CroLAX - DOMAIN-SUFFIX,disqus.com,CroLAX - DOMAIN-SUFFIX,disquscdn.com,CroLAX - DOMAIN-SUFFIX,dnsimple.com,CroLAX - DOMAIN-SUFFIX,docker.com,CroLAX - DOMAIN-SUFFIX,dribbble.com,CroLAX - DOMAIN-SUFFIX,droplr.com,CroLAX - DOMAIN-SUFFIX,duckduckgo.com,CroLAX - DOMAIN-SUFFIX,dueapp.com,CroLAX - DOMAIN-SUFFIX,dytt8.net,CroLAX - DOMAIN-SUFFIX,edgecastcdn.net,CroLAX - DOMAIN-SUFFIX,edgekey.net,CroLAX - DOMAIN-SUFFIX,edgesuite.net,CroLAX - DOMAIN-SUFFIX,engadget.com,CroLAX - DOMAIN-SUFFIX,entrust.net,CroLAX - DOMAIN-SUFFIX,eurekavpt.com,CroLAX - DOMAIN-SUFFIX,evernote.com,CroLAX - DOMAIN-SUFFIX,fabric.io,CroLAX - DOMAIN-SUFFIX,fast.com,CroLAX - DOMAIN-SUFFIX,fastly.net,CroLAX - DOMAIN-SUFFIX,fc2.com,CroLAX - DOMAIN-SUFFIX,feedburner.com,CroLAX - DOMAIN-SUFFIX,feedly.com,CroLAX - DOMAIN-SUFFIX,feedsportal.com,CroLAX - DOMAIN-SUFFIX,fiftythree.com,CroLAX - DOMAIN-SUFFIX,firebaseio.com,CroLAX - DOMAIN-SUFFIX,flexibits.com,CroLAX - DOMAIN-SUFFIX,flickr.com,CroLAX - DOMAIN-SUFFIX,flipboard.com,CroLAX - DOMAIN-SUFFIX,g.co,CroLAX - DOMAIN-SUFFIX,gabia.net,CroLAX - DOMAIN-SUFFIX,geni.us,CroLAX - DOMAIN-SUFFIX,gfx.ms,CroLAX - DOMAIN-SUFFIX,ggpht.com,CroLAX - DOMAIN-SUFFIX,ghostnoteapp.com,CroLAX - DOMAIN-SUFFIX,git.io,CroLAX - DOMAIN-KEYWORD,github,CroLAX - DOMAIN-SUFFIX,globalsign.com,CroLAX - DOMAIN-SUFFIX,gmodules.com,CroLAX - DOMAIN-SUFFIX,godaddy.com,CroLAX - DOMAIN-SUFFIX,golang.org,CroLAX - DOMAIN-SUFFIX,gongm.in,CroLAX - DOMAIN-SUFFIX,goo.gl,CroLAX - DOMAIN-SUFFIX,goodreaders.com,CroLAX - DOMAIN-SUFFIX,goodreads.com,CroLAX - DOMAIN-SUFFIX,gravatar.com,CroLAX - DOMAIN-SUFFIX,gstatic.com,CroLAX - DOMAIN-SUFFIX,gvt0.com,CroLAX - DOMAIN-SUFFIX,hockeyapp.net,CroLAX - DOMAIN-SUFFIX,hotmail.com,CroLAX - DOMAIN-SUFFIX,icons8.com,CroLAX - DOMAIN-SUFFIX,ift.tt,CroLAX - DOMAIN-SUFFIX,ifttt.com,CroLAX - DOMAIN-SUFFIX,iherb.com,CroLAX - DOMAIN-SUFFIX,imageshack.us,CroLAX - DOMAIN-SUFFIX,img.ly,CroLAX - DOMAIN-SUFFIX,imgur.com,CroLAX - DOMAIN-SUFFIX,imore.com,CroLAX - DOMAIN-SUFFIX,instapaper.com,CroLAX - DOMAIN-SUFFIX,ipn.li,CroLAX - DOMAIN-SUFFIX,is.gd,CroLAX - DOMAIN-SUFFIX,issuu.com,CroLAX - DOMAIN-SUFFIX,itgonglun.com,CroLAX - DOMAIN-SUFFIX,itun.es,CroLAX - DOMAIN-SUFFIX,ixquick.com,CroLAX - DOMAIN-SUFFIX,j.mp,CroLAX - DOMAIN-SUFFIX,js.revsci.net,CroLAX - DOMAIN-SUFFIX,jshint.com,CroLAX - DOMAIN-SUFFIX,jtvnw.net,CroLAX - DOMAIN-SUFFIX,justgetflux.com,CroLAX - DOMAIN-SUFFIX,kat.cr,CroLAX - DOMAIN-SUFFIX,klip.me,CroLAX - DOMAIN-SUFFIX,libsyn.com,CroLAX - DOMAIN-SUFFIX,linode.com,CroLAX - DOMAIN-SUFFIX,lithium.com,CroLAX - DOMAIN-SUFFIX,littlehj.com,CroLAX - DOMAIN-SUFFIX,live.com,CroLAX - DOMAIN-SUFFIX,live.net,CroLAX - DOMAIN-SUFFIX,livefilestore.com,CroLAX - DOMAIN-SUFFIX,llnwd.net,CroLAX - DOMAIN-SUFFIX,macid.co,CroLAX - DOMAIN-SUFFIX,macromedia.com,CroLAX - DOMAIN-SUFFIX,macrumors.com,CroLAX - DOMAIN-SUFFIX,mashable.com,CroLAX - DOMAIN-SUFFIX,mathjax.org,CroLAX - DOMAIN-SUFFIX,medium.com,CroLAX - DOMAIN-SUFFIX,mega.co.nz,CroLAX - DOMAIN-SUFFIX,mega.nz,CroLAX - DOMAIN-SUFFIX,megaupload.com,CroLAX - DOMAIN-SUFFIX,microsofttranslator.com,CroLAX - DOMAIN-SUFFIX,mindnode.com,CroLAX - DOMAIN-SUFFIX,mobile01.com,CroLAX - DOMAIN-SUFFIX,modmyi.com,CroLAX - DOMAIN-SUFFIX,msedge.net,CroLAX - DOMAIN-SUFFIX,myfontastic.com,CroLAX - DOMAIN-SUFFIX,name.com,CroLAX - DOMAIN-SUFFIX,nextmedia.com,CroLAX - DOMAIN-SUFFIX,nsstatic.net,CroLAX - DOMAIN-SUFFIX,nssurge.com,CroLAX - DOMAIN-SUFFIX,nyt.com,CroLAX - DOMAIN-SUFFIX,nytimes.com,CroLAX - DOMAIN-SUFFIX,omnigroup.com,CroLAX - DOMAIN-SUFFIX,onedrive.com,CroLAX - DOMAIN-SUFFIX,onenote.com,CroLAX - DOMAIN-SUFFIX,ooyala.com,CroLAX - DOMAIN-SUFFIX,openvpn.net,CroLAX - DOMAIN-SUFFIX,openwrt.org,CroLAX - DOMAIN-SUFFIX,orkut.com,CroLAX - DOMAIN-SUFFIX,osxdaily.com,CroLAX - DOMAIN-SUFFIX,outlook.com,CroLAX - DOMAIN-SUFFIX,ow.ly,CroLAX - DOMAIN-SUFFIX,paddleapi.com,CroLAX - DOMAIN-SUFFIX,parallels.com,CroLAX - DOMAIN-SUFFIX,parse.com,CroLAX - DOMAIN-SUFFIX,pdfexpert.com,CroLAX - DOMAIN-SUFFIX,periscope.tv,CroLAX - DOMAIN-SUFFIX,pinboard.in,CroLAX - DOMAIN-SUFFIX,pinterest.com,CroLAX - DOMAIN-SUFFIX,pixelmator.com,CroLAX - DOMAIN-SUFFIX,pixiv.net,CroLAX - DOMAIN-SUFFIX,playpcesor.com,CroLAX - DOMAIN-SUFFIX,playstation.com,CroLAX - DOMAIN-SUFFIX,playstation.com.hk,CroLAX - DOMAIN-SUFFIX,playstation.net,CroLAX - DOMAIN-SUFFIX,playstationnetwork.com,CroLAX - DOMAIN-SUFFIX,pushwoosh.com,CroLAX - DOMAIN-SUFFIX,rime.im,CroLAX - DOMAIN-SUFFIX,servebom.com,CroLAX - DOMAIN-SUFFIX,sfx.ms,CroLAX - DOMAIN-SUFFIX,shadowsocks.org,CroLAX - DOMAIN-SUFFIX,sharethis.com,CroLAX - DOMAIN-SUFFIX,shazam.com,CroLAX - DOMAIN-SUFFIX,skype.com,CroLAX - DOMAIN-SUFFIX,smartdnsProxy.com,CroLAX - DOMAIN-SUFFIX,smartmailcloud.com,CroLAX - DOMAIN-SUFFIX,sndcdn.com,CroLAX - DOMAIN-SUFFIX,sony.com,CroLAX - DOMAIN-SUFFIX,soundcloud.com,CroLAX - DOMAIN-SUFFIX,sourceforge.net,CroLAX - DOMAIN-SUFFIX,spotify.com,CroLAX - DOMAIN-SUFFIX,squarespace.com,CroLAX - DOMAIN-SUFFIX,sstatic.net,CroLAX - DOMAIN-SUFFIX,st.luluku.pw,CroLAX - DOMAIN-SUFFIX,stackoverflow.com,CroLAX - DOMAIN-SUFFIX,startpage.com,CroLAX - DOMAIN-SUFFIX,staticflickr.com,CroLAX - DOMAIN-SUFFIX,steamcommunity.com,CroLAX - DOMAIN-SUFFIX,symauth.com,CroLAX - DOMAIN-SUFFIX,symcb.com,CroLAX - DOMAIN-SUFFIX,symcd.com,CroLAX - DOMAIN-SUFFIX,tapbots.com,CroLAX - DOMAIN-SUFFIX,tapbots.net,CroLAX - DOMAIN-SUFFIX,tdesktop.com,CroLAX - DOMAIN-SUFFIX,techcrunch.com,CroLAX - DOMAIN-SUFFIX,techsmith.com,CroLAX - DOMAIN-SUFFIX,thepiratebay.org,CroLAX - DOMAIN-SUFFIX,theverge.com,CroLAX - DOMAIN-SUFFIX,time.com,CroLAX - DOMAIN-SUFFIX,timeinc.net,CroLAX - DOMAIN-SUFFIX,tiny.cc,CroLAX - DOMAIN-SUFFIX,tinypic.com,CroLAX - DOMAIN-SUFFIX,tmblr.co,CroLAX - DOMAIN-SUFFIX,todoist.com,CroLAX - DOMAIN-SUFFIX,trello.com,CroLAX - DOMAIN-SUFFIX,trustasiassl.com,CroLAX - DOMAIN-SUFFIX,tumblr.co,CroLAX - DOMAIN-SUFFIX,tumblr.com,CroLAX - DOMAIN-SUFFIX,tweetdeck.com,CroLAX - DOMAIN-SUFFIX,tweetmarker.net,CroLAX - DOMAIN-SUFFIX,twitch.tv,CroLAX - DOMAIN-SUFFIX,txmblr.com,CroLAX - DOMAIN-SUFFIX,typekit.net,CroLAX - DOMAIN-SUFFIX,ubertags.com,CroLAX - DOMAIN-SUFFIX,ublock.org,CroLAX - DOMAIN-SUFFIX,ubnt.com,CroLAX - DOMAIN-SUFFIX,ulyssesapp.com,CroLAX - DOMAIN-SUFFIX,urchin.com,CroLAX - DOMAIN-SUFFIX,usertrust.com,CroLAX - DOMAIN-SUFFIX,v.gd,CroLAX - DOMAIN-SUFFIX,vimeo.com,CroLAX - DOMAIN-SUFFIX,vimeocdn.com,CroLAX - DOMAIN-SUFFIX,vine.co,CroLAX - DOMAIN-SUFFIX,vivaldi.com,CroLAX - DOMAIN-SUFFIX,vox-cdn.com,CroLAX - DOMAIN-SUFFIX,vsco.co,CroLAX - DOMAIN-SUFFIX,vultr.com,CroLAX - DOMAIN-SUFFIX,w.org,CroLAX - DOMAIN-SUFFIX,w3schools.com,CroLAX - DOMAIN-SUFFIX,webtype.com,CroLAX - DOMAIN-SUFFIX,wikiwand.com,CroLAX - DOMAIN-SUFFIX,wikileaks.org,CroLAX - DOMAIN-SUFFIX,wikimedia.org,CroLAX - DOMAIN-SUFFIX,wikipedia.com,CroLAX - DOMAIN-SUFFIX,wikipedia.org,CroLAX - DOMAIN-SUFFIX,windows.com,CroLAX - DOMAIN-SUFFIX,windows.net,CroLAX - DOMAIN-SUFFIX,wire.com,CroLAX - DOMAIN-SUFFIX,wordpress.com,CroLAX - DOMAIN-SUFFIX,workflowy.com,CroLAX - DOMAIN-SUFFIX,wp.com,CroLAX - DOMAIN-SUFFIX,wsj.com,CroLAX - DOMAIN-SUFFIX,wsj.net,CroLAX - DOMAIN-SUFFIX,xda-developers.com,CroLAX - DOMAIN-SUFFIX,xeeno.com,CroLAX - DOMAIN-SUFFIX,xiti.com,CroLAX - DOMAIN-SUFFIX,yahoo.com,CroLAX - DOMAIN-SUFFIX,yimg.com,CroLAX - DOMAIN-SUFFIX,ying.com,CroLAX - DOMAIN-SUFFIX,yoyo.org,CroLAX - DOMAIN-SUFFIX,ytimg.com,CroLAX - DOMAIN-SUFFIX,telegram.me,CroLAX - IP-CIDR,91.108.4.0/22,CroLAX - IP-CIDR,91.108.8.0/22,CroLAX - IP-CIDR,91.108.56.0/22,CroLAX - IP-CIDR,109.239.140.0/24,CroLAX - IP-CIDR,149.154.160.0/20,CroLAX - IP-CIDR,127.0.0.0/8,DIRECT - IP-CIDR,172.16.0.0/12,DIRECT - IP-CIDR,192.168.0.0/16,DIRECT - IP-CIDR,10.0.0.0/8,DIRECT - IP-CIDR,17.0.0.0/8,DIRECT - IP-CIDR,100.64.0.0/10,DIRECT - GEOIP,CN,DIRECT - MATCH,,CroLAX 主要关注注释代码部分，更加详细的ClashX配置说明请参加 此文。 windows端 windows端使用v2rayN软件，安装后点击服务器 -&gt; 添加[VMess]服务器, 具体配置如下： 配置 BBR 加速TCP BBR 是谷歌在 2016 年 9 月开源的一个优化 TCP 拥塞的算法，并且 Linux 内核从 4.9 版本开始集成该算法，据多方网友反馈，网速甚至可以提升好几个数量级， 一般新版的Linux操作系统以及自带了BBR，不需要手动安装，如果是老系统，可以执行下面命令： 12345678# 下载脚本wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh# 添加可执行权限chmod +x bbr.sh# 运行bbr脚本./bbr.sh 12345wget --no-check-certificate https://raw.githubusercontent.com/cx9208/Linux-NetSpeed/master/tcp.shchmod +x tcp.sh./tcp.sh 我这边系统以及自带，运行bbr脚本后提示已经安装了，结果如下： 可以验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令： 123456789uname -r # &gt;&gt; 4.18.0-147.8.1.el8_1.x86_64sysctl net.ipv4.tcp_available_congestion_control # &gt;&gt; net.ipv4.tcp_available_congestion_control = reno cubic bbrsysctl net.ipv4.tcp_congestion_control # &gt;&gt; net.ipv4.tcp_congestion_control = bbrsysctl net.core.default_qdisc # &gt;&gt; net.core.default_qdisc = fqlsmod | grep bbr # &gt;&gt; tcp_bbr 20480 9 返回值有 tcp_bbr 模块即说明bbr已启动。 Trojan安装教程Trojan是一个近两年兴起的网络工具，项目官网（https://github.com/trojan-gfw）。与强调加密和混淆的SS/SSR等工具不同，trojan将通信流量伪装成互联网上最常见的https流量，从而有效防止流量被检测和干扰。 使用Trojan需要一个指向服务器IP的域名以及域名证书。 使用Let’s Encrypt获取免费证书 开发端口 certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。需要开发防火墙端口 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --zone=public --add-port=443/tcp --permanent 如果80端口已被占用，请先停止占用的进程，例如停止Nginx： 1killall nginx 安装certbot 1yum install -y python3 &amp;&amp; pip3 install certbot 查看certbot使用方法： 1certbot --help 为指定域名生成证书： 1certbot certonly --standalone -d 域名1 -d 域名2 查看域名证书的路径和国旗时间 1certbot certificates 安装trojan服务端1sudo bash -c \"$(curl -fsSL https://raw.githubusercontent.com/trojan-gfw/trojan-quickstart/master/trojan-quickstart.sh)\" 该命令会下载最新版的trojan并安装。安装完毕后，trojan配置文件路径是 /usr/local/etc/trojan/config.json，其初始内容为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"run_type\": \"server\", \"local_addr\": \"0.0.0.0\", \"local_port\": 443, \"remote_addr\": \"127.0.0.1\", \"remote_port\": 80, \"password\": [ \"password1\", \"password2\" ], \"log_level\": 1, \"ssl\": &#123; \"cert\": \"/path/to/certificate.crt\", \"key\": \"/path/to/private.key\", \"key_password\": \"\", \"cipher\": \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\", \"cipher_tls13\": \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\", \"prefer_server_cipher\": true, \"alpn\": [ \"http/1.1\" ], \"reuse_session\": true, \"session_ticket\": false, \"session_timeout\": 600, \"plain_http_response\": \"\", \"curves\": \"\", \"dhparam\": \"\" &#125;, \"tcp\": &#123; \"prefer_ipv4\": false, \"no_delay\": true, \"keep_alive\": true, \"reuse_port\": false, \"fast_open\": false, \"fast_open_qlen\": 20 &#125;, \"mysql\": &#123; \"enabled\": false, \"server_addr\": \"127.0.0.1\", \"server_port\": 3306, \"database\": \"trojan\", \"username\": \"trojan\", \"password\": \"\" &#125;&#125; local_port：监听的端口，默认是443，除非端口被墙，不建议改成其他端口； remote_addr和remote_port：非trojan协议时，将请求转发处理的地址和端口。可以是任意有效的ip/域名和端口号，默认是本机和80端口； password：密码。需要几个密码就填几行，最后一行结尾不能有逗号； cert和key：域名的证书和密钥，Let’s Encrypt申请的证书可用 certbot certificates 查看证书路径； key_password：默认没有密码（如果证书文件有密码就要填上）； alpn：建议填两行：http/1.1和h2，保持默认也没有问题。 根据自己的情况修改配置，保存，然后设置开机启动： 1systemctl enable trojan 启动Trojan： 1systemctl start trojan 检查是否运行： 1ss -lp | grep trojan 证书自动更新Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如： 123systemctl stop trojancertbot renewsystemctl restart trojan 也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行： 10 0 1 */2 0 root systemctl stop trojan; /usr/local/bin/certbot renew; systemctl restart trojan Trojan客户端以Mac端使用ClashX客户端为例，配置如下： 123456789101112Proxy: - name: trojan_NJ5 type: trojan server: nj5.kobingo.xyz port: 443 password: OF54OAJN3WZ66882 # udp: true # sni: example.com # aka server name alpn: - h2 - http/1.1 # skip-cert-verify: true 参考文章 Trojan官网 trojan教程 https://github.com/hijkpw/scripts trojan一键脚本 Namesilo购买域名详细教程","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"梯子","slug":"梯子","permalink":"http://kobin.top/tags/%E6%A2%AF%E5%AD%90/"}]},{"title":"打造赏心悦目的Mac终端","slug":"others-zsh","date":"2020-06-10T11:36:19.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"others-zsh/","link":"","permalink":"http://kobin.top/others-zsh/","excerpt":"本文主要讲解如何基于iTerm2 + Oh My Zsh 打造赏心悦目的Mac终端，以及如何配置终端代理等。","text":"本文主要讲解如何基于iTerm2 + Oh My Zsh 打造赏心悦目的Mac终端，以及如何配置终端代理等。 下载iTerm2可以直接去官网下载：https://www.iterm2.com/ 安装完成后，在/bin目录下会多出一个zsh的文件。 Mac系统自带很多Shell，可以通过命令查看： 1cat /etc/shells 结果如下： 由于Mac默认使用dash作为终端，所以首先修改为默认使用zsh： 1chsh -s /bin/zsh 这就是iTerm2初始的样子，下面我们来美化它，让它变得好用又好看！ 安装Oh my zshoh-my-zsh开源地址：https://github.com/robbyrussell/oh-my-zsh 主要有curl和wget两种安装方式，可任选一种进行安装： 12# curl 安装方式sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 12# wget 安装方式sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" 安装命令和安装完成后的截图： 安装PowerLinePowerline是agnoster主题的依赖。具体可以在repo里查询到：https://github.com/agnoster/agnoster-zsh-theme 安装powerline的方式依然简单，也只需要一条命令： 1pip install powerline-status --user 没有安装pip的同学可能会碰到zsh: command not found: pip。 使用命令安装pip即可： 1sudo easy_install pip 安装后再次执行安装powerline的命令即可。 安装PowerFonts安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。 在你习惯的位置新建一个文件夹，如：~/Desktop/OpenSource/ 在此文件夹下执行git clone命令： 123456# git clonegit clone https://github.com/powerline/fonts.git --depth=1# cd to foldercd fonts# run install shell./install.sh 执行结果如下： 安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好： 安装配色方案配色方案在使用VIM或Colorful Log时会变得非常有用，同时界面也不会一片黑绿一样死板。 同样使用git clone的方式下载源码进行安装： 1234cd ~/Desktop/OpenSourcegit clone https://github.com/altercation/solarizedcd solarized/iterm2-colors-solarized/open . 在打开的finder窗口中，双击Solarized Dark.itermcolors和Solarized Light.itermcolors即可安装明暗两种配色： 再次进入iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets中根据个人喜好选择这两种配色中的一种即可： 安装主题下载agnoster主题，执行脚本安装： 1234cd ~/Desktop/OpenSourcegit clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.gitcd oh-my-zsh-agnoster-fcamblor/./install 执行上面的命令会将主题拷贝到oh my zsh的themes中： 拷贝完成后，执行命令打开zshrc配置文件，将ZSH_THEME后面的字段改为agnoster。 1vi ~/.zshrc 修改完成后按一下esc调出vi命令，输入:wq保存并退出vi模式。 此时command+Q或source配置文件后，iTerm2变了模样： 安装高亮插件这是oh my zsh的一个插件，安装方式与theme大同小异： 123cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitvi ~/.zshrc 这时我们再次打开zshrc文件进行编辑。找到plugins，此时plugins中应该已经有了git，我们需要把高亮插件也加上： 请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。 然后在文件的最后一行添加：source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 按一下esc调出vi命令，输入:wq保存并退出vi模式。 执行命令使刚才的修改生效： 1source ~/.zshrc 至此大功告成，请看最终效果图： 背景图片取自微软Surface Studio的4K壁纸(将近12MB大小)，非常漂亮，需要的可以自取： https://pan.baidu.com/s/1LKd4ghGyyNI6UwHhOHvfaA提取码: snrd 更换背景图片方式：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window -&gt; BackGround Image勾选图片即可。 可选择、命令补全跟代码高亮的安装方式一样，这也是一个zsh的插件，叫做zsh-autosuggestion，用于命令建议和补全。 123cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-autosuggestionsvi ~/.zshrc 找到plugins，加上这个插件即可： 插件效果： 有同学说补全命令的字体不太清晰，与背景颜色太过相近，其实可以自己调整一下字体颜色。 Preferences -&gt; Profiles -&gt; Colors 中有Foreground是标准字体颜色，ANSI Colors中Bright的第一个是补全的字体颜色。 VScode显示异常问题在经过上面配置后，发现VScode上的终端显示异常，主要原因是前面配置的agnoster主题需要PowerFonts字体的支持。 所以需要在VScode里设置字体（比如：Meslo LG L for Powerline）： 完成后，显示正常： 使用代理由于GFW的存在，平时用终端安装npm包，或者clone GitHub上的仓库等操作时，经常速度是可怜的10K/s甚至不到的速度，即便开了 SS / V2Ray 等代理服务，貌似在终端上没什么卵用😭（其实主要原因是这些代理服务走的是会话层，而item的命令走在网络层，层级更低，所以流量无法用过代理转发）。 如果你用的是VPN方式代理，那么估计你没有这个烦恼 原因是主流的VPN协议（包括PPTP / L2TP / OPENVPN / SSTP）跑在第二层（数据链路层）和第三层（网络层），基本可以说是全流量代理。 那有没有什么方法可以让iterm上的流量能走代理从而提高下载速度呢？ 答案是有的！ 下面的操作的前提是你自己有有可用的代理服务 编辑~/.zshrc: 1vim ~/.zshrc 在配置的最下面添加如下代码： 1234567891011121314151617function useProxy() &#123; export https_proxy=http://127.0.0.1:7890; export http_proxy=http://127.0.0.1:7890; export all_proxy=socks5://127.0.0.1:7891; echo 'open proxy successful';&#125;function closeProxy() &#123; unset https_proxy; unset http_proxy; unset all_proxy; echo 'close proxy successful';&#125;alias openP='useProxy'alias closeP='closeProxy' 保存更改，执行： 1source ~/.zshrc 接着只要在终端执行openP就能打开终端代理，执行closeP就能关闭终端代理 ZSH常用技能 自动补全 ZSH的补全功能非常贴心，按TAB可以补全命令、路径还有参数。 杀进程 Bash杀进程需要先用ps aux | grep xxx查找进程的PID，然后才能用kill PID。ZSH可以直接就kill xxx后按TAB会显示对应的PID，非常方便。 历史记录 ZSH的history可以跨session，可以共享，这样就一进行历史记录的受限查询。比如，输入git，再按向上箭头，会搜索前面所有的git命令。 通配符搜索 l .png查找当前目录下所有png文件，l **/.png递归查找。","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"Mac终端","slug":"Mac终端","permalink":"http://kobin.top/tags/Mac%E7%BB%88%E7%AB%AF/"}]},{"title":"常用软件大全","slug":"others-常用软件推荐","date":"2020-05-27T22:51:15.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"others-常用软件推荐/","link":"","permalink":"http://kobin.top/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"在此记录一些堪称神器的软件","text":"windows篇1. Listary它不仅可以在本地非常快速的搜索，还可以打开网站、在搜索引擎中搜索、随时随地打开快捷菜单、文件快速定位、快速打开cmd窗口等等优秀的功能； 比如输入 cmd打开cmd窗口，输入 cmda使用管理员权限打开cmd窗口，输入 wyyyy打开网易云音乐，找到某个文件的时候 Enter直接打开， Ctrl+Enter 是打开文件所在文件夹； 值得一提的是搜索关键词功能，让我们可以非常便捷的打开相应网站或在对应网站搜索，比如输入 gg我的存款呢？就可以直接使用默认浏览器在谷歌搜索中搜索了，我们还可以自定义输入其他关键字，只需把搜索链接中的关键字换成 {query} ~ 2. uTools可以作为程序启动器外，uTools最大的特点就是拥有强大的插件系统，每个插件都有简洁美观、易于操作的界面，输入plugins进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最趁手的工具合集，为各种日常操作提供便利。不断产生的新插件，也将为你带来无限可能。 个人常用图床、剪切板、todo、各种技术文档等 3. DittoDitto 是一款免费开源的windows剪切板管理工具，作为 CtrlC V工程师，复制粘贴少不了，更厉害的是，可以用它来批量的复制， Ctrl+C一堆别人的代码，一次性全粘上，岂不美哉； 使用快捷键打开剪切板历史，然后 Ctrl/Shift来选择你希望粘贴的内容， Enter即可选择性的粘贴多行内容；另外剪切板历史还可以搜索，快速找到复制内容； 只需设置寥寥几个快捷键，就可以很方便的操作剪切板，带来极大幸福~ 4. Winsnap看到上面的截图没，旁边都有很骚包的阴影，怎么做到的？不需要各种高大上的图片处理软件，只需 Winsnap ，它可以在截图的时候自动帮你加上背景阴影，然后帮你自动复制到剪切板； 它可以使用全屏、应用程序、窗口、对象等捕捉模式，更牛的是它还可以在截图的时候同时选择和捕捉多个对象，按住 Ctrl或 Shift选择多个窗口或对象…这个就比较厉害了，不信你试试？ 5. CmderCmder 是一个美观又实用的命令行工具，它支持大部分Linux命令，支持ssh连Linux，还可以在它的窗口中新建cmd和powershell，更多玩法等你来战~ 比较方便的是在安装目录下 \\config\\user-aliases.cmd设置 alias 别名，比如参见的 Git 操作： 12345678910111213ga=git add $*gb=git branch $*gc=git commit $*gch=git checkout $*gd=git diff $*gl=git log $*gs=git status $* 还可以将cmder配置到右键菜单，快捷在当前目录打开cmder，方法是先把这个地址加到系统的path环境变量里面，比如我的是 D:cmder，然后右键 Cmder.exe属性-兼容性-以管理员身份运行此程序，再重新打开 Cmder.exe输入 Cmder.exe/REGISTER ALL就行了~ 记得安装完在配置 Setting-Startup-Environment里面加上 setLANG=zh_CN.UTF8，否则输出的一些中文会乱码； 6. Typora使用过很多 Markdown 编辑器，最后选择了 Typora，与主流编辑器一边编辑一边预览的形式，Typora 是将编辑和预览合并到一起，简洁大方，目光也不需要在复杂的编辑区和预览区中来回切换了，只有当焦点移入的时候才显示 Markdown 语法； 另外 Typora 还支持 Latex、 [TOC]动态目录、拖拽图片自动生成本地预览链接、自定义主题等方便的功能； 7. Quick LookQuickLook 是在 Microsoft Store 里面下载的一个速览工具，有时候打开一个PDF、TXT、图片之类的需要等关联程序启动半天，有了它之后只要选中目标文件，按空格，就可以快速预览了，速度非常快，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML等格式； 用它来看一些代码什么的，甚至不需要 Sublime\\VSCode 启动就可以直接看了，如果只是速览一下的话是非常适合的了。 8. Myper SplashMyper Splash 也是可以在 Microsoft Store 里面下载的一款高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用，再加上简洁美观的UI/UX设计，让你体验一见钟情的感觉。 另外 MyperSplash 可以设置自动每天自动更换壁纸或锁屏，每天早晨来到办公室点亮屏幕就可以看到 Awesome 的锁屏或壁纸，让你带着好心情开启一天的工作。 9. GifCam / ScreenToGif相信大家都有过需要截一个 Gif 的时候，这里有两个免费 Gif 屏幕录制工具都很不错，小而美的 GifCam 和开源强大的 ScreenToGif ； 10. Free Download ManageFree Download Manage (FDM) 是一款免费的下载工具，如果你已经受够了国内一些软件的广告和限速，那么 FDM 是一个不错的选择，另外多线程、断点续传、计划任务等功能让 FDM 值得推介。 11. SourcetreeSourcetree 是跨平台免费的 Git 客户端管理工具，如果受够了手打各种 Git 操作命令，那么 Sourcetree 是一个不错的选择； Sourcetree 可以大大简化你的代码操作，特别是对于一些不甚熟悉 Git 命令的人来说灰常实用；一些对 Git 操作比较熟练的用户也可以用它来提升效率，减少出错。","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"software","slug":"software","permalink":"http://kobin.top/tags/software/"},{"name":"软件","slug":"软件","permalink":"http://kobin.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"centOS7安装Java环境","slug":"others-centOS7安装Java环境","date":"2020-05-22T16:28:42.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"others-centOS7安装Java环境/","link":"","permalink":"http://kobin.top/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/","excerpt":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程","text":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程 1. 选择合适的jdk版本 jdk下载地址 选择一下版本获取下载链接 2. 下载1wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b 此链接地址可能失效，请自行在步骤1中获取最新下载链接 下载后检查安装包大小是否符合预期（判断安装包是否损坏） 1ls -lht 3. 安装3.1. 创建安装目录： 1mkdir /usr/local/java/ 3.2 解压到安装目录： 1tar -zxvf jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b -C /usr/local/java 4. 配置环境变量打开profile文件 1vim /etc/profile 在末尾添加一下代码： 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_251export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量生效 1source /etc/profile 添加软链接 1ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java 验证是否安装成功 1java -version","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kobin.top/tags/Linux/"},{"name":"centOS","slug":"centOS","permalink":"http://kobin.top/tags/centOS/"},{"name":"java","slug":"java","permalink":"http://kobin.top/tags/java/"}]},{"title":"ECMAScript新特性","slug":"javascript-ECMAScript特性分析","date":"2020-05-22T14:59:54.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-ECMAScript特性分析/","link":"","permalink":"http://kobin.top/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/","excerpt":"2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES 2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。","text":"2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES 2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。 ES 7 新特性 功能点 说明 Array.prototype.includes 查找数组 Exponentiation operator 指数函数的中缀表示法 Array.prototype.includesincludes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（和indexOf不一样的点)。 1234567891011121314let arr = [1, 2, 3, NaN];if (arr.includes(2)) &#123; //查找2是否存在于arr数组中 console.log(\"找到了!\"); //&gt;&gt; 找到了！&#125;if (!arr.includes(2, 3)) &#123; //第二个参数3表示数组下标为3的项，也即第4项开始查找 console.warn(\"不存在!\"); //&gt;&gt; 不存在！&#125;//下面两句说明incluedes和indexOf的区别console.log(arr.includes(NaN)); //trueconsole.log(arr.indexOf(NaN) != -1); //false 指数函数用法JavaScript采用两个星符号**来表示Math.pow，相对于Math.pow的好处： 中缀表示法比函数表示法更简洁，这使它更可取。 方便数学、物理、机器人学等领域的计算。 12345678910//用法一：x ** ylet squared = 2 ** 2;//等同于: 2 * 2let cubed = 2 ** 3;//等同于: 2 * 2 * 2//用法二：x **= ylet a = 2;a **= 2;//等同于: a = a * a;let b = 3;b **= 3;//等同于: b = b * b * b; ES 8 新特性 功能点 说明 Object.values / Object.entries String padding 字符串追加 Object.getOwnPropertyDescriptors 返回指定对象自己所有的属性内容 Async functions 异步函数 Shared memory and atomics 共享内存和 Atomics 对象 Object.values() / Object.entries Object.values(obj)，obj 参数是对目标对象的操作，它可以是一个对象或者数组 12345678910const obj = &#123; x: 'xxx', y: 1 &#125;;Object.values(obj); // ['xxx', 1]const obj = ['e', 's', '8']; // 等同于 &#123; 0: 'e', 1: 's', 2: '8' &#125;;Object.values(obj); // ['e', 's', '8']//当把数字对象的当键的时候，返回的数组以键的值升序排序const obj = &#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;;Object.values(obj); // ['yyy', 'zzz', 'xxx']Object.values('es8'); // ['e', 's', '8'] Object.entries方法返回一个给定对象可枚举属性值的数组[key, value]，与Object.values类似 123456789const obj = &#123; x: 'xxx', y: 1 &#125;;Object.entries(obj); // [['x', 'xxx'], ['y', 1]]const obj = ['e', 's', '8'];Object.entries(obj); // [['0', 'e'], ['1', 's'], ['2', '8']]const obj = &#123; 10: 'xxx', 1: 'yyy', 3: 'zzz' &#125;;Object.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']] 字符串追加在 ES 8 中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。String.padStart(targetLength,[padString])targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。padString：(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。String.padEnd(targetLength,padString]) 参数释义同上。 1234567891011'es8'.padStart(2); // 'es8''es8'.padStart(5); // ' es8''es8'.padStart(6, '1891'); // '189es8''es8'.padStart(14, 'coffe'); // 'coffecoffecoffes8''es8'.padStart(7, '0'); // '0000es8''es8'.padEnd(2); // 'es8''es8'.padEnd(5); // 'es8 ''es8'.padEnd(6, '1891'); // 'es81891''es8'.padEnd(14, 'coffe'); // 'es8coffecoffecoff''es8'.padEnd(7, '9'); // 'es89999' Object.getOwnPropertyDescriptorsgetOwnPropertyDescriptors方法返回指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。定义是：Object.getOwnPropertyDescriptors(obj)，obj 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。 12345678910111213141516171819const obj = &#123; get es7() &#123; return 7; &#125;, get es8() &#123; return 8; &#125;&#125;;Object.getOwnPropertyDescriptors(obj);// &#123;// es7: &#123;// configurable: true,// enumerable: true,// get: function es7()&#123;&#125;, //the getter function// set: undefined// &#125;,// es8: &#123;// configurable: true,// enumerable: true,// get: function es8()&#123;&#125;, //the getter function// set: undefined// &#125;// &#125; getOwnPropertyDescriptors可以用来创建子类： 12345678function superclass() &#123;&#125;superclass.prototype = &#123; // 在这里定义方法和属性&#125;;function subclass() &#123;&#125;subclass.prototype = Object.create(superclass.prototype, Object.getOwnPropertyDescriptors(&#123; // 在这里定义方法和属性&#125;)); 异步函数Async Functions也就是我们常说的Async/Await,已经用的很频繁了，在此不再赘述。 SharedArrayBuffer &amp; AtomicsSharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。 请注意，作为对Spectre的响应，所有主流浏览器均默认于2018年1月5日禁用SharedArrayBuffer。 Chrome在启用了网站隔离功能的平台上的v67中重新启用了该功能，以防止出现Spectre风格的漏洞。 语法： 123456/** * * @param &#123;*&#125; length 所创建的数组缓冲区的大小，以字节(byte)为单位。 * @returns &#123;SharedArrayBuffer&#125; 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 */new SharedArrayBuffer(length) 共享内存能被同时创建和更新于工作者线程或主线程。依赖于系统（CPU，操作系统，浏览器），变化传递给所有上下文环境需要一段时间。需要通过 atomic 操作来进行同步。 Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。 多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。 方法名 说明 Atomics.add() 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值 Atomics.and() 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 Atomics.compareExchange() 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 Atomics.exchange() 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 Atomics.load() 返回数组中指定元素的值。 Atomics.or() 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 Atomics.store() 将数组中指定的元素设置为给定的值，并返回该值。 Atomics.sub() 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 Atomics.xor() 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 Atomics.wait() 检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。 Atomics.wake() 唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。 Atomics.isLockFree(size) 可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。 ES 9 新特性 新特性 中文说明 Asynchronous Iteration 异步迭代器 Promise.prototype.finally Lifting template literal restriction 重新修订了字面量的转义 Rest/Spread Properties Rest/Spread 属性 s (dotAll) flag for regular expressions 正则表达式dotAll模式 RegExp named capture groups 正则表达式命名捕获组 RegExp Lookbehind Assertions 正则表达式反向断言 RegExp Unicode Property Escapes 正则表达式 Unicode 转义 异步迭代器在async/await的某些时刻，你可能尝试在同步循环中调用异步函数。例如： 12345async function func(array) &#123; for (let i of array) &#123; await someFunc(i); &#125;&#125; 这段代码不会达到预期目的，下面这段同样也不会： 12345async function func(array) &#123; array.forEach(async i =&gt; &#123; await someFunc(i); &#125;);&#125; 上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。 引入异步迭代器后，就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。 12345async function func(array) &#123; for await (let i of array) &#123;//异步迭代 someFunc(i); &#125;&#125; 更多详细论述见“壹.2.12”。 Promise.prototype.finally一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，.finally()允许实现这样的目的。 1234567891011function func() &#123; promiseFunc() //返回一个Promise对象 .then(() =&gt; &#123;&#125;) .then(() =&gt; &#123;&#125;) .catch(err =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; //无论promiseFunc()运行成功还是失败，这里的代码会被调用到 &#125;);&#125; 更多详细论述见“壹.2.12”。 重新修订了字面量的转义ES9 之前，\\u表示 unicode 转义，\\x表示十六进制转义，\\后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径C:\\uuu\\xxx\\111。 要取消转义序列的语法限制，可在模板字符串之前使用标记函数String.raw。 12345let s = `\\u&#123;54&#125;` //会转义成unicode \"T\"console.log(s);//&gt;&gt; Tlet str = String.raw`\\u&#123;54&#125;`; //不会被转义console.log(str);//&gt;&gt; \\u&#123;54&#125; Rest / Spread 属性这个就是我们通常所说的三个点...，在=左边的是rest参数，放在=右边或者作为参数的是扩展运算符，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符： 12345678910111213const obj = &#123; a: 1, b: 2, c: 3&#125;;const &#123; a, ...param &#125; = obj; //这里...是rest参数console.log(a); //&gt;&gt; 1console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;function foo(&#123; a, ...param &#125;) &#123;//这里...是扩展运算符 console.log(a); //&gt;&gt; 1 console.log(param); //&gt;&gt; &#123;b: 2, c: 3&#125;&#125; 正则表达式dotAll模式正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许匹配回车换行。 1234/hello.world/.test('hello\\nworld'); // false/hello.world/s.test('hello\\nworld'); // trueconsole.log(/hello.world/s.test(`helloworld`)) //&gt;&gt; true 正则表达式命名捕获组Javascript正则表达式中使用exec()匹配后，能够返回一个包含匹配字符串的类数组对象。 12345678const reDate = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/, match = reDate.exec(\"2018-08-06\");console.log(match);//&gt;&gt; [2018-08-06, 2018, 08, 06]//这样就可以直接用索引来获取年月日：let year = match[1]; //&gt;&gt; 2018let month = match[2]; //&gt;&gt; 08let day = match[3]; //&gt;&gt; 06 返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 reDate 的第 1 个分组\\d{4}相匹配的文本（如果有的话），第 2 项是与 reDate 的第 2 个分组\\d{2}相匹配的文本（如果有的话），以此类推。正则表达式的组以()包起来。 上面的案例，若是日期格式变成月日年，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例： 12345678const reDate = /(\\d&#123;2&#125;)-(\\d&#123;2&#125;)-(\\d&#123;4&#125;)/,//表达式结构变化了 match = reDate.exec(\"08-06-2018\");console.log(match);//&gt;&gt; [08-06-2018, 08, 06, 2018]//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？let year = match[3]; //&gt;&gt; 2018let month = match[1]; //&gt;&gt; 08let day = match[2]; //&gt;&gt; 06 可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号?&lt;name&gt;来命名捕获组（也即“匹配到的组”），示例如下： 123456789const reDate = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/, match = reDate.exec(\"2018-08-06\");console.log(match);//&gt;&gt; [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！let year = match.groups.year; //&gt;&gt; 2018let month = match.groups.month; //&gt;&gt; 08let day = match.groups.day; //&gt;&gt; 06 命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的groups属性中。 正则表达式后行断言先看看正则表达式先行断言示例： 123456const re1 = /\\D(\\d+)/, re2 = /\\D(?=\\d+)/,//\"?=\"是正向先行断言 match1 = re1.exec(\"$123.45\"), match2 = re2.exec(\"$123.45\");console.log(match1[0]); //&gt;&gt; $123console.log(match2[0]); //&gt;&gt; $ (?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion)代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern； (?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion)代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern； (?&lt;=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion)代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern； (?&lt;!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion)代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。 在ES9中，可以允许使用?&lt;=进行正向后行断言，可以获取货币的价格而忽略货币符号。 123const re= /(?&lt;=\\D)[\\d\\.]+/, match = re.exec(\"$123.45\");console.log(match[0]); //&gt;&gt; 123.45 上面的正向后行断言，也就是说\\D这个条件必须满足，但\\D匹配的字符不会作为结果输出（因为先行/后行断言其实只是匹配了一个位置）。如果是下面这样： 12345const re= /(?&lt;=\\D)[\\d\\.]+/, match1 = re.exec(\"123.45\"), match2 = re.exec(\"12345\");console.log(match1 &amp;&amp; match1[0]); //&gt;&gt; 45console.log(match2 &amp;&amp; match1[0]); //&gt;&gt; null 可以看到match1匹配到的是45,这是由于在.前面没有任何符合\\D的匹配内容，它会一直找到符合\\D的内容，也就是.然后返回后面的内容。而match2若是没有满足前面肯定反向断言的条件的话，则结果返回null。 正则表达式 Unicode 转义ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为\\p{...}和\\P{...}，在正则表达式中使用标记 u (unicode) 设置，在\\p的{...}内，可用键值对的方式设置需要匹配的属性而非具体内容。 123const regex = /\\p&#123;Script=Greek&#125;/u;//Greek为希腊语的意思console.log(regex.test('a')); //&gt;&gt; flaseconsole.log(regex.test('Σ')); //&gt;&gt; true ES 10 新特性 新特性 中文说明 Optional catch binding 可选的 catch 变量绑定 JSON superset JSON超集 Symbol.prototype.description Symbol 对象的 description 属性 Function.prototype.toString revision 修订Function.prototype.toString Object.fromEntries Well-formed JSON.stringify 更加友好的JSON.stringify String.prototype.{trimStart,trimEnd} Array.prototype.{flat,flatMap} 可选的 catch 变量绑定在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。 12345//之前是try &#123;&#125; catch(e) &#123;&#125;//ES10之后可以写成，try &#123;&#125; catch &#123;&#125;//省掉了变量e JSON超集什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。 ECMAScript 在标准 JSON.parse 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 U+2028 行分隔符与 U+2029 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 JSON.parse() 执行带如上特殊字符的字符串时，只会收到 SyntaxError 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 SyntaxError 。 Symbol 对象的 description 属性ES10 中为 Symbol 对象添加了只读属性 description ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加description (描述)，能够直接访问description ，对调试是很有用的。 123456789101112let sym = Symbol('foo');//添加的描述内容为“foo”console.log(sym.description);//&gt;&gt; foosym = Symbol();console.log(sym.description);//&gt;&gt; undefined//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它//会再新建一个。sym = Symbol.for('bar');console.log(sym.description);//&gt;&gt; bar 修订Function.prototype.toString函数原型上的方法toString()现在返回精确字符，包括空格和注释。 123456789101112function /* comment */ foo /* another comment */() &#123;&#125;//ES10之前不会打印注释部分console.log(foo.toString()); //&gt;&gt; function foo()&#123;&#125;//ES10里，会把注释一同打印console.log(foo.toString()); //&gt;&gt; function /* comment */ foo /* another comment */ ()&#123;&#125;//注意：//箭头函数是个例外const bar /* comment */ = /* another comment */ () =&gt; &#123;&#125;;console.log(bar.toString()); //&gt;&gt; () =&gt; &#123;&#125; Object.fromEntries在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。 12345678let map = new Map().set('foo', true).set('bar', false);let arr = Array.from(map);let set = new Set(map.values());let obj = &#123; foo: true, bar: false &#125;;//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,//形如：[[\"foo\",true],[\"bar\",false]]let newMap = new Map(Object.entries(obj)); 但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。 123456let map = new Map().set(\"foo\", true).set(\"bar\", false);let obj = Array.from(map).reduce((acc, [key, val]) =&gt; &#123; return Object.assign(acc, &#123; [key]: val &#125;);&#125;, &#123;&#125;); 该特性的目的在于为对象添加一个新的静态方法 Object.fromEntries，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。 12const map = new Map().set(\"foo\", true).set(\"bar\", false);let obj = Object.fromEntries(map); 更加友好的 JSON.stringifyES10 之前，当你使用 JSON.stringify() 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用JSON.stringify()来安全的表示这些不正常的UTF-8字符。 123456789101112let r;r = JSON.stringify(\"❤\"); //正常的UTF-8字符原样输出console.log(r); //&gt;&gt; \"❤\"r = JSON.stringify('\\u2764'); //正常的UTF-8字符编码，输出解码之后的模样console.log(r); //&gt;&gt; \"❤\"r = JSON.stringify(\"\\uDF06\\uD834\"); //不正常的UTF-8字符编码，则以unicode形式输出console.log(r); //&gt;&gt; \"\\udf06\\ud834\"r = JSON.stringify(\"\\uDEAD\"); //不正常的UTF-8字符编码，则以unicode形式输出console.log(r); //&gt;&gt; \"\\udead\" String.prototype.{trimStart,trimEnd}新增了String的trimStart()方法和trimEnd()方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。 Array.prototype.{flat,flatMap}这个特性新创造了两个方法，其中： Array.prototype.flat 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回； Array.prototype.flatMap 首先会执行一次map()方法，然后再通过类似flat()方法扁平化数组。它等同于执行完 map() 后再执行一次 flat() 方法，所以当你执行 map() 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。 来看几个例子解释一下，首先 flat() 方法支持多维数组的扁平化，其中Infinity可以将多维数组压扁成一维数组。 123456789let r;r = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat();//4维数组，默认降维1，变成3维数组console.log(r); //&gt;&gt; [ '1', '8', [ '9', ['1'] ] ]r = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat(2); //4维数组，降维2，变成2维数组console.log(r); //&gt;&gt; [ '1', '8', '9', ['1'] ]r = [\"1\", [\"8\", [\"9\", [\"1\"]]]].flat(Infinity);//4维数组，最多变成1维数组console.log(r); //&gt;&gt; [ '1', '8', '9', '1' ] 接着来看看flatMap() 123456let r;r = [\"I love\", \"coffe 1891\"].map(item =&gt; item.split(\" \"));console.log(r); //&gt;&gt; [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]r = [\"I love\", \"coffe 1891\"].flatMap(item =&gt; item.split(\" \"));console.log(r); //&gt;&gt;[ 'I', 'love', 'coffe', '1891' ] ES 11 新特性一览 新特性 中文说明 String.prototype.matchAll import() import()函数 Promise.allSettled String.prototype.matchAllmatchAll() 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 matchAll 出现之前，通过在循环中调用Regexp.exec来获取所有匹配项信息（Regexp需使用/g标志）： 12345678const regexp = RegExp('foo*','g');const str = 'coffe football, foosball';while ((matches = regexp.exec(str)) !== null) &#123; console.log(`找到 $&#123;matches[0]&#125;，下一轮循环从位置 $&#123;regexp.lastIndex&#125; 开始`); //&gt;&gt; 找到 foo，下一轮循环从位置 9 开始 //&gt;&gt; 找到 foo，下一轮循环从位置 19 开始&#125; 如果使用matchAll ，就可以不必使用while循环加exec方式（且正则表达式需使用/g标志）。使用matchAll 会得到一个迭代器的返回值，配合 for...of，array spread，Array.from() 可以更方便实现功能。 123456789101112131415161718const regexp = RegExp('foo*','g');const str = 'coffe football, foosball';let matches = str.matchAll(regexp);for (const match of matches) &#123; console.log(match);&#125;//&gt;&gt; [ \"foo\" ]//&gt;&gt; [ \"foo\" ]//注意：//matches的迭代器在for..of之后已经被消耗掉了，//需要再次调用matchAll创建一个新的迭代器matches = str.matchAll(regexp);let arr = Array.from(matches, m =&gt; m[0]);console.log(arr);//&gt;&gt; [ \"foo\", \"foo\" ] import()函数这个特性为JavaScript添加了一个类函数（function-like）的import()功能，以便可以像函数传参那样传入参数实现动态（没错，import是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用import()开启懒加载。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;nav&gt; &lt;a href&#x3D;&quot;books.html&quot; data-entry-module&#x3D;&quot;books&quot;&gt;书籍&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;movies.html&quot; data-entry-module&#x3D;&quot;movies&quot;&gt;电影&lt;&#x2F;a&gt; &lt;a href&#x3D;&quot;video-games.html&quot; data-entry-module&#x3D;&quot;video-games&quot;&gt;电视游戏&lt;&#x2F;a&gt;&lt;&#x2F;nav&gt;&lt;main&gt;内容将会加载到这里！&lt;&#x2F;main&gt;&lt;script&gt; const main &#x3D; document.querySelector(&quot;main&quot;); for (const link of document.querySelectorAll(&quot;nav &gt; a&quot;)) &#123; link.addEventListener(&quot;click&quot;, e &#x3D;&gt; &#123; e.preventDefault(); import(&#96;.&#x2F;section-modules&#x2F;$&#123;link.dataset.entryModule&#125;.js&#96;)&#x2F;&#x2F;动态引用 .then(module &#x3D;&gt; &#123;&#x2F;&#x2F;加载模块成功以后，该模块会当作then方法的参数 module.loadPageInto(main); &#125;) .catch(err &#x3D;&gt; &#123;&#x2F;&#x2F;捕捉异常 main.textContent &#x3D; err.message; &#125;); &#125;); &#125;&lt;&#x2F;script&gt; 请注意import()和import的区别： import() 可以用在script脚本区，不止是模块内； 如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）； import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数； import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如import（“/foo.js”）中，实现仍然可以执行静态分析优化。 如果模块采用default的形式对外暴露接口，则可用default属性直接获得。 1234import('./module.js').then(module =&gt; &#123; console.log(module.default);//直接通过default属性获得模块暴露的接口&#125;); Promise.allSettled为什么要有Promise.allSettled()？ 举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。 在多个promise同时进行时咱们很快会想到使用Promise.all来进行包装，但是由于Promise.all的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。 Promise.allSettled跟Promise.all类似，其参数接受一个Promise的数组，返回一个新的Promise，唯一的不同在于，其没有一票否决的特性，也就是说当Promise全部处理完成后我们可以拿到每个Promise的状态，而不管其是否处理成功。 123456Promise.allSettled([Promise.resolve(\"coffe\"), Promise.reject(\"1891\")]).then( arr =&gt; &#123; console.log(arr); //&gt;&gt; [ &#123; status: \"fulfilled\", value: \"coffe\"&#125;, //&gt;&gt; &#123; status: \"rejected\", reason: \"1891\" &#125; ] &#125;); 本篇结语很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"post","slug":"framework-virtual-dom","date":"2020-05-13T17:28:22.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"framework-virtual-dom/","link":"","permalink":"http://kobin.top/framework-virtual-dom/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"typeof 实现原理","slug":"javascript-typeof","date":"2020-05-06T23:11:22.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-typeof/","link":"","permalink":"http://kobin.top/javascript-typeof/","excerpt":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如","text":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 123let s = new String(\"abc\");typeof s === \"object\"; // trues instanceof String; // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 `null`：所有机器码均为0 `undefined`：用 −2^30 整数来表示所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 1null instanceof null; // TypeError: Right-hand side of 'instanceof' is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留 bug，可以参考 typeof. 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括 symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是 Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 123456789Object.prototype.toString.call(1); // \"[object Number]\"Object.prototype.toString.call(\"hi\"); // \"[object String]\"Object.prototype.toString.call(&#123; a: \"hi\" &#125;); // \"[object Object]\"Object.prototype.toString.call([1, \"a\"]); // \"[object Array]\"Object.prototype.toString.call(true); // \"[object Boolean]\"Object.prototype.toString.call(() =&gt; &#123;&#125;); // \"[object Function]\"Object.prototype.toString.call(null); // \"[object Null]\"Object.prototype.toString.call(undefined); // \"[object Undefined]\"Object.prototype.toString.call(Symbol(1)); // \"[object Symbol]\" instanceof 操作符的实现原理之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 123let person = function () &#123;&#125;;let nicole = new person();nicole instanceof person; // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 123456let person = function () &#123;&#125;;let programmer = function () &#123;&#125;;programmer.prototype = new person();let nicole = new programmer();nicole instanceof person; // truenicole instanceof programmer; // true instanceof 实现原理： 12345678910111213function new_instance_of(leftVaule, rightVaule) &#123; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__; &#125;&#125; 总结简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"一些 JS 关键技术的底层实现汇总","slug":"javascript-js-basic-implementation","date":"2020-05-06T22:40:35.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-js-basic-implementation/","link":"","permalink":"http://kobin.top/javascript-js-basic-implementation/","excerpt":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。","text":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() new 的原理 reduce 实现原理 双向绑定 继承 Object.create instanceof 实现 Array.isArray 实现 getOwnPropertyNames 实现 Promise 实现 防抖/节流 函数柯里化实现 实现简单深拷贝 Function.prototype.call()call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。 语法：fun.call(thisArg, arg1, arg2, ...) 123456789101112131415161718192021222324252627282930313233/** * call的实现原理 */const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;Function.prototype.mcall = function (context) &#123; context = context ? Object(context) : getGlobal(); const fn = Symbol(\"anything\"); //创建一个不重复的常量 context[fn] = this; let args = [...arguments].slice(1); let r = context[fn](...args); delete context[fn]; return r;&#125;;/** * 一个用call实现继承的例子 * @param &#123;*&#125; name * @param &#123;*&#125; price */function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Fruit(name, price) &#123; Product.mcall(this, name, price); this.category = \"fruit\";&#125;var apple = new Fruit(\"apple\", 5);console.log(apple); Function.prototype.apply()apply()调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数. 语法： func.apply(thisArg, [argsArray]) 1234567891011121314151617181920212223242526272829303132333435const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * apply原理 */Function.prototype.apply = function (context, arr) &#123; context = context ? Object(context) : getGlobal(); console.log(\"context\", context); const fn = Symbol(\"anything\"); //创建一个不重复的常量 context[fn] = this; // let args = [...arguments][1]; if (!arr) &#123; let r = context[fn](); delete context[fn]; return r; &#125; let r = context[fn](...arr); delete context[fn]; return r;&#125;;//使用例子var array = [\"a\", \"b\"];var elements = [0, 1, 2];array.push.apply(array, elements);console.log(\"array\", array); // [\"a\", \"b\", 0, 1, 2]function A(x, y) &#123; console.log(this.b + \" \" + x + \" \" + y);&#125;var B = &#123; b: 1 &#125;;A.apply(B, [2, 3]); Function.prototype.bind()bind()方法创建一个新函数, 在调用时设置 this 关键字为提供的值。 语法：fun.bind(thisArg, arg1, arg2, ...) 12345678910111213141516171819202122const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * bind实现原理 */Function.prototype.bind = function (context) &#123; context = context ? Object(context) : getGlobal(); const me = this; const args = [...arguments].slice(1); return function () &#123; me.apply(context, [...args, ...arguments]); &#125;;&#125;;function A(x, y) &#123; console.log(this.b + \", \" + x + \", \" + y);&#125;var B = &#123; b: 1 &#125;;let fnc = A.bind(B, 2); //1 2 3fnc(3); new 的原理在了解 new 原理之前先看看 js 的内部机制图 我们需要知道当 new 的时候做了什么事情 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 new 没法重写，这里是有 mockNew 函数来模拟 1234567891011121314151617181920212223242526272829303132/** * new实现原理 */function mockNew() &#123; //创建一个实例 const obj = &#123;&#125;; //获得构造器 const constructor = [].shift.call(arguments); //实现继承，实例可以访问构造器熟悉 obj.__proto__ = constructor.prototype; //调用构造器，改变this指向为实例 const res = constructor.apply(obj, arguments); //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象 return res instanceof Object ? res : obj;&#125;/** * 使用例子 * @param &#123;*&#125; color * @param &#123;*&#125; name */function Car(color, name) &#123; this.color = color; return &#123; name: name, &#125;;&#125;let car = mockNew(Car, \"black\", \"BMW\");console.log(car.color);// undefinedconsole.log(car.name);// \"BMW\" reduce 实现原理12345678910111213141516171819202122232425262728293031323334/** * 实现原理 */Array.prototype.mockReduce = function (callback) &#123; const length = this.length; let reducer = undefined, //累加器，最终返回这个值 k = 0, //数组下标 initVal = [...arguments].length &gt; 1 ? [...arguments][1] : undefined; //传入reduce的初始值 if (typeof callback !== \"function\") &#123; throw new TypeError(callback + \" is not a function\"); &#125; if (length === 0 &amp;&amp; !initVal) &#123; throw new TypeError(\"Reduce of empty array with no initial value\"); &#125; if (initVal) &#123; reducer = initVal; &#125; else &#123; reducer = this[0]; k++; &#125; while (k &lt; length) &#123; if (this.hasOwnProperty(k)) &#123; const kValue = this[k]; reducer = callback(reducer, kValue); &#125; k++; &#125; return reducer;&#125;;const rReduce = [].reduce((a, b) =&gt; a + b, 3);const mReduce = [].mockReduce((a, b) =&gt; a + b);console.log(rReduce, mReduce); 双向绑定defineProperty实现 123456789101112131415161718// 数据const data = &#123; text: \"hello\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持Object.defineProperty(data, \"text\", &#123; // 数据变化 --&gt; 修改视图 set(newVal) &#123; input.value = newVal; p.innerHTML = newVal; &#125;,&#125;);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; data.text = e.target.value;&#125;); proxy实现 12345678910111213141516171819202122// 数据const data = &#123; text: \"default\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持const handler = &#123; set(target, key, value) &#123; target[key] = value; // 数据变化 --&gt; 修改视图 input.value = value; p.innerHTML = value; return value; &#125;,&#125;;const proxy = new Proxy(data, handler);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; proxy.text = e.target.value;&#125;); 继承12345678910111213141516171819202122232425function inheritPrototype(subType, superType) &#123; var protoType = Object.create(superType.prototype); //创建对象 protoType.constructor = subType; //增强对象 subType.prototype = protoType; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; alert(this.age);&#125;;var instance = new SubType(\"Bob\", 18);instance.sayName();instance.sayAge(); Object.create1234567891011121314151617181920if (typeof Object.create !== \"function\") &#123; Object.create = function (prototype, properties) &#123; if (typeof prototype !== \"object\") &#123; throw TypeError(); &#125; function Ctor() &#123;&#125; Ctor.prototype = prototype; var o = new Ctor(); if (prototype) &#123; o.constructor = Ctor; &#125; if (properties !== undefined) &#123; if (properties !== Object(properties)) &#123; throw TypeError(); &#125; Object.defineProperties(o, properties); &#125; return o; &#125;;&#125; instanceof 实现原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null 1234567891011// L 表示左表达式，R 表示右表达式function instance_of(L, R) &#123; var O = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; // 这里重点：当 O 严格等于 L 时，返回 true if (O === L) return true; L = L.__proto__; &#125;&#125; Array.isArray 实现12345Array.myIsArray = function (o) &#123; return Object.prototype.toString.call(Object(o)) === \"[object Array]\";&#125;;console.log(Array.myIsArray([])); // true getOwnPropertyNames 实现123456789101112131415if (typeof Object.getOwnPropertyNames !== \"function\") &#123; Object.getOwnPropertyNames = function (o) &#123; if (o !== Object(o)) &#123; throw TypeError(\"Object.getOwnPropertyNames called on non-object\"); &#125; var props = [], p; for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) &#123; props.push(p); &#125; &#125; return props; &#125;;&#125; Promise 实现实现原理：其实就是一个发布订阅者模式 构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数 then 时收集依赖，将回调函数收集到 成功/失败队列 executor 函数中调用 resolve/reject 函数 resolve/reject 函数被调用时会通知触发队列中的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209const isFunction = variable =&gt; typeof variable === 'function';// 定义Promise的三种状态常量const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';class MyPromise &#123; // 构造函数，new 时触发 constructor(handle: Function) &#123; try &#123; handle(this._resolve, this._reject); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 状态 pending fulfilled rejected private _status: string = PENDING; // 储存 value，用于 then 返回 private _value: string | undefined = undefined; // 失败队列，在 then 时注入，resolve 时触发 private _rejectedQueues: any = []; // 成功队列，在 then 时注入，resolve 时触发 private _fulfilledQueues: any = []; // resovle 时执行的函数 private _resolve = val =&gt; &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; this._status = FULFILLED; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* * 如果resolve的参数为Promise对象， * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变 * 且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; runRejected(err); &#125; ); &#125; else &#123; this._value = val; runFulfilled(val); &#125; &#125;; // 异步调用 setTimeout(run); &#125;; // reject 时执行的函数 private _reject = err =&gt; &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run); &#125;; // then 方法 then(onFulfilled?, onRejected?) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 const fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; const res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 const rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; const res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // catch 方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // finally 方法 finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125; // 静态 resolve 方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 静态 reject 方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 静态 all 方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // 返回值的集合 let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125;&#125; 防抖/节流防抖函数 onscroll 结束时触发一次，延迟执行123456789101112131415function debounce(callback, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; callback.apply(context, args); &#125;, wait); &#125;;&#125;// 使用window.onscroll = debounce(function () &#123; console.log(\"debounce\");&#125;, 1000); 节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样1234567891011121314function throttle(callback, delay) &#123; var prevTime = Date.now(); return function () &#123; var curTime = Date.now(); if (curTime - prevTime &gt; delay) &#123; callback.apply(this, arguments); prevTime = curTime; &#125; &#125;;&#125;// 使用window.onscroll = throttle(function () &#123; console.log(\"throtte\");&#125;, 1000); 函数柯里化实现其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。应用场景： 延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数） 动态创建函数 （参数不够时会返回接受剩下参数的函数） 参数复用（每个参数可以多次复用） 123456789101112const curry = (fn) =&gt; (judge = (...args) =&gt; args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg));const sum = (a, b, c, d) =&gt; a + b + c + d;const currySum = curry(sum);currySum(1)(2)(3)(4); // 10currySum(1, 2)(3)(4); // 10currySum(1)(2, 3)(4); // 10 实现简单深拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; \"[object Boolean]\": \"boolean\", \"[object Number]\": \"number\", \"[object String]\": \"string\", \"[object Function]\": \"function\", \"[object Array]\": \"array\", \"[object Date]\": \"date\", \"[object RegExp]\": \"regExp\", \"[object Undefined]\": \"undefined\", \"[object Null]\": \"null\", \"[object Object]\": \"object\", &#125;; if (obj instanceof Element) &#123; // 判断是否是dom元素，如div等 return \"element\"; &#125; return map[str];&#125;function deepCopy(original) &#123; const type = getType(original); let copy; switch (type) &#123; case \"array\": return copyArray(original, copy); case \"object\": return copyObject(original, copy); case \"function\": return copyFunction(original, copy); default: return original; &#125;&#125;function copyArray(original, copy = []) &#123; for (const [index, value] of original.entries()) &#123; copy[index] = deepCopy(value); &#125; return copy;&#125;function copyObject(original, copy = &#123;&#125;) &#123; for (const [key, value] of Object.entries(original)) &#123; copy[key] = deepCopy(value); &#125; return copy;&#125;function copyFunction(original, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(original.toString()); fn.prototype = original.prototype; return fn;&#125;const arr1 = [1, 2, [3, 4], &#123; i: 6, j: 6 &#125;, (k, m) =&gt; k + m];console.log(deepCopy(arr1));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"前端如何学数据结构与算法 - 一篇讲完关于`堆`的一切","slug":"algorithms-heap-knowledge","date":"2020-02-17T15:01:41.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"algorithms-heap-knowledge/","link":"","permalink":"http://kobin.top/algorithms-heap-knowledge/","excerpt":"对于前端来说，堆是一个不好理解的知识，但也是必不可少的知识点，是面试时经常考的重难点，本文是笔者自身学习堆的心得记录，意在能对堆有个更加系统的了解。","text":"对于前端来说，堆是一个不好理解的知识，但也是必不可少的知识点，是面试时经常考的重难点，本文是笔者自身学习堆的心得记录，意在能对堆有个更加系统的了解。 一、什么是堆在了解什么是堆前，需要先了解什么是完全二叉树。 完全二叉树 一种特殊的二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。 堆 堆是一种特殊的完全二叉树，堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。如果堆上的任意节点都大于等于子节点值，则称为 大顶堆;如果堆上的任意节点都小于等于子节点值，则称为 小顶堆; 二、堆的存储完全二叉树可以用数组存储，如果一个节点存储在数组中的下标为 i（ i从1开始） ，那么它的左子节点的存储下标为 2 * i ，右子节点的下标为 2 * i + 1，反过来，下标 i / 2 位置存储的就是该节点的父节点。完全二叉树用数组来存储是最省内存的方式。 因为堆是一种特殊的完全二叉树，所以堆也适用于上面的存储方法。 三、如何创建堆常用的创建堆方式有两种： 插入式创建：每次插入一个节点，实现一个大顶堆（或小顶堆） 原地创建：又称堆化，给定一组节点，实现一个大顶堆（或小顶堆） 下面都已创建大顶堆为例。 3.1 插入式建堆步骤： 将元素插入到队尾； 将插入节点与其父节点比较，如果插入节点大于父节点（对于大顶堆）或插入节点小于父节点（对于小顶堆），则插入节点与父节点调换位置。 如果需要调换位置，则调换后继续第2步向上比较，直到达到根节点，或者不需要调换为止。 实现代码： 12345678910111213141516171819202122232425262728//插入式建堆function MaxHeap(params) &#123; let heaps = [,]; //初始化一个堆，从1开始 this.insert = function (value) &#123; heaps.push(value); let i = heaps.length - 1; while (Math.floor(i / 2) &gt; 0 &amp;&amp; heaps[i] &gt; heaps[Math.floor(i / 2)]) &#123; [heaps[i], heaps[Math.floor(i / 2)]] = [ heaps[Math.floor(i / 2)], heaps[i], ]; // 交换 i = Math.floor(i / 2); &#125; &#125;; this.get = function (params) &#123; return heaps &#125;&#125;let maxHeap = new MaxHeap();maxHeap.insert(3);maxHeap.insert(5);maxHeap.insert(1);maxHeap.insert(2);maxHeap.insert(3);maxHeap.insert(4);let result = maxHeap.get();console.log(result);// =&gt; [empty, 5, 3, 4, 2, 3, 1] 3.2 原地建堆原地建堆有两种思路： 自下而上式堆化 ：将节点与其父节点比较，如果节点大于父节点（大顶堆）或节点小于父节点（小顶堆），则节点与父节点调整位置 自上往下式堆化 ：将节点与其左右子节点比较，如果存在左右子节点大于该节点（大顶堆）或小于该节点（小顶堆），则将子节点的最大值（大顶堆）或最小值（小顶堆）与之交换 自下而上式堆是调整节点与父节点（往上走），自上往下式堆化是调整节点与其左右子节点（往下走）。 3.2.1. 从前往后、自下而上式堆化建堆。假设有个序列： 1let arr = [,4,2,1,3,5,6]; 实现代码： 123456789101112131415161718function buildHeap(items, heapSize = 1) &#123; while (heapSize &lt; items.length - 1) &#123; heapSize++; heapify(items, heapSize); &#125;&#125;function heapify(items, i) &#123; while (Math.floor(i / 2) &gt; 0 &amp;&amp; items[i] &gt; items[Math.floor(i / 2)]) &#123; [items[i], items[Math.floor(i / 2)]] = [items[Math.floor(i / 2)], items[i]]; //利用解构方式交换元素 i = Math.floor(i / 2); &#125;&#125;let arr = [, 4, 2, 1, 3, 5, 6];buildHeap(arr);console.log(arr);// =&gt; [ empty, 6, 4, 5, 2, 3, 1 ] 3.2.2. 从后往前、自上而下式堆化建堆因为叶子节点没有子节点，不需要自上而下式堆化，所以从后往前是从序列的最后一个非叶子节点开始（即 n/2）。 假设有个序列： 1let arr = [,4,2,1,3,5,6]; 实现代码： 123456789101112131415161718192021222324252627function buildHeap(items) &#123; let heapSize = items.length - 1; // 从最后一个非叶子节点开始遍历 for (let i = Math.floor(heapSize / 2); i &gt;= 1; i--) &#123; heapify(items, heapSize, i); &#125;&#125;function heapify(items, heapSize, i) &#123; while (true) &#123; let maxIndex = i; // 用maxIndex表示 i 的最大子节点的下标 if (2 * i &lt;= heapSize &amp;&amp; items[i] &lt; items[2 * i]) &#123; maxIndex = 2 * i; &#125; if (2 * i + 1 &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[2 * i + 1]) &#123; maxIndex = 2 * i + 1; &#125; if (maxIndex === i) break; [items[maxIndex], items[i]] = [items[i], items[maxIndex]]; //交换 i 与其最大的子节点 i = maxIndex; &#125;&#125;let arr = [, 4, 2, 1, 3, 5, 6];buildHeap(arr);console.log(arr);// =&gt; [ empty, 6, 5, 4, 3, 2, 1 ] 四、堆排序由于大顶堆的堆顶点（i=1）存放的是最大值，所以可以每次让堆顶与最后一个节点交换数据，此时最大值放入了有效序列的最后一位，并且有效序列减1，有效堆依然保持完全二叉树的结构，然后堆化，成为新的大顶堆，重复此操作，直到有效堆的长度为 0，排序完成。 详细步骤： 将原序列转化成一个大顶堆； 设置堆的有效序列长度为 heapSize； 将堆顶元素与最后一个子元素（最后一个有效序列）交换，并有效序列长度减1； 堆化有效序列，使有效序列重新称为一个大顶堆； 重复以上2、3步，直到有效序列的长度为 1，排序完成； 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function heapSort(items) &#123; // 设置堆的初始有效序列长度为 items.length - 1 let heapSize = items.length - 1; // 构建大顶堆 buildHeap(items, heapSize); while (heapSize &gt; 1) &#123; // 交换堆顶元素与最后一个有效子元素 [items[1], items[heapSize]] = [items[heapSize], items[1]]; // 有效序列长度减 1 heapSize--; heapify(items, heapSize, 1); &#125; return items;&#125;/** * 原地建堆: 自上而下建堆， * @param &#123;原始序列&#125; items * @param &#123;有效序列长度&#125; heapSize */function buildHeap(items, heapSize) &#123; // 从最后一个非叶子节点开始，自上而下式堆化 for (let i = Math.floor(heapSize / 2); i &gt;= 1; --i) &#123; heapify(items, heapSize, i); &#125;&#125;/** * 这里不适合用自下而上方式，因为交换过后，有效序列里唯一没有堆化的是堆顶元素， * 所以直接从堆顶开始自上而下堆化是最快的 */function heapify(items, heapSize, i) &#123; while (true) &#123; let maxIndex = i; // 用maxIndex表示 i 的最大子节点的下标 if (2 * i &lt;= heapSize &amp;&amp; items[i] &lt; items[2 * i]) &#123; maxIndex = 2 * i; &#125; if (2 * i + 1 &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[2 * i + 1]) &#123; maxIndex = 2 * i + 1; &#125; if (maxIndex === i) break; [items[maxIndex], items[i]] = [items[i], items[maxIndex]]; //交换 i 与其最大的子节点 i = maxIndex; &#125;&#125;// 测试var items = [, 8, 3, 4, 2, 6, 7, 1, 9, 5]heapSort(items)console.log(items);// =&gt; [ empty, 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 复杂度分析： 时间复杂度： 建堆 - O(nlogn), 排序 - O(nlogn), 整体 - O(nlogn); 空间复杂度： O(1); 堆的典型应用场景： Top K 问题 什么是 Top K 问题？简单来说就是在一组数据里面找到频率出现最高的前K个数，或前K大（或前K小）的数。 下面以取前K大为例来讲解： 从数组中取前 K 个数，构造成小顶堆； 从 K+1 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。 遍历完成后，堆中的数据就是前 K 大的数据； 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function findKthLargest(nums, k) &#123; nums.splice(0, 0, null); buildHeap(nums, k); for (let i = k + 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt; nums[1]) &#123; nums[1] = nums[i]; heapify(nums, k, 1) &#125; &#125; return nums[1]&#125;/** * 原地建堆: 自上而下建堆， * 这里不适合用自下而上方式，因为交换过后，有效序列里唯一没有堆化的是堆顶元素， * 所以直接从堆顶开始自上而下堆化是最快的 * @param &#123;原始序列&#125; items * @param &#123;有效序列长度&#125; heapSize */function buildHeap(items, heapSize) &#123; // 从最后一个非叶子节点开始，自上而下式堆化 for (let i = Math.floor(heapSize / 2); i &gt;= 1; --i) &#123; heapify(items, heapSize, i); &#125;&#125;function heapify(items, heapSize, i) &#123; while (true) &#123; let minIndex = i; // 用minIndex表示 i 的最小子节点的下标 if (2 * i &lt;= heapSize &amp;&amp; items[i] &gt; items[2 * i]) &#123; minIndex = 2 * i; &#125; if (2 * i + 1 &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[2 * i + 1]) &#123; minIndex = 2 * i + 1; &#125; if (minIndex === i) break; [items[minIndex], items[i]] = [items[i], items[minIndex]]; //交换 i = minIndex; &#125;&#125;// 测试var nums = [2, 1]let kth = findKthLargest(nums, 2)console.log(kth); 复杂度分析： 时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk) 空间复杂度：O(k) 当然，topK的最简单实现是用排序，但是用堆方式的话，最大好处就是求动态数组的topK。如果用排序方式的话，每次进来一个新元素都得重新排序，这是非常不可取的，而堆方式可以有效处理这个问题。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://kobin.top/tags/%E5%A0%86/"}]},{"title":"前端如何学数据结构与算法 - JavaScript里的栈与堆","slug":"algorithms-JavaScript里的栈内存与堆内存","date":"2019-12-07T15:37:25.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"algorithms-JavaScript里的栈内存与堆内存/","link":"","permalink":"http://kobin.top/algorithms-JavaScript%E9%87%8C%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98/","excerpt":"本文主要介绍堆与栈，以及他们在JavaScript语言底层的应用。","text":"本文主要介绍堆与栈，以及他们在JavaScript语言底层的应用。 栈 定义 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。 不包含任何元素的栈称为空栈。 栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。 堆 定义 堆数据结构是一种树状结构 它的存取数据的方式，与书架相似：我们不关心书的放置顺序是怎样的，只需知道书的名字就可以取出我们想要的书 堆与栈比较 栈，线性结构，后进先出，便于管理。 堆，非线性结构，杂乱无章，方便存储和开辟内存空间。 堆是动态分配内存，内存大小不一，不会自动释放。 栈是自动分配相对固定大小的内存空间，并由系统自动释放。 JS在浏览器上的运行机制我们知道 JavaScript 是单线程的，所谓单线程，是指在 JavaScript 引擎中负责解释和执行 JavaScript 代码的线程唯一，同一时间上只能执行一件任务。 为什么是单线程？这是因为 JavaScript 可以修改 DOM 结构，如果 JavaScript 引擎线程不是单线程的，那么可以同时执行多段 JavaScript，如果这多段 JavaScript 都修改 DOM，那么就会出现 DOM 冲突。 为了避免 DOM 渲染的冲突，可以采用单线程或者死锁，JavaScript 采用了单线程方案。 但单线程有一个问题：如果任务队列里有一个任务耗时很长，导致这个任务后面的任务一直排队等待，就会发生页面卡死，严重影响用户体验。 为了解决这个问题，JavaScript 将任务的执行模式分为两种：同步和异步。 同步 123// 同步任务let a = 1console.log(a) // 1 异步 1234// 异步任务setTimeout(() =&gt; &#123; console.log(1)&#125;, 1000) 同步任务都在主线程（ JavaScript 引擎线程）上执行，会形成一个 调用栈(执行栈)； 除了主线程外，还有一个任务队列（也称消息队列），用于管理异步任务的 事件回调 ，在 调用栈 的任务执行完毕之后，系统会检查任务队列，看是否有可以执行的异步任务。 注意：任务队列存放的是异步任务的事件回调 例如上例： 123setTimeout(() =&gt; &#123; console.log(1)&#125;, 1000) 在执行这段代码时，并不会立刻打印 ，只有定时结束后（1s）才打印。 setTimeout 本身是同步执行的，放入任务队列的是它的回调函数。 下面我们重点看一下主线程上的调用栈。 调用栈调用栈是用来管理函数调用关系的一种栈结构 。 下面通过一个简单例子说明调用栈如何管理函数调用关系： 123456789var a = 1function add(a) &#123; var b = 2 let c = 3 return a + b + c&#125;// 函数调用add(a) 在执行这段代码之前，JavaScript 引擎会先创建一个全局执行上下文，包含所有已声明的函数与变量： 从图中可以看出，代码中的全局变量 a 及函数 add 保存在变量环境中。 执行上下文准备好后，开始执行全局代码，首先执行 a = 1 的赋值操作， 赋值完成后 a 的值由 undefined 变为 1，然后执行 add 函数，JavaScript 判断出这是一个函数调用，然后执行以下操作： 首先，从全局执行上下文中，取出 add 函数代码其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码，并将执行上下文压入栈中 然后，执行代码，返回结果，并将 add 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。 至此，整个函数调用执行结束了。 所以说，调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行。 如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。 如果我们从函数返回，就将它的执行上下文从栈顶弹出。 也可以说调用栈是用来管理这种执行上下文的栈，或称执行上下文栈（执行栈）。 了解了什么是调用栈，就能方便的理解栈溢出了，因为调用栈是一个栈结构，它有容量上限，当入栈的上下文过多的时候，它就会报栈溢出。 可以通过console.trace()来查看函数的调用栈路径 栈内存与堆内存JavaScript 中的变量分为基本类型和引用类型。 基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，通过按值访问，并由系统自动分配和自动释放。 这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。 JavaScript 中的 Boolean、Null、Undefined、Number、String、Symbol 都是基本类型。 引用类型（如对象、数组、函数等）是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，JavaScript 不允许直接访问堆内存中的位置，因此操作对象时，实际操作对象的引用。 JavaScript 中的 Object、Array、Function、RegExp、Date是引用类型。 示例： 12345678var a = 1function foo() &#123; var b = 2 var c = &#123; name: 'an' &#125;&#125;// 函数调用foo() 当我们要访问堆内存中的引用数据类型时: 从栈中获取该对象的地址引用; 再从堆内存中取得我们需要的数据; 复制基本类型 1234let a = 20;let b = a;b = 30;console.log(a); // 20 在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是 相互独立，互不影响的。 复制引用类型 1234let a = &#123; x: 10, y: 20 &#125;let b = a;b.x = 5;console.log(a.x); // 5 引用类型的复制，同样为新的变量 b 分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针。他们两个指向同一个堆内存空间，在堆内存中访问到的具体对象实际上是同一个。因此改变 b.x 时，a.x 也发生了变化，这就是引用类型的特性。 总结 栈内存 堆内存 存储基础数据类型 存储引用数据类型 按值访问 按引用访问 存储的值大小固定 存储的值大小不定，可动态调整 由系统自动分配内存空间 由代码进行指定分配 空间小，运行效率高 空间大，运行效率相对较低 先进后出，后进先出 无序存储，可根据引用直接获取 浅拷贝 与 深拷贝上面讲的引用类型的复制就是浅拷贝，复制得到的访问地址都指向同一个内存空间。所以修改了其中一个的值，另外一个也跟着改变了。 深拷贝：复制得到的访问地址指向不同的内存空间，互不相干。所以修改其中一个值，另外一个不会改变。 浅拷贝的优势在于性能出色，但是并不能都满足日常需求，很多时候我们需要改变拷贝数组的时候，原数组不受影响，这时候就需要用到深拷贝了。 一个通用深拷贝的实现主要思想： 通过判断拷贝对象的类型，如果是基本类型，直接赋值，如果是引用类型(array/object/function),则进入核心步骤 深拷贝的实现最重要的是处理循环引用的问题，以下用WeakMap的方式阻止循环引用:12345// 阻止循环引用if (cache.has(target)) &#123; return cache.get(target);&#125;cache.set(target, copy); 完整实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; \"[object Boolean]\": \"boolean\", \"[object Number]\": \"number\", \"[object String]\": \"string\", \"[object Function]\": \"function\", \"[object Array]\": \"array\", \"[object Date]\": \"date\", \"[object RegExp]\": \"regExp\", \"[object Undefined]\": \"undefined\", \"[object Null]\": \"null\", \"[object Object]\": \"object\", &#125;; return map[str];&#125;function deepCopy(target, cache = new WeakMap()) &#123; const type = getType(target); // 值类型数组 const valTypes = [ \"undefined\", \"null\", \"boolean\", \"number\", \"string\", \"symbol\", \"bigInt\", ]; if (valTypes.includes(type)) &#123; return target; &#125; let copy; // 初始化clone值 if (type === \"function\") &#123; copy = &#123;&#125;; &#125; else &#123; copy = new target.constructor(); &#125; // 阻止循环引用 if (cache.has(target)) &#123; return cache.get(target); &#125; cache.set(target, copy); switch (type) &#123; case \"array\": return copyArray(target, copy, cache); case \"object\": return copyObject(target, copy, cache); case \"function\": return copyFunction(target, cache); default: return target; &#125;&#125;function copyArray(target, copy = [], cache) &#123; for (const [index, value] of target.entries()) &#123; copy[index] = deepCopy(value, cache); &#125; return copy;&#125;function copyObject(target, copy = &#123;&#125;, cache) &#123; for (const [key, value] of Object.entries(target)) &#123; copy[key] = deepCopy(value, cache); &#125; return copy;&#125;function copyFunction(target, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(target.toString()); fn.prototype = target.prototype; return fn;&#125; 垃圾回收JavaScript 中的垃圾数据都是由垃圾回收器自动回收的，不需要手动释放。 回收栈空间在 JavaScript 执行代码时，主线程上会存在 ESP 指针，用来指向调用栈中当前正在执行的上下文。 当 foo 函数执行完成后，ESP 向下指向全局执行上下文，foo 函数执行上下文就变成无效的，当有新的执行上下文进来时，可以直接覆盖这块内存空间。 JavaScript 引擎通过向下移动 ESP 指针来销毁存放在栈空间中的执行上下文。 回收堆空间V8 中把堆分成新生代与老生代两个区域： 新生代：用来存放生存周期较短的小对象，一般只支持1～8M的容量 老生代：用来存放生存周期较长的对象或大对象 V8 对这两块区域使用了不同的回收器： 新生代使用副垃圾回收器 老生代使用主垃圾回收器 副垃圾回收器: 采用 Scavenge 算法及对象晋升策略来进行垃圾回收 所谓 Scavenge 算法，即把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。 新加入的对象都加入对象区域，当对象区满的时候，就执行一次垃圾回收，执行流程如下： 标记：首先要对区域内的对象进行标记（活动对象、非活动对象） 垃圾清理：将对象区的活动对象复制到空闲区域，并进行有序的排列，当复制完成后，对象区域与空闲区域进行翻转，空闲区域晋升为对象区域，对象区域为空闲区域 翻转后，对象区域是没有碎片的，此时不需要进行内存整理。 所谓对象晋升策略，因为新生代区域很小的，一般1～8M的容量，所以它很容易满，所以，JavaScript 引擎采用对象晋升策略来处理: 即只要对象经过 两次 垃圾回收之后依然继续存活，就会被晋升到老生代区域中。 主垃圾回收器： 老生代区域里有两块对象： 从新生代晋升来的存活时间久的对象 大对象（直接分配到老生代） V8 中主垃圾回收器主要采用标记-清除法进行垃圾回收。 主要流程如下： 标记：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。 垃圾清理：将所有垃圾数据清理掉 内存整理：标记-整理策略，将活动对象整理到一起 增量标记： V8 浏览器会自动执行垃圾回收，但由于 垃圾回收 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会造成页面的卡顿，影响用户体验，所以 V8 采用增量 标记算法回收： 即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。 总结本文内容回顾： 栈与堆的定义与对比： 栈：线性结构，LIFO 堆：非线性结构，杂乱无章，方便存储与开辟内存空间 以及JS的运行机制： 调用栈 任务队列 调用栈 调用栈是 JavaScript 用来管理函数执行上下文的一种数据结构，它记录了当前函数执行的位置，哪个函数正在被执行 栈内存与堆内存 栈内存： 基本类型（Boolean、Null、Undefined、Number、String、Symbol） 堆内存： 引用类型（Object、Array、Function、RegExp、Date） 浅拷贝 与 深拷贝 垃圾回收 回收栈空间： JavaScript 引擎通过向下移动 ESP 指针来销毁存放在栈空间中的执行上下文。 回收堆空间： 副垃圾回收器 与 主垃圾回收器 的区别 增量标记： 解决阻塞主进程问题","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://kobin.top/tags/%E6%A0%88/"},{"name":"堆","slug":"堆","permalink":"http://kobin.top/tags/%E5%A0%86/"}]},{"title":"前端如何学数据结构与算法 - 线性表","slug":"algorithms-线性表基础汇总","date":"2019-12-05T14:25:24.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"algorithms-线性表基础汇总/","link":"","permalink":"http://kobin.top/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/","excerpt":"数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。 本系列所有示例均采用JavaScript，旨在入门数据结构与算法。 本节主要是讲解下基础数据结构 - 线性表 相关的内容。","text":"数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。 本系列所有示例均采用JavaScript，旨在入门数据结构与算法。 本节主要是讲解下基础数据结构 - 线性表 相关的内容。 线性表 与 非线性表线性表（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是典型线性表结构。 非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。 数组 定义数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。数组的索引是从 0 开始的。 特点数组是用一组连续的内存空间来存储的。 所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。 低效的插入和删除。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n) 实现JavaScript 原生支持数组，而且提供了很多操作方法，JavaScript数组支持的方法可见下表： 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 entries() 返回数组的可迭代对象。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 from() 通过给定的对象中创建一个数组。 includes() 判断一个数组是否包含一个指定的值。 indexOf() 搜索数组中的元素，并返回它所在的位置。 isArray() 判断对象是否为数组。 join() 把数组的所有元素放入一个字符串。 keys() 返回数组的可迭代对象，包含原始数组的键(key)。 lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 栈 定义 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。 在栈里，新元素都靠近栈顶，旧元素都接近栈底。 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。 不包含任何元素的栈称为空栈。 栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344function Stack() &#123; this.data = []; /** * 添加一个（或几个）新元素到栈顶。 */ this.push = function (element) &#123; this.data.push(element); &#125;; /** * 移除栈顶的元素，同时返回被移除的元素。 */ this.pop = function () &#123; return this.data.pop(); &#125;; /** * 返回栈顶的元素，不对栈做任何修改。 */ this.peek = function () &#123; return this.data[this.data.length - 1]; &#125;; /** * 如果栈里没有任何元素就返回 true，否则返回 false */ this.isEmpty = function () &#123; return this.data.length === 1; &#125;; /** * 移除栈里的所有元素 */ this.clear = function () &#123; this.data = []; &#125;; /** * 返回栈里的元素个数。 */ this.size = function () &#123; return this.data.length; &#125;; // 打印栈里的元素 this.print = function () &#123; console.log(this.data.toString()); &#125;;&#125; 使用场景 举一个判断回文的例子： 12345678910111213141516function isPalindrome(word) &#123; var s = new Stack(); for (var i = 0; i &lt; word.length; i++) &#123; s.push(word[i]); &#125; var rword = \"\"; while (s.length() &gt; 0) &#123; rword += s.pop(); &#125; return word == rword;&#125;console.log(isPalindrome(\"level\")); // trueconsole.log(isPalindrome(\"1001\")); // trueconsole.log(isPalindrome(\"word\")); // false 队列 定义 队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。 队列在尾部添加新元素，并从顶部移除元素。 最新添加的元素必须排在队列的末尾。 队列只有 入队 push() 和出队 pop()。 队列又可以细分为普通队列、优先队列、循环队列。 普通队列 实现 123456789101112131415161718192021222324252627282930313233343536373839// Queue类function Queue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element) &#123; this.data.push(element); &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; console.log(this.data.toString()); &#125;;&#125; 优先队列 定义优先队列中元素的添加和移除会根据优先级来处理 场景优先队列一个典型的场景就是机场登机，头等舱和商务舱乘客的优先级要高于经济舱乘客。 分类 最小优先队列，优先级值越小的元素在越前面 最大优先队列，优先级值越大的元素在越前面 实现实现最小优先队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// MinPriorityQueue类function MinPriorityQueue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element, priority) &#123; //若队列为空则直接将元素入列，否则需要比较该元素与其他元素的优先级 if (this.isEmpty()) &#123; this.data.push(&#123; element, priority &#125;); &#125; else &#123; let added = false; for (let i = 0, length = this.size(); i &lt; length; i++) &#123; if (priority &lt; this.data[i].priority) &#123; this.data.splice(i, 0, &#123; element, priority &#125;); added = true; break; &#125; &#125; if (!added) &#123; this.data.push(&#123; element, priority &#125;); &#125; &#125; &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; const info = this.data.map((item) =&gt; `$&#123;item.priority&#125;: $&#123;item.element&#125;`); console.log(info.toString()); &#125;;&#125; 实现最大优先队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// MaxPriorityQueue类function MaxPriorityQueue() &#123; this.data = []; // 向队列尾部添加元素 this.enqueue = function (element, priority) &#123; //若队列为空则直接将元素入列，否则需要比较该元素与其他元素的优先级 if (this.isEmpty()) &#123; this.data.push(&#123; element, priority &#125;); &#125; else &#123; let added = false; for (let i = 0, length = this.size(); i &lt; length; i++) &#123; if (priority &gt; this.data[i].priority) &#123; this.data.splice(i, 0, &#123; element, priority &#125;); added = true; break; &#125; &#125; if (!added) &#123; this.data.push(&#123; element, priority &#125;); &#125; &#125; &#125;; // 移除队列的第一个元素，并返回被移除的元素 this.dequeue = function () &#123; return this.data.shift(); &#125;; // 返回队列的第一个元素 this.front = function () &#123; return this.data[0]; &#125;; // 判断是否为空队列 this.isEmpty = function () &#123; return this.data.length === 0; &#125;; // 获取队列的长度 this.size = function () &#123; return this.data.length; &#125;; // 清空队列 this.clear = function () &#123; this.data = []; &#125;; // 打印队列里的元素 this.print = function () &#123; const info = this.data.map((item) =&gt; `$&#123;item.priority&#125;: $&#123;item.element&#125;`); console.log(info.toString()); &#125;;&#125; 循环队列循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到最后一个孩子为最后胜利者。 基于上面的普通队列，实现这个游戏： 1234567891011121314151617181920212223242526272829303132333435// 实现击鼓传花function hotPotato(nameList, num) &#123; var queue = new Queue(); for (var i = 0; i &lt; nameList.length; i++) &#123; queue.enqueue(nameList[i]); &#125; var eliminated = \"\"; while (queue.size() &gt; 1) &#123; // 循环 num 次，队首出来去到队尾 for (var i = 0; i &lt; num; i++) &#123; queue.enqueue(queue.dequeue()); &#125; // 循环 num 次过后，移除当前队首的元素 eliminated = queue.dequeue(); console.log(`$&#123;eliminated&#125; 在击鼓传花中被淘汰！`); &#125; // 最后只剩一个元素 return queue.dequeue();&#125;// 测试var nameList = [\"张三\", \"李四\", \"王五\", \"马六\", \"牛七\"];var winner = hotPotato(nameList, 5);console.log(`最后的胜利者是：$&#123;winner&#125;`);// =&gt; 牛七 在击鼓传花中被淘汰！// =&gt; 张三 在击鼓传花中被淘汰！// =&gt; 王五 在击鼓传花中被淘汰！// =&gt; 马六 在击鼓传花中被淘汰！// =&gt; 最后的胜利者是：李四 链表 定义链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 指针 将 零散的内存块 串连起来的。 每个元素由一个存储元素本身的 节点和一个指向下一个元素的 指针组成。 简单的链接结构图: 上图中，data 中保存着数据，next 保存着下一个链表的指针。 上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。需要注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。 特点 低效的访问： 链表是通过指针将零散的内存块串连起来的。 所以链表不支持 随机访问，如果要找特定的项，只能从头开始遍历，直到找到某个项。 所以访问的时间复杂度为 O(n)。 高效的插入和删除。 链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移节点，因为链表的存储空间本身就不是连续的，只需要考虑相邻节点的指针改变。 所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。 分类常见列表可以分为三类： 单向链表 双向链表 循环链表 单向链表 定义 由于链表的起始点的确定比较麻烦，因此很多链表的实现都会在链表的最前面添加一个特殊的节点，称为 头节点，表示链表的头部。 特点 只能单向遍历，操作灵活性不高 实现 需要实现的以下常用操作： 方法名 描述 append(element) 尾部添加元素。 insert(position, element) 特定位置插入一个新的项。 removeAt(position) 特定位置移除一项。 remove(element) 移除一项。 indexOf(element) 返回元素在链表中的索引。如果链表中没有该元素则返回 -1。 isEmpty() 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false。 size() 返回链表包含的元素个数，与数组的 length 属性类似。 getHead() 返回链表的第一个元素。 toString() 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值。 print() 打印链表的所有元素。 list() 获取整个链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157// 单链表function SinglyLinkedList() &#123; // 节点 function Node(element) &#123; this.element = element; // 当前节点的元素 this.next = null; // 下一个节点指针 &#125; let length = 0; // 链表的长度 let head = null; // 链表的头节点 // 向链表尾部添加一个新的节点 this.append = function (element) &#123; let node = new Node(element); // 判断是否为空链表 if (head === null) &#123; // 是空链表，就把当前节点作为头部节点 head = node; &#125; else &#123; let currentNode = head; // 从 head 开始一直找到最后一个 node while (currentNode.next) &#123; // 后面还有 node currentNode = currentNode.next; &#125; // 把最后一个节点的 next 指针指向新的节点 currentNode.next = node; &#125; // 链表的长度加 1 length++; &#125;; // 向链表特定位置插入一个新节点 this.insert = function (position, element) &#123; if (position &lt; 0 || position &gt; length) &#123; // 越界 return false; &#125; else &#123; let node = new Node(element); let index = 0; let currentNode = head; let previousNode; // 在最前插入节点 if (position === 0) &#123; node.next = currentNode; head = node; &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性 previousNode.next = node; node.next = currentNode; &#125; length++; return true; &#125; &#125;; // 从链表的特定位置移除一项 this.removeAt = function (position) &#123; if ((position &lt; 0 || position &gt;= length) || length === 0) &#123; // 越界 return false; &#125; else &#123; let currentNode = head; let index = 0; let previousNode; if (position === 0) &#123; head = currentNode.next; &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点 previousNode.next = currentNode.next; &#125; length--; return true; &#125; &#125;; // 从链表中移除指定项 this.remove = function (element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在链表的索引，如果链表中没有该元素则返回 -1 this.indexOf = function (element) &#123; let currentNode = head; let index = 0; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; index++; currentNode = currentNode.next; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false this.isEmpty = function () &#123; return length === 0; &#125;; // 返回链表包含的元素个数，与数组的 length 属性类似 this.size = function () &#123; return length; &#125;; // 获取链表头部元素 this.getHead = function () &#123; return head.element; &#125;; // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值 this.toString = function (cur) &#123; let currentNode = cur || head; let string = \"\"; while (currentNode) &#123; string += \",\" + currentNode.element; currentNode = currentNode.next; &#125; return string.slice(1); &#125;; // 打印链表数据 this.print = function (cur) &#123; console.log(this.toString(cur)); &#125;; // 获取整个链表 this.list = function () &#123; console.log(\"head: \", head); return head; &#125;;&#125; 双向链表上面说的单向链表只有一个方向，节点只有一个后继指针 next 指向后面的节点。 最为对比，双向链表就有两个方向的指针，每个节点不止有一个后继指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的节点。 与单向列表比较 内存空间比单向链表大，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址 可以双向操作，灵活性更高，查找/插入/删除更高效 实现在实现了单向链表后，双向链表就没那么难了，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216// 创建双向链表 DoublyLinkedList 类function DoublyLinkedList() &#123; function Node(element) &#123; this.element = element; //当前节点的元素 this.next = null; //下一个节点指针 this.previous = null; //上一个节点指针 &#125; let length = 0; // 链表长度 let head = null; // 链表头部 let tail = null; // 链表尾部 // 向链表尾部添加一个新的项 this.append = function (element) &#123; let node = new Node(element); let currentNode = tail; // 判断是否为空链表 if (currentNode === null) &#123; // 空链表 head = node; tail = node; &#125; else &#123; currentNode.next = node; node.previous = currentNode; tail = node; &#125; length++; &#125;; // 向链表特定位置插入一个新的项 this.insert = function (position, element) &#123; if (position &lt; 0 || position &gt; length) &#123; // 越界 return false; &#125; else &#123; let node = new Node(element); let index = 0; let currentNode = head; let previousNode; if (position === 0) &#123; //在头部添加 if (!head) &#123; head = node; tail = node; &#125; else &#123; node.next = currentNode; currentNode.previous = node; head = node; &#125; &#125; else if (position === length) &#123; //在末尾添加 this.append(element); return true; &#125; else if (length - 1 - position &gt; position) &#123; //position离head更近 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = node; node.next = currentNode; node.previous = previousNode; currentNode.previous = node; &#125; else &#123; //position离tail更近，则从tail开始向前查找 index = length - 1; currentNode = tail; while (index &gt; position) &#123; index--; currentNode = currentNode.previous; previousNode = currentNode.previous; &#125; previousNode.next = node; node.next = currentNode; node.previous = previousNode; currentNode.previous = node; &#125; length++; return true; &#125; &#125;; // 从链表的特定位置移除一项 this.removeAt = function (position) &#123; if (position &lt; 0 || position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; let currentNode = head; let index = 0; let previousNode; if (position === 0) &#123; // 移除第一项 if (length === 1) &#123; head = null; tail = null; &#125; else &#123; head = currentNode.next; head.previous = null; &#125; &#125; else if (position === length - 1) &#123; // 移除最后一项 if (length === 1) &#123; head = null; tail = null; &#125; else &#123; currentNode = tail; tail = currentNode.previous; tail.next = null; &#125; &#125; else if (length - 1 - position &gt; position) &#123; //position离head更近 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; currentNode.next.previous = previousNode; &#125; else &#123; //position离tail更近，则从tail开始向前查找 index = length - 1; currentNode = tail; while (index &gt; position) &#123; index--; currentNode = currentNode.previous; previousNode = currentNode.previous; &#125; previousNode.next = currentNode.next; currentNode.next.previous = previousNode; &#125; length--; return true; &#125; &#125;; // 从链表中移除指定项 this.remove = function (element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在链表的索引，如果链表中没有该元素则返回 -1 this.indexOf = function (element) &#123; let currentNode = head; let index = 0; let currentNode2 = tail; let index2 = length - 1; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; if (currentNode2.element === element) &#123; return index2; &#125; index++; currentNode = currentNode.next; index2--; currentNode2 = currentNode2.previous; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true ，如果链表长度大于 0 ，返回 false this.isEmpty = function () &#123; return length == 0; &#125;; // 返回链表包含的元素个数，与数组的 length 属性类似 this.size = function () &#123; return length; &#125;; // 获取链表头部元素 this.getHead = function () &#123; return head.element; &#125;; // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值 this.toString = function () &#123; let currentNode = head; let string = \"\"; while (currentNode) &#123; string += \",\" + currentNode.element; currentNode = currentNode.next; &#125; return string.slice(1); &#125;; this.print = function () &#123; console.log(this.toString()); &#125;; // 获取整个链表 this.list = function () &#123; console.log(\"head: \", head); return head; &#125;;&#125; 单向链表 VS 双向链表 性能对比1234567891011121314151617let singlyList = new SinglyLinkedList();console.time(\"singlyList-time\");for (let i = 0; i &lt; 100000; i++) &#123; singlyList.insert(i, \"Tom\" + i);&#125;console.timeEnd(\"singlyList-time\");let doublyList = new DoublyLinkedList();console.time(\"doublyLinked-time\");for (let i = 0; i &lt; 100000; i++) &#123; doublyList.insert(i, \"Tom\" + i);&#125;console.timeEnd(\"doublyList-time\");// &gt;&gt; singlyList-time: 34532.815ms// &gt;&gt; doublyList-time: 64.111ms 结论： 同样插入100000条数据，双向链表的速度优势明显； 循环链表循环链表是一种特殊的单链表。 循环链表和单链表相似，节点类型都是一样。 唯一的区别是，循环链表的尾节点指向了头节点，形成了一个循环。如下图所示: 实现基于单向链表实现循环链表，主要区别在于要将循环链表的尾节点指向头节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// 循环链表function CircularLinkedList() &#123; // 节点 function Node(element) &#123; this.element = element; // 当前节点的元素 this.next = null; // 下一个节点指针 &#125; let length = 0; // 链表的长度 let head = null; // 链表的头节点 let tail = null; // 链表的尾节点 // 向链表尾部添加一个新的节点 this.append = function (element) &#123; let node = new Node(element); // 判断是否为空链表 if (head === null) &#123; // 是空链表，就把当前节点作为头部节点 head = node; head.next = head; tail = head;//区别于单向链表的点 &#125; else &#123; let currentNode = head; // 从 head 开始一直找到最后一个 node while (currentNode.next !== head) &#123; // 后面还有 node currentNode = currentNode.next; &#125; // 把最后一个节点的 next 指针指向新的节点 currentNode.next = node; // 把新插入的节点的next指向head node.next = head; tail = node; // 把新加入的节点设为尾节点 &#125; // 链表的长度加 1 length++; &#125;; // 向链表特定位置插入一个新节点 this.insert = function (position, element) &#123; if (position &lt; 0 || position &gt; length) &#123; // 越界 return false; &#125; else if (length === 0) &#123; //空链表时使用append插入第一个节点 this.append(element); &#125; else &#123; let node = new Node(element); let index = 0; let currentNode = head; let previousNode; // 在最前插入节点 if (position === 0) &#123; node.next = head; head = node; tail.next = head; //区别于单向链表的点 &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性 previousNode.next = node; node.next = currentNode; &#125; length++; return true; &#125; &#125;; // 从链表的特定位置移除一项 this.removeAt = function (position) &#123; if (position &lt; 0 || position &gt;= length || length === 0) &#123; // 越界 return false; &#125; else &#123; let currentNode = head; let index = 0; let previousNode; if (position === 0) &#123; head = head.next; tail.next = head; //区别于单向链表的点 &#125; else &#123; // 循环找到位置 while (index &lt; position) &#123; index++; previousNode = currentNode; currentNode = currentNode.next; &#125; // 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点 previousNode.next = currentNode.next; &#125; length--; return true; &#125; &#125;; // 从链表中移除指定项 this.remove = function (element) &#123; let index = this.indexOf(element); return this.removeAt(index); &#125;; // 返回元素在链表的索引，如果链表中没有该元素则返回 -1 this.indexOf = function (element) &#123; let currentNode = head; let index = 0; while (currentNode) &#123; if (currentNode.element === element) &#123; return index; &#125; index++; currentNode = currentNode.next; &#125; return -1; &#125;; // 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false this.isEmpty = function () &#123; return length === 0; &#125;; // 返回链表包含的元素个数，与数组的 length 属性类似 this.size = function () &#123; return length; &#125;; // 获取链表头部元素 this.getHead = function () &#123; return head.element; &#125;; // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值 this.toString = function () &#123; let currentNode = head; let string = \"\"; let index = 0; while (currentNode &amp;&amp; index &lt; length) &#123; string += \",\" + currentNode.element; currentNode = currentNode.next; index++; &#125; return string.slice(1); &#125;; // 打印链表数据 this.print = function (cur) &#123; console.log(this.toString(cur)); &#125;; // 获取整个链表 this.list = function () &#123; console.log(\"head: \", head); return head; &#125;;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Nodejs读取控制台输入(stdin)的方法总结","slug":"node-node-stdin","date":"2019-09-23T14:35:46.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"node-node-stdin/","link":"","permalink":"http://kobin.top/node-node-stdin/","excerpt":"在用 Nodejs 写 CLI 应用或者做OJ的时候经常会遇到要从 stdin 读取输入的情况，这里总结了几种不依赖第三方库来按行读取输入的方法。","text":"在用 Nodejs 写 CLI 应用或者做OJ的时候经常会遇到要从 stdin 读取输入的情况，这里总结了几种不依赖第三方库来按行读取输入的方法。 Readline基础使用 优点：简洁方便，平台无关。可用于编写 REPL 应用。 缺点：某些 OJ 的 node 版本可能不支持readline，对此请参考OJ专用的方法。 123456789require(\"readline\") .createInterface(&#123; input: process.stdin, output: process.stdout, &#125;) .on(\"line\", function (line) &#123; console.log(\"the input is: \", line.trim()); this.close(); &#125;); 实现互动问答 优点：便于引导用户正确输入。 1234567891011121314151617181920212223242526const rl = require(\"readline\").createInterface(&#123; input: process.stdin, output: process.stdout,&#125;);const wait = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));const question = (query) =&gt; new Promise((resolve) =&gt; rl.question(query, (answer) =&gt; resolve(answer)));(async () =&gt; &#123; let answer = await question(\"你觉得node是最棒的吗？ \"); console.log(`您的答案是：$&#123;answer&#125;`); answer = await question(\"async/await好不好用啊 \"); console.log(`您的答案是：$&#123;answer&#125;`); answer = await question(\"等待多少秒继续执行？ \"); rl.pause(); await wait(parseInt(answer) * 1000); rl.resume(); while ((await question(\"输入bye退出 \")).trim() !== \"bye\"); console.log(\"Good day.\"); rl.close();&#125;)(); process.stdin1234567891011121314151617181920process.stdin.setEncoding(\"utf8\");process.stdin.on(\"readable\", () =&gt; &#123; var chunk = process.stdin.read(); if (typeof chunk === \"string\") &#123; chunk = chunk.slice(0, -1); process.stdout.write(`stringLength:$&#123;chunk.length&#125;\\n`); &#125; if (chunk === \"\") &#123; process.stdin.emit(\"end\"); return; &#125; if (chunk !== null) &#123; process.stdout.write(`data: $&#123;chunk&#125;\\n`); &#125;&#125;);process.stdin.on(\"end\", () =&gt; &#123; process.stdout.write(\"end\");&#125;);","categories":[{"name":"node","slug":"node","permalink":"http://kobin.top/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://kobin.top/tags/node/"},{"name":"stdin","slug":"stdin","permalink":"http://kobin.top/tags/stdin/"}]},{"title":"promise高级用法","slug":"javascript-promise高级用法","date":"2019-08-02T22:49:39.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-promise高级用法/","link":"","permalink":"http://kobin.top/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/","excerpt":"对于Promise高级用法的使用汇总，包括多个promise串行执行、多个promise并行执行以及限制并行等","text":"实现多个promise串行执行在 async/await 以前 Promise 串行执行还是比较麻烦的，除了依赖 async、promise-fun 等工具库，我们还可以使用 Array.prototype.reduce() 自己实现一个简单的串行Promise了： 123456789/** * 核心代码 **/function runPromiseByQueue(myPromises) &#123; myPromises.reduce( (previousPromise, nextPromise) =&gt; previousPromise.then(() =&gt; nextPromise()), Promise.resolve() );&#125; 当上一个 Promise 开始执行（previousPromise.then），当其执行完毕后再调用下一个 Promise，并作为一个新 Promise 返回，下次迭代就会继续这个循环。 举个例子： 12345678910111213141516171819const createPromise = (time, id) =&gt; () =&gt; new Promise((solve) =&gt; &#123; console.time(\"time\" + id); setTimeout(() =&gt; &#123; console.log(\"promise\", id); console.timeEnd(\"time\" + id); if (id == 3) &#123; console.timeEnd(\"timeall\"); &#125; solve(); &#125;, time); &#125;);console.time(\"timeall\");runPromiseByQueue([ createPromise(3000, 1), createPromise(2000, 2), createPromise(1000, 3),]); 最后的输出结果如下： 说明确实是串行依次执行了三个promise。 实现多个promise并行执行这个目前ES官方已经实现了promise.all/promise.allSettled/promise.race等方法，以promise.all()为例： 12345678910const promise1 = Promise.resolve(3);const promise2 = 42;const promise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, 'foo');&#125;);Promise.all([promise1, promise2, promise3]).then((values) =&gt; &#123; console.log(values);&#125;);// expected output: Array [3, 42, \"foo\"] Promise.all可以保证，promises数组中所有promise对象都达到resolve状态，才执行then回调。 那么如果promises数组是包含几十个甚至几百个http请求，直接用Promise.all的话，会瞬间发出所有的http请求，造成请求拥堵甚至失败。 这时候就需要对Promise.all做并发限制。 promise.all并行限制首先需要明白的是，promise并不是在调用Promise.all才执行，而是在实例化promise对象的时候就执行了，在理解这一点的基础上，就可以从promise实例化上下手实现并发限制。具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940/** * Promise并发限制 * @param &#123;Array&#125; array * @param &#123;Number&#125; poolLimit */function LimitPromiseAll(array, poolLimit) &#123; let i = 0; //待执行元素的数组下标 const results = []; // promise.all的promises数组 const executing = []; // 存放正在执行 const enqueue = function () &#123; // 边界处理，array为空数组 if (i === array.length) &#123; return Promise.resolve(); &#125; // 每调一次enqueue，初始化一个promise const fn = array[i++]; // 如果curPromise不是Promise对象。则转成Promise 对象 // 等同于 const p = Promise.resolve(fn()); const p = Promise.resolve().then(() =&gt; fn()); // 放入promises数组 results.push(p); // promise执行完毕，从executing数组中删除 const e = p.then((res) =&gt; &#123; executing.splice(executing.indexOf(e), 1); &#125;); //正在执行的promise, 插入executing数组 executing.push(e); // 当executing数组中promise数量低于poolLimit，就实例化新的promise并执行, // 否则调用promise.race()获取到最快执行完成的promise（将其从executing数组删除，便可继续后续执行） let r = Promise.resolve(); if (executing.length &gt;= poolLimit) &#123; r = Promise.race(executing); &#125; // 递归，直到遍历完array return r.then(() =&gt; enqueue()); &#125;; return enqueue().then(() =&gt; Promise.all(results));&#125; 使用例子： 1234567891011121314151617181920console.time(\"all-time\");const timeout = (i) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(i), i));LimitPromiseAll( [ timeout.bind(null, 1000), timeout.bind(null, 5000), timeout.bind(null, 2000), timeout.bind(null, 4000), ], 2).then((res) =&gt; &#123; console.log(res); console.timeEnd(\"all-time\");&#125;);/**输出： [ 1000, 5000, 2000, 4000 ] all-time: 7037.285ms **/ 其实，目前社区里已经有一些开源包实现了这个功能，比如async-pool、es6-promise-pool、p-limit。上述实现代码也是参考async-pool的实现。 使用Promise实现fetch超时处理因为fetch默认没有请求超时设置，以及中断请求操作，在这里我们尝试使用Promise结合AbortController封装一个简单的请求超时和中断请求的fetch。 AbortController接口代表一个控制器对象，允许你在需要时中止一个或多个DOM请求目前IE外的主流浏览器基本都实现了AbortController功能； AbortController的浏览器兼容情况： 核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637function TimeoutFetch(params) &#123; this.controller = new AbortController(); //实例化AbortController this.signal = this.controller.signal; //signal用来 abort 请求 this.timeout = 5000; //默认超时时间&#125;/** * 设置超时时间 */TimeoutFetch.prototype.setTimeout = function (ms) &#123; this.timeout = ms;&#125;;/** * 封装fetch请求 */TimeoutFetch.prototype.fetch = function (url, data = &#123;&#125;) &#123; const timeoutPromise = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; code: 1, msg: `timeout of $&#123;this.timeout&#125;ms`, &#125;); this.controller.abort(); &#125;, this.timeout); &#125;); const fetchPromise = fetch(url, &#123; signal: this.signal, //设置信号 ...data, &#125;); return Promise.race([fetchPromise, timeoutPromise]);&#125;;/** * 手动中断请求 */TimeoutFetch.prototype.abort = function () &#123; this.controller.abort();&#125;; 使用例子： 12345const timeoutFetch = new TimeoutFetch();timeoutFetch.setTimeout(30);timeoutFetch.fetch(\"http://localhost/data\").then((res) =&gt; &#123; console.log(res);&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"},{"name":"promise","slug":"promise","permalink":"http://kobin.top/tags/promise/"}]},{"title":"通过iframe下载文件如何判断下载完成","slug":"javascript-iframe-download-complete","date":"2019-07-06T22:24:20.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-iframe-download-complete/","link":"","permalink":"http://kobin.top/javascript-iframe-download-complete/","excerpt":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。","text":"问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = \"http://www.example.com/file.zip\";var iframe = document.createElement(\"iframe\");iframe.src = url;iframe.style.display = \"none\";iframe.onload = function () &#123; console.debug(\"start downloading...\"); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 这里说一下 Content-disposition： Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。 解决思路二：添加 header 配置123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(\"X-Content-Type-Options\", \"nosniff\");// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(\"X-Frame-Options\", \"deny\"); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(\"iframedownload\"); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == \"complete\" || iframeDoc.readyState == \"interactive\" ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"iframe","slug":"iframe","permalink":"http://kobin.top/tags/iframe/"},{"name":"download","slug":"download","permalink":"http://kobin.top/tags/download/"}]},{"title":"nginx初试","slug":"others-nginx-basic","date":"2019-05-25T18:35:46.000Z","updated":"2020-10-14T10:18:00.457Z","comments":true,"path":"others-nginx-basic/","link":"","permalink":"http://kobin.top/others-nginx-basic/","excerpt":"“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。” 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。","text":"“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。” 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。 一、初试 Nginx想要成为一个合格的大前端，又怎能不会 Nginx 呢？ Nginx 从 2004 年发展至今，从一开始的完善沉淀，再迅速蹿升为“网红”，再到现在占服务器市场中接近 1/3 份额，成为互联网网站搭建的必选技术之一。发展可谓相当迅速，之所以能取得如此成就，主要还是相对于其他 HTTP 服务器其有着不可替代的优势： 支持海量高并发：采用 IO 多路复用 epoll。官方测试 Nginx 能够支持 5 万并发链接，实际生产环境中可以支撑 2-4 万并发连接数。 内存消耗少：在主流的服务器中 Nginx 目前是内存消耗最小的了，比如我们用 Nginx+PHP，在 3 万并发链接下，开启 10 个 Nginx 进程消耗 150M 内存。 免费使用可以商业化：Nginx 为开源软件，采用的是 2-clause BSD-like 协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 而对于前端童鞋，在实际工作上，更倾向于用 Nodejs 来搭建服务器，进而实现一些需求，对 Nginx 有天然的疏远感。的确，Nginx 中的绝大部分功能，如果单纯的使用 Node.js 也可以满足和实现。但实际上，Nginx 和 Node.js 并不冲突，都有自己擅长的领域：Nginx 更擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长于上层具体业务逻辑的处理。如果将两者组合一起，则可以更加助力前端开发。 开始动手之前先交代下具体的系统环境： 系统环境说明：服务器：阿里云 ECS操作系统： CentOS 7.4 64 位Nginx 版本：nginx/1.16.1 二、Nginx 的安装首先可以查看下系统的 yum 源下是否有可用的 Nginx 包 1yum list | grep nginx 如果结果类似如图内容，说明 yum 源是存在的 如果不存在或者没有需要的 Nginx 版本，则可以自己配一个 yum 源。 打开终端，输入 1vim /etc/yum.repos.d/nginx.repo 往里面添加如下脚本： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/$&#123;OS&#125;/$&#123;OSRELEASE&#125;/$basearch/gpgcheck=0enabled=1 需要注意：OS: 操作系统名称，如：centosOSRELEASE: 操作系统版本，如： 7对应的 baseurl: baseurl=http://nginx.org/packages/centos/7/$basearch/ 保存修改后，就可以安装 Nginx 了，安装命令： 1yum install nginx 安装完成后查看安装的 Nginx 版本: 1nginx -v 三、Nginx 基本配置安装完 Nginx 后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看： 1rpm -ql nginx rpm 是 linux 的 rpm 包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到 nginx 的所有安装位置了。 下面重点罗列下一些重要的文件 nginx.conf nginx.conf 文件是 Nginx 总配置文件，在我们搭建服务器时经常调整的文件。 进入 etc/nginx 目录下，然后用 vim 进行打开 12cd /etc/nginxvim nginx.conf 下面是文件的详细注释: 12345678910111213141516171819202122232425262728293031323334#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件&#125; default.conf进入 conf.d 目录，打开 default.conf，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 四、Nginx 常用操作启动 Nginx 服务 Nginx 直接启动（CentOS7.4 以上版本） 1nginx 使用 systemctl 命令启动 1systemctl start nginx.service 查看服务运行状态 1ps aux | grep nginx 关停 Nginx 服务 立即停止服务 1nginx -s stop 这种方法比较强硬，无论进程是否在工作，都直接停止进程。 从容停止服务 1nginx -s quit 这种方法较 stop 相比就比较温和一些了，需要进程完成当前工作后再停止。 killall 方法杀死进程 1killall nginx 这种方法也是比较野蛮的，直接杀死进程。 systemctl 停止 1systemctl stop nginx.service 重启 Nginx 服务1systemctl restart nginx.service 重新载入配置文件在重新编写或者修改 Nginx 的配置文件后，需要作一下重新载入，这时候可以用这个命令。 1nginx -s reload 查看端口号如果 80 端口被占用，可以使用此命令查看端口占用情况 1netstat -tlnp 80 五、自定义错误页面以及访问控制 多错误指向一个页面 1error_page 500 502 503 504 /50x.html; 单独为错误置顶处理方式 1error_page 404 /404_error.html; 把错误码换成一个地址 1error_page 404 http://kobin.top; 简单实现访问控制 有时候我们的服务器只允许特定主机访问，比如内部 OA 系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些 IP 访问，我们可以直接在 location 里进行配置。 可以直接在 default.conf 里进行配置。 1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 指令优先级 1234location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置表示只允许45.76.202.231进行访问，其他的 IP 是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？ 会发现所有的 IP 都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。 复杂访问控制权限匹配 在工作中，访问权限的控制需求更加复杂，例如，对于网站下的 img（图片目录）是运行所有用户访问，但对于网站下的 admin 目录则只允许公司内部固定 IP 访问。这时候仅靠 deny 和 allow 这两个指令，是无法实现的。我们需要 location 块来完成相关的需求匹配。 上面的需求，配置代码如下： 123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; 使用正则表达式设置访问权限 只有精确匹配(=)有时是完不成我们的工作任务的，比如现在我们要禁止访问所有 php 的页面，php 的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。 代码如下： 123location ~\\.php$ &#123; deny all; &#125; 这样我们再访问的时候就不能访问以 php 结尾的文件了。是不是让网站变的安全很多了那？ 六、Nginx 配置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供 Web 服务，并且互不干扰。用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上。可以大大节约服务器成本与维护成本。 基于端口号配置虚拟主机 基于端口号来配置虚拟主机，算是 Nginx 中最简单的一种方式了。原理就是 Nginx 监听多个端口，根据不同的端口号，来区分不同的网站 我习惯在 conf.d 里新建一个配置文件来配置新的虚拟主机，但也可以配置在主配置 etc/nginx/nginx.conf里，也可以配置在etc/nginx/conf.d/default.conf里。 12345678server&#123; listen 8088; server_name localhost; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于 IP 的虚拟主机 基于 IP 和基于端口的配置几乎一样，只是把server_name选项，配置成 IP 就可以了。 12345678server&#123; listen 80; server_name 112.74.164.244; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于域名的虚拟主机 域名设置虚拟主机也非常简单，主要操作的是配置文件的 server_name 项 12345678910111213141516server&#123; listen 80; server_name nginx.kobin.com; location / &#123; root /usr/share/nginx/html/html; index index.html index.htm; &#125;&#125;server&#123; listen 80; server_name nginx2.kobin.com; location / &#123; root /usr/share/nginx/html/html8001; index index.html index.htm; &#125;&#125; 七、Nginx 反向代理的设置什么是反向代理？ 互联网应用基本都基于 CS 基本结构，即 client 端和 server 端。代理其实就是在 client 端和真正的 server 端之前增加一层提供特定服务的服务器，即代理服务器。 在了解反向代理前先了解什么是正向代理。 正向代理 翻墙工具就是一个典型的正向代理工具。它会把我们不能访问的墙外服务器 server 的网页请求，代理到一个可以访问该网站的代理服务器 proxy，这个代理服务器 proxy 把墙外服务器 server 上的网页内容获取，再转发给客户。具体的流程如下图。 其特点如下： 客户端和代理服务器可以直接互相访问，属于一个 LAN（局域网） 代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器 代理服务器通过代理用户端的请求来向域外服务器请求响应内容。 一句话总结： 代理的是客户端 反向代理 反向代理正好相反，客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。 其特点如下： 代理服务器和真正 server 服务器可以直接互相访问，属于一个 LAN（服务器内网） 代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作； 代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。 一句话总结： 代理的是服务器 反向代理的好处： 安全及权限使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须通过 Nginx。可以通过在 Nginx 层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。 负载均衡一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配 简单实现反向代理 举个例子，我们访问 home.kobin.top 这个网站，然后反向代理到 baidu.com 上。可做如下配置： 1234567server&#123; listen 80; server_name home.kobin.top; location / &#123; proxy_pass https://www.baidu.com; &#125;&#125; 结果如下： 其他常用的反向代理配置： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置 Nginx 与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间。 proxy_send_timeout：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的 Location 和 Refresh。 八、Nginx 适配移动端与 PC 端Nginx 通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是 PC 端，进而展示不同的页面给用户。 在 conf.d 目录下新建一个 demo.conf 文件，内容如下： 1234567891011server &#123; listen 80; server_name blog.kobin.top; location / &#123; root /yangling/app/pc; # 默认展示PC端页面 if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') &#123; # 如果匹配到mobile端的user_agent则展示mobile页面 root /yangling/app/mobile; &#125; index index.html; &#125;&#125; 九、Nginx 实现 Gzip 压缩Gzip 是网页的一种网页压缩技术，经过 gzip 压缩后，页面大小可以变为原来的 30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip 网页压缩的实现需要浏览器和服务器的支持。 gzip 是需要服务器和浏览器同事支持的。当浏览器支持 gzip 压缩时，会在请求消息中包含 Accept-Encoding:gzip,这样 Nginx 就会向浏览器发送听过 gzip 后的内容，同时在相应信息头中加入 Content-Encoding:gzip，声明这是 gzip 后的内容，告知浏览器要先解压后才能解析输出。 gzip 配置： gzip : 该指令用于开启或 关闭 gzip 模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。 gzip_comp_level : gzip 压缩比，压缩级别是 1-9，1 的压缩级别最低，9 的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的 User-Agent 不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的 Content-length 中进行获取。 gzip_http_version：识别 HTTP 协议版本，其值可以是 1.1.或 1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩。 gzip_vary : 用于在响应消息头中添加 Vary：Accept-Encoding,使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩。 简单配置： 123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用 gizp 模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和 CSS 文件进行压缩输出。 十、Nginx 与跨域请求举个例子：在 a.com 页面中有请求 b.com 的接口http://b.com/getHomeData, 出现了跨域问题。当然这种跨域问题的处理方式很多，这里主要说下用 Nginx 如何解决。 在 a.com 启个 Nginx 服务，配置如下： 12345678910server &#123; listen 80; server_name a.com; #请求跨域，这里约定代理请求url path是以/apis/开头 location ^~/apis/ &#123; # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配 rewrite ^/apis/(.*)$ /$1 break; proxy_pass https://www.b.com/; &#125;&#125; 这时请求接口 URL 换成http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。 十一、Nginx 与合并请求通过nginx-http-concat插件可以实现将多个资源请求合并为一个请求，达到性能优化目的。 十二、Nginx 与图片处理通过ngx_http_image_filter_module插件实现日常对图片的处理，包括缩放、裁剪、旋转、图片质量等的控制。 十三、使用Let’s Encrypt配置ssl证书安装certbot1yum install -y python3 &amp;&amp; pip3 install certbot 查看certbot使用方法： 1certbot --help certbot 默认使用http方式对域名所有权进行验证，该操作需要绑定vps的80端口。如果80端口已被占用，请先停止占用的进程，例如停止Nginx： 1killall nginx 为指定域名生成证书： 1certbot certonly --standalone -d 域名1 -d 域名2 查看域名证书的路径和国旗时间 1certbot certificates 生成的证文件位置： 1/etc/letsencrypt/live/kobin.top/ 配置Nginx编辑/etc/nginx/conf.d/default.conf: 1234567891011121314151617181920212223242526server &#123; listen 80; server_name kobin.top; rewrite ^(.*) https://$server_name$1 permanent;&#125;server &#123; listen 443 ssl; server_name kobin.top; charset utf-8; ssl_certificate /etc/letsencrypt/live/kobin.top/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/kobin.top/privkey.pem; ssl_protocols TLSv1.2 TLSv1.3; # TLSv1.3需要nginx 1.13.0以上版本 # 如果nginx版本低，建议使用这种加密算法配置 # ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384; ssl_ecdh_curve secp384r1; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_session_tickets off; keepalive_timeout 70; # 这里填写其他配置&#125; 查看配置有无错误： 1nginx -t 如果没有错误，则启动Nginx： 1systemctl restart nginx.service 证书自动更新Let’s Encrypt证书的有效期是三个月，超过期限则需要续签。证书续期可以手动完成，例如： 123systemctl stop nginxcertbot renewsystemctl restart nginx 也可以配置crontab任务自动续签，在/etc/crontab文件末添加一行： 10 0 1 */2 0 root systemctl stop nginx; /usr/local/bin/certbot renew; systemctl restart nginx","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"http://kobin.top/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"http://kobin.top/tags/nginx/"}]},{"title":"文章摘录","slug":"collection","date":"2019-05-06T15:35:35.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"collection/","link":"","permalink":"http://kobin.top/collection/","excerpt":"在这里记录一些看到的好文章好博客","text":"在这里记录一些看到的好文章好博客 龙恩 0707 cdn 全栈修炼 前端进阶之道 大前端面试宝典 - 图解前端 未来可期的 TypeScript 别再说虚拟 DOM 快了，要被打脸的 深入理解虚拟 DOM，它真的不快 Deep In React 之详谈 React 16 Diff 策略(二) ReactFiber 在并发模式下的运行机制 前端浏览器输入 URL 后发生什么 大公司如何部署前端代码 Vuex、Flux、Redux、Redux-saga、Dva、MobX累死累活做业务，绩效还不怎么样，我只能帮你到这了……","categories":[{"name":"面试","slug":"面试","permalink":"http://kobin.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kobin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"基于hexo搭建个人博客并使用GitHub Actions一键发布到GitHub pages & 阿里云ECS","slug":"others-hexo","date":"2019-04-28T15:15:23.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"others-hexo/","link":"","permalink":"http://kobin.top/others-hexo/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装前提安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序： Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本) Git 注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容 安装 Hexo使用 npm: 1$ npm install -g hexo-cli 使用 yarn: 1$ yarn global add hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 常用命令new新建一篇文章 1$ hexo new [layout] &lt;title&gt; generate生成静态文件。 1$ hexo generate publish发表草稿。 1$ hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 1$ hexo server deploy部署网站。 1$ hexo deploy clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 1$ hexo clean list列出网站资料。 1$ hexo list &lt;type&gt; 注： 更多命令见官网 部署 GitHub pages如果您只是想部署到GitHub Actions上，那么可以直接用这节的方法。如果还想部署到阿里云等私人服务器上，那么可以跳过这步，直接看下一节。 新建 GitHub 项目打开 GitHub 点击右上角的new repository 然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建 安装 hexo-deployer-git。1$ npm install hexo-deployer-git --save 修改_config.yml 配置1234deploy: type: git repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git branch: master 执行命令执行 hexo deploy 将生成的文件部署到上一步配置的仓库对应的分支上去。 1hexo clean &amp;&amp; hexo deploy 至此，已经实现了个人博客的搭建并完成了一键发布到GitHub Pages的功能，如果只需要发布到GitHub Pages，那么至此已经可以愉快地写文章了。 但是由于总所周知的原因，GitHub在国内的访问速度总是时好时坏，不够畅快。 那么如果你手里恰好有闲置的云服务器，那么接下去就更进一步吧！🙂 GitHub Actions登场GitHub Actions 是 GitHub 于2018年10月推出的持续集成服务。功能非常强大，具体的基础用法不赘述，可以参阅阮一峰老师的教程。 这里主要介绍如何配置GitHub Actions实现自动部署功能。 创建workflow 文件GitHub Actions 的配置文件叫做 workflow 文件, 存放在代码仓库的.github/workflows目录。 新建.github/workflows/deploy.yml, 具体配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152name: Hexo build and deployon: push: branches: - blog # blog分支是本人的hexo源码分支jobs: build: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v2 # If you're using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly. with: persist-credentials: false # checkout到你的hexo代码分支 ref: blog # hexo需要加载内部子模块 submodules: true # 使用 node:10 - name: use Node.js 10 uses: actions/setup-node@v1 with: node-version: 10 # 安装npm包 &amp; 生成静态文件 - name: Install and publish run: | npm install npm run build # 将静态文件部署到阿里云 - name: Deploy to aliyun server uses: easingthemes/ssh-deploy@v2.0.7 env: SSH_PRIVATE_KEY: $&#123;&#123; secrets.ALIYUN_SERVER_ACCESS_TOKEN &#125;&#125; ARGS: \"-avz --delete\" SOURCE: \"public\" REMOTE_HOST: $&#123;&#123; secrets.ALIYUN_SERVER_HOST &#125;&#125; REMOTE_USER: \"root\" TARGET: \"/code/hexo-blog\" # 静态资源存放目录 # 将静态文件部署到github pages - name: Deploy to Github Pages uses: JamesIves/github-pages-deploy-action@releases/v3 with: ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BASE_BRANCH: blog BRANCH: master FOLDER: public 配置参数说明 ALIYUN_SERVER_HOST： 阿里云服务器公网IP； ALIYUN_SERVER_ACCESS_TOKEN：阿里云.ssh下的私钥(id_rsa); 如果未生成过，可以执行如下命令：1ssh-keygen -m PEM -t rsa -b 4096 把公钥复制一份到authorized_keys中:12cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys ACCESS_TOKEN: GitHub 密钥, 按照官方文档生成一个秘钥。 以上三个参数都保存到自己仓库-&gt;settings-&gt;Secrets里面： 构建结果将整个仓库推送到GitHub，GitHub 发现了 workflow 文件以后，就会自动运行。 至此，我们已经将博客部署到GitHub Actions和阿里云上了。阿里云上我们可以使用Nginx托管静态资源： 12345678server &#123; listen 80; server_name kobin.top; location / &#123; root /code/hexo-blog/public; # 静态资源存放目录 index index.html; &#125;&#125; 一切大功告成！收工😄","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://kobin.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Event Loop详解","slug":"javascript-event-loop","date":"2018-03-01T18:55:10.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-event-loop/","link":"","permalink":"http://kobin.top/javascript-event-loop/","excerpt":"JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 –&gt; http延迟 –&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。 JavaScript用异步回调（asynchronous callback）去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。","text":"JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 –&gt; http延迟 –&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。 JavaScript用异步回调（asynchronous callback）去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。 先了解一点基础知识1. JavaScript的 Engine 和 Runtime简单来说，为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂得多）： 第一部分是Engine（JS引擎）：编译并执行 JavaScript 代码，完成内存分配、垃圾回收等；第二部分是是 Runtime（运行时）：为 JavaScript 提供一些对象或机制，使它能够与外界交互。 举个例子： Chrome浏览器 和 Node.js 都使用了 V8 Engine。V8 实现并提供了 ECMAScript 标准中的所有数据类型、操作符、对象和方法（注意并没有 DOM）。 但它们的 Runtime 并不一样：Chrome 提供了 window、DOM，而 Node.js 则是 require、process 等等。 2. 浏览器的线程现代浏览器的一个 tab ，其中的线程包括但不局限于： GUI 渲染线程 JS引擎线程 事件触发线程 定时器触发线程 异步http请求线程 JavaScript中的异步回调是通过 WebAPIs 去支持的，常见的有 XMLHttpRequest，setTimeout，事件回调（onclik, onscroll等）。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有合适的地方去处理定时器的计时、各种请求的回调。即当代码中出现这几个定义的异步任务，是由浏览器实现了它们与JS引擎的通信，与JS引擎不属与同一个线程。 另外，GUI 渲染和JavaScript执行是互斥的。虽然两者属于不同的线程，但是由于JavaScript执行结果可能会对页面产生影响，所以浏览器对此做了处理，大部分情况下JavaScript线程执行，执行渲染（render）的线程就会暂停，等JavaScript的同步代码执行完再去渲染。 Event loop的定义Event Loop（事件循环） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。Event Loop的作用很简单： 监控调用栈和任务队列（见 3），如果调用栈是空的，它就会取出队列中的第一个”callback函数”，然后将它压入到调用栈中，然后执行它。 总的来说，Event Loop 是实现异步回调的一种机制而已。 1.分两种Event Loop 分为两种，一种存在于 Browsing Context 中，还有一种在 Worker 中。 Browsing Context 是指一种用来将 Document（文档）展现给用户的环境。例如浏览器中的 tab，window 或 iframe 等，通常都包含 Browsing Context。 Worker 是指一种独立于 UI 脚本，可在后台执行脚本的 API。常用来在后台处理一些计算密集型的任务。 本篇重点介绍的是 Browsing Context 中的 Event Loop，相比 Worker 中的 Event Loop，它也更加复杂一些。 另外，Event Loop 并不是在 ECMAScript 标准中定义的，而是在 HTML 标准中定义的。在 JS引擎中（以V8为例），只是实现了 ECMAScript 标准，而并不关心什么 Event Loop。也就是说 Event Loop 是属于 JavaScript Runtime 的，是由宿主环境（比如浏览器）提供的。所以千万不要理解错了，这也是前面介绍 JavaScript Engine 和 Runtime 的原因。 2.独立每个”线程“都有自己的 Event Loop。所以，每个 web worker 拥有独立的 Event Loop，它们都可以独立运行；同源的 windows 共享一个 Event Loop，它们之间可以互相通信。 内存模型从 JavaScript 内存模型的角度，我们可以将内存划分为调用栈（Call Stack）、堆（Heap）以及任务队列（Queue）等几个部分： 1. 调用栈调用栈会记录所有的函数调用信息，当我们调用某个函数时，会将其参数与局部变量等以栈帧的形式压入栈中（入栈）；在执行完毕后，会弹出栈顶的帧。让我们来看一看下面的例子： 12345678function multiply(x, y) &#123; return x * y;&#125;function printSquare(x) &#123; var s = multiply(x, x); console.log(s);&#125;printSquare(5); 当程序开始执行的时候，调用栈是空的，然后，步骤如下： 2. 堆堆则则存放了大量的非结构化数据，譬如程序分配的变量与对象。 3. 任务队列任务队列包含了一系列待处理的信息与相关联的回调函数。任务队列又分为 MacroTask Queue 和 MicroTask Queue 两种。 MacroTask 和 MicroTask1. MacroTask Queue（宏任务队列）Event Loop 会有一个或多个 MacroTask Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task（也即MacroTask）。 关于 Task，常有人通俗地称它为 MarcoTask，但其实 HTML 标准中并没有这种说法。然而，为了方便理解，本书仍沿用通俗的称谓MacroTask。 在 HTML 标准中，定义了几种常见的 Task Source： DOM manipulation（DOM 操作）； User interaction（用户交互）； Networking（网络请求）； History traversal（History API 操作）。 MacroTask Source 的定义非常的宽泛，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），以及定时器相关的 setTimeout、setInterval 等等都属于 Task Source，所有来自这些 MacroTask Source 的 MacroTask 都会被放到对应的 MacroTask Queue 中等待处理。 对于 MacroTask、MacroTask Queue 和 Task Source，有如下规定： 来自相同 Task Source 的 MacroTask，必须放在同一个 MacroTask Queue 中； 来自不同 Task Source 的 MacroTask，可以放在不同的 MacroTask Queue 中； 同一个 MacroTask Queue 内的 MacroTask 是按顺序执行的； 但对于不同的 MacroTask Queue（Task Source），浏览器会进行调度，允许优先执行来自特定 Task Source 的 MacroTask。 例如，鼠标、键盘事件和网络请求都有各自的 MacroTask Queue，当两者同时存时，浏览器可以优先从用户交互相关的 MacroTask Queue 中挑选 MacroTask 并执行，比如这里的鼠标、键盘事件，从而保证流畅的用户体验。 2. MicroTask Queue（微任务队列）MicroTask Queue 与 MacroTask Queue 类似，也是一个有序列表。不同之处在于，一个 Event Loop 只有一个 MicroTask Queue。 在 HTML 标准中，并没有明确规定 MicroTask Source，通常认为有以下几种： Promise 在 Promises/A+ Note 3.1 中提到了 then、onFulfilled、onRejected 的实现方法，但 Promise 本身属于平台代码，由具体实现来决定是否使用 Microtask，因此在不同浏览器上可能会出现执行顺序不一致的问题。不过好在目前的共识是用 Microtask 来实现事件队列。 MutationObserver Object.observe (已废弃) 这里要特别提一下：网上有很多文章把 Node.js 的 process.nextTick 和 Microtask 混为一谈，事实上虽然两者层级（运行时机）非常接近，但并不是同一个东西。process.nextTick 是 Node.js 自身定义实现的一种机制，有自己的 nextTickQueue，与 HTML 标准中的 MicroTask 不是一回事。在 Node.js 中，process.nextTick 会先于 Microtask Queue 被执行。 3. 二者关系图例Event Loop中，每一次循环称为tick，每一次tick的任务细节如下： 调用栈选择最先进入队列的MacroTask（通常是script整体代码），如果有则执行； 检查是否存在 MicroTask，如果存在则不停的执行，直至清空 MicroTask Queue； 浏览器更新渲染（render），每一次事件循环，浏览器都可能会去更新渲染； 重复以上步骤。 MacroTask Queue和MicroTask Queue二者的关系如下图： 如图所示，二者互相穿插：MacroTask –&gt; MicroTask Queue –&gt; MacroTask。 一个Event Loop会有一个或多个 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。 这句话可能比较令人费解，因为图中似乎有2 个MicroTask Queue！ 其实是这样的，每个 MacroTask Queue 都保证按照回调函数（callback）入队列的顺序依次执行MacroTask，在 MacroTask 或者 MicroTask 中产生的新 MicroTask 会被压入到 MicroTask Queue中并执行。而在 执行两个MacroTask之间，也即在执行下一个MacroTask之前，会优先执行完所有MicroTask，也即会优先清空已有的 MicroTask Queue。 因此，图中第二个MicroTask Queue产生的时候，第一个MicroTask Queue其实已经被清空了。所以Event Loop实际上仅有一个MicroTask Queue。 JavaScript Runtime 的运行机制了解了 Event Loop 和任务队列的基本概念后，就可以从相对宏观的角度先了解一下 JavaScript Runtime 的运行机制了，简化后的步骤如下： 主线程不断循环； 对于同步任务，创建执行上下文（Execution Context），按顺序进入调用栈； 对于异步任务： 与步骤 2 相同，同步执行这段代码； 将相应的 MacroTask（或 Microtask）添加到任务队列； 由其他线程来执行具体的异步操作。 其他线程是指：尽管 JavaScript 是单线程的，但浏览器内核是多线程的，它会将 GUI 渲染、定时器触发、HTTP 请求等工作交给专门的线程来处理。另外，在 Node.js 中，异步操作会优先由 OS 或第三方系统提供的异步接口来执行，然后才由线程池处理。 当主线程执行完当前调用栈中的所有任务，就会去读取 Event Loop 的任务队列，取出并执行任务； 重复以上步骤。 用一张简图来表示一下这种运行机制： 还是拿 setTimeout 举例： 主线程同步执行这个 setTimeout 函数本身。 将负责执行这个 setTimeout 的回调函数的 MacroTask 添加到 MacroTask Queue。 定时器开始工作（实际上是靠 Event Loop 不断循环检查系统时间来判断是否已经到达指定的时间点）。 主线程继续执行其他任务。 当调用栈为空，且定时器触发时，主线程取出 MacroTask 并执行相应的回调函数。 很明显，执行 setTimeout 不会导致阻塞。当然，如果主线程很忙的话（调用栈一直非空），就会出现明明时间已经到了，却也不执行回调的现象，所以类似 setTimeout 这样的回调函数都是没法保证执行时机的。 setTimeout和setInterval取的时间是不准确的，因为当调用栈若不为空，它们的回调函数永远不会别执行。所以，我们会经常碰到setTimeout和setInterval用来做动画的时候，很不流畅或者卡顿。 面试题解析在面试中我们常常会碰到如下类似的代码题，面试官要你写出输出结果，其要目的是考察对JavaScript不同任务的执行先后顺序的理解： 1234567891011// 执行顺序问题，考察频率挺高setTimeout(function() &#123; console.log(1);&#125;);new Promise(function(resolve, reject) &#123; console.log(2); resolve(3);&#125;).then(function(val) &#123; console.log(val);&#125;);console.log(4); 根据本文的解析，我们可以得到： 先执行同步代码 首先，执行new Promise中的console.log(2)，then后面的属于MicroTask所以跳过； 然后，执行console.log(4)。 执行完script这个MacroTask后，执行MicroTask（也即Promise.then） 中的console.log(val)，此时val的值由resolve(3)传递过来，值为3。后面无其他微任务。 执行另一个MacroTask也即定时器setTimeout中的console.log(1)。 根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2，4，3，1。","categories":[],"tags":[]},{"title":"javascript的继承实现","slug":"javascript-javascript的继承实现","date":"2018-03-01T17:19:23.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-javascript的继承实现/","link":"","permalink":"http://kobin.top/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/","excerpt":"抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下","text":"抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下 01.类式继承(classical inheritance) 实现本质：重写子类的原型，代之以父类的实例。 1234567891011121314151617181920212223242526272829303132//父类function User(username) &#123; this.username = username ? username : \"Unknown\"; this.books = [\"coffe\", \"1891\"];&#125;//子类function CoffeUser(username) &#123; if (username) this.username = username;&#125;//关键CoffeUser.prototype = new User();const user1 = new CoffeUser();const user2 = new CoffeUser();//instanceof是检测某个对象是否是某个类的实例console.log(user1 instanceof User);//&gt;&gt; true// 可以直接访问原型链上的属性console.log(user1.username);//&gt;&gt; Unknownconsole.log(user1.books); //&gt;&gt; [\"coffe\", \"1891\"]//修改来自原型上的引用类型的属性，则有副作用：会影响到所有实例user1.books.push(\"hello\");console.log(user1.books); //&gt;&gt; [\"coffe\", \"1891\", \"hello\"]console.log(user2.books); //&gt;&gt; [\"coffe\", \"1891\", \"hello\"]//修改来自原型上的值类型的属性，无副作用user1.username = 'U';console.log(user1.username, user2.username); //&gt;&gt; U Unknown 缺陷： 引用类型属性的误修改。原型属性中的引用类型属性会被所有实例共享，若子类实例更改从父类原型继承来的引用类型的共有属性，会影响其他子类。 无法传递参数。在创建子类型的实例时，不能向父类的构造函数中传递参数。这点如过不好理解的话，接着看下面的“构造函数式继承”。 综上，我们在实际开发中很少单独使用类式继承。 02.构造函数式继承通过call/apply调用来实现继承： 123456789101112131415161718function User(username, password) &#123; this.password = password; this.username = username; User.prototype.login = function () &#123; console.log(this.username + '要登录Github，密码是' + this.password); &#125;&#125;function CoffeUser(username, password) &#123; User.call(this, username, password);//通过call向父类的构造函数传递参数 this.articles = 3; // 文章数量&#125;const user1 = new CoffeUser('coffe1891', '123456');console.log(user1 instanceof User);//&gt;&gt; falseconsole.log(user1.username, user1.password); //&gt;&gt; coffe1891 123456console.log(user1.login()); // TypeError: user1.login is not a function 存在明显的缺陷： 无法通过instanceof的测试； 并没有继承父类原型上的方法。 03.组合式继承既然上述两种方法各有缺点，但是又各有所长，那么我们是否可以将其结合起来使用呢？即原型链继承方法，而在构造函数继承属性，这种继承方式就叫做“组合式继承”。 123456789101112131415161718function User(username, password) &#123; this.password = password; this.username = username; User.prototype.login = function () &#123; console.log(this.username + '要登录Github，密码是' + this.password); &#125;&#125;function CoffeUser(username, password) &#123; User.call(this, username, password); // 第2次执行 User 的构造函数 this.articles = 3; // 文章数量&#125;CoffeUser.prototype = new User(); // 第1次执行 User 的构造函数const user1 = new CoffeUser(\"coffe1891\", \"123456\");console.log(user1 instanceof User);//&gt;&gt; trueuser1.login();//&gt;&gt; coffe1891要登录Github，密码是123456 虽然这种方式弥补了上述两种方式的一些缺陷，但有些问题仍然存在： 父类的构造函数被调用了两次，显得多余； 污染：若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法。 综上，组合式继承也不是我们最终想要的。 04.原型继承(prototypal inheritance)原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下： 123456789function createObject(o) &#123; // 创建临时类 function F() &#123; &#125; // 修改类的原型为o, 于是f的实例都将继承o上的方法 F.prototype = o; return new F();&#125; 这不就是ES5的 Object.create 吗？没错，你可以认为是如此。 既然只是类式继承的一种封装，其使用方式自然如下： 1CoffeUser.prototype &#x3D; createObject(User) 也就仍然没有解决类式继承的一些问题。从这个角度而言，原型继承和类式继承应该直接归为一种继承。 05.寄生式继承寄生式继承是与原型继承紧密相关的一种思路，它依托于一个内部对象而生成一个新对象，因此称之为寄生。 12345678910111213141516const UserSample = &#123; username: \"coffe1891\", password: \"123456\"&#125;function CoffeUser(obj) &#123; var o = Object.create(obj);//o继承obj的原型 o.__proto__.readArticle = function () &#123;//扩展方法 console.log('Read article'); &#125; return o;&#125;var user = new CoffeUser(UserSample);user.readArticle();//&gt;&gt; Read articleconsole.log(user.username, user.password);//&gt;&gt; coffe1891 123456 06.寄生组合式继承12345678910111213141516171819202122232425262728293031323334353637//寄生组合式继承的核心方法function inherit(child, parent) &#123; // 继承父类的原型 const p = Object.create(parent.prototype); // 重写子类的原型 child.prototype = p; // 重写被污染的子类的constructor p.constructor = child;&#125;//User, 父类function User(username, password) &#123; let _password = password this.username = username&#125;User.prototype.login = function () &#123; console.log(this.username + '要登录Github，密码是' + _password); //&gt;&gt; ReferenceError: _password is not defined&#125;//CoffeUser, 子类function CoffeUser(username, password) &#123; User.call(this, username, password) // 继承属性 this.articles = 3 // 文章数量&#125;//继承inherit(CoffeUser, User);//在原型上添加新方法CoffeUser.prototype.readArticle = function () &#123; console.log('Read article');&#125;const user1 = new CoffeUser(\"Coffe1891\", \"123456\");console.log(user1); 观察chrome浏览器的输出结果： 简单说明一下： 子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性； 子类可以传递动态参数给父类； 父类的构造函数只执行了一次。 Nice！这才是我们想要的继承方法。然而，仍然存在一个美中不足的问题： 子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话若是已经存在的两个类，就不好办了。 所以，我们可以将其优化一下： 12345678function inherit(child, parent) &#123; // 继承父类的原型 const parentPrototype = Object.create(parent.prototype) // 将父类原型和子类原型合并，并赋值给子类的原型 child.prototype = Object.assign(parentPrototype, child.prototype) // 重写被污染的子类的constructor p.constructor = child&#125; 但实际上，使用Object.assign 来进行 copy 仍然不是最好的方法。因为上述的继承方法只适用于 copy 原型链上可枚举的方法，而ES6中，类的方法默认都是不可枚举的。此外，如果子类本身已经继承自某个类，以上的继承将不能满足要求。 参考文献Inheritance in JavaScript","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"继承","slug":"继承","permalink":"http://kobin.top/tags/%E7%BB%A7%E6%89%BF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"原型与原型链","slug":"javascript-原型与原型链","date":"2018-02-05T15:45:38.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-原型与原型链/","link":"","permalink":"http://kobin.top/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。","text":"在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。 原型、prototype、__proto__ 原型是一个对象。 prototype是函数的一个属性而已，也是一个对象，它和原型没有绝对的关系（很多书、很多网络文章都模糊地将prototype表述为原型，这是严重不对的）。JavaScript里函数也是一种对象，每个对象都有一个原型，但不是所有对象都有prototype属性，实际上只有函数才有这个属性。 1234567var a = function()&#123;&#125;;var b=[1,2,3];//函数才有prototype属性console.log(a.prototype);//&gt;&gt; function()&#123;&#125;//非函数，没有prototype属性console.log(b.prototype);//&gt;&gt; undefined 每个对象(实例)都有一个属性__proto__，指向他的构造函数（constructor）的prototype属性。 一个对象的原型就是它的构造函数的prototype属性的值，因此__proto__也即原型的代名词。 对象的__proto__也有自己的__proto__，层层向上，直到__proto__为null。换句话说，原型本身也有自己的原型。这种由原型层层链接起来的数据结构成为 原型链。因为null不再有原型，所以原型链的末端是null。 让我们用更多代码来验证一下以上结论： 123456789101112131415161718var a = function()&#123;&#125;;var b=[1,2,3];//a的构造函数是「Function函数」console.log(a.__proto__ == Function.prototype);//&gt;&gt; true//b的构造函数是「Array函数」console.log(b.__proto__ == Array.prototype);//&gt;&gt; true//因为「Function函数」和「Array函数」又都是对象，其构造函数//是「Object函数」，所以，a和b的原型的原型都是Object.prototypeconsole.log(a.__proto__.__proto__ === Object.prototype);//&gt;&gt; trueconsole.log(b.__proto__.__proto__ === Object.prototype);//&gt;&gt; true//Object作为顶级对象的构造函数，它实例的原型本身就不再有原型了，因此它原型//的__proto__属性为nullconsole.log(new Object().__proto__.__proto__);//&gt;&gt; null//也即Object类型对象，其原型（Object.prototype）的__proto__为nullconsole.log(Object.prototype.__proto__);//&gt;&gt; null 三者关系图如下： 使用__proto__是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。__proto__属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。但是，它已被不推荐使用，现在更推荐使用Object.getPrototypeOf/Reflect.getPrototypeOf 和Object.setPrototypeOf/Reflect.setPrototypeOf（尽管如此，设置对象的原型是一个缓慢的操作，如果性能要求很高，应该避免设置对象的原型）。 原型继承使用最新的方法Object.setPrototypeOf（类似Reflect.setPrototypeOf）可以很方便地给对象设置原型，这个对象会继承该原型所有属性和方法。 但是，setPrototypeOf的性能很差，我们应该尽量使用 Object.create()来为某个对象设置原型。 1234567891011//obj的原型是Object.prototypevar obj=&#123; methodA()&#123; console.log(\"coffe\"); &#125;&#125;var newObj = Object.create(obj);//以obj为原型创建一个新的对象//methodA实际上是newObj原型对象obj上的方法。也即newObj继承了它的原型对象obj的属性和方法。newObj.methodA();//&gt;&gt; coffe 类(class）的prototype和protoES6之后，类(class)也有了prototype属性，为什么呢，因为class本质上是构造函数的语法糖. 1234class A &#123;&#125;typeof A;//&gt;&gt; \"function\" 说明class本质上也是函数，所以它带有prototype属性是十分正常的事。然后，在Chrome浏览器里调试如下代码： 1234class A &#123;&#125;A.prototype; 得到的结果如下图: 上面代码说明类的prototype是一个对象，它包含有constructor属性。这和函数的prototype属性表现具有一致性。 1234class A &#123;&#125;A===A.prototype.constructor;//&gt;&gt; true 上面代码说明一个重要结论：类指向自身构造函数。而且，事实上，类的所有方法都定义在类的prototype属性上面。同样可以通过Chrome调试验证。 1234567891011121314151617181920class A&#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于A.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 结果如下： 定理class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A //&gt;&gt; trueB.prototype.__proto__ === A.prototype //&gt;&gt; true","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"原型","slug":"原型","permalink":"http://kobin.top/tags/%E5%8E%9F%E5%9E%8B/"}]},{"title":"闭包","slug":"javascript-闭包","date":"2018-02-03T15:04:57.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-闭包/","link":"","permalink":"http://kobin.top/javascript-%E9%97%AD%E5%8C%85/","excerpt":"闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。","text":"闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。 热身：循环中的闭包12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function test() &#123; console.log(i) //&gt;&gt; 6 6 6 6 6 &#125;, i * 1000);&#125; 本意是想每隔一秒依次输出“1 2 3 4 5”，结果变成输出“6 6 6 6 6 ”。为什么会这样呢，根据作用域链上变量查找机制，setTimeout第一个参数的函数体内的i引用了去全局作用域里面的i，当for循环完毕后，i的值为6，所以输出了“6 6 6 6 6 ”。 如何实现正确的输出呢？ 其实用闭包就能轻松解决这个问题： 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123;//包了一层IIFE形式的函数，这个函数是闭包 setTimeout(function test() &#123;//函数体内的j引用了外层匿名函数的参数j console.log(j); //&gt;&gt; 1 2 3 4 5 &#125;, j * 1000); &#125;)(i);&#125; 什么是闭包1. 闭包的定义关于JavaScript闭包的定义有很多种，每本书、每个作者都有不完全相同的描述，虽然笔者认为函数就是闭包这个定义才是最简单最直白的，但其实笔者看到过不下十种定义，到现在一种都记不住。鉴于此，我们干脆不要记住这些五花八门的定义了，只要记住了产生闭包的时机会更实际一些，面试时，把闭包产生的时机告诉面试官就可以了： 内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。让我们用代码来说事儿吧： 1234567891011function func()&#123;//func1引用了它外层的变量a，因此func成为了闭包 let a=\"coffe\"; function func1()&#123; console.log(a);//访问了外层函数func体内的变量a debugger;//断点 &#125; func1();&#125;func(); 我们在chrome浏览器的“开发者工具”里面的控制台，运行上面的代码，可以很方便看到闭包。 看上面这个图，Closure出现在Scope一栏里面，所以可以认为闭包也是一种作用域。既然闭包也是一种作用域，闭包能够解决经典的“循环中的闭包”的问题，那是不是利用作用域就能解决问题？这让人想到了关键字let，试试看吧，把本文开头的代码改造一下： 12345678for (var i = 1; i &lt;= 5; i++) &#123; &#123; let j = i; setTimeout(function test() &#123; console.log(j) //&gt;&gt; 1 2 3 4 5 &#125;, j * 1000); &#125;&#125; 果然，用let关键字包上一个作用域，也能和闭包一样解决问题达成目的。因此可以说，闭包是一种作用域，它拷贝了一套外层函数作用域中被访问的参数、变量/函数，这个拷贝都是浅拷贝 2. 写成闭包形式有什么好处呢？当然有好处！还是以之前的代码为例，变量a类似于高级语言的私有属性，无法被func外部作用域访问和修改，只有func内部的作用域（含嵌套作用域）可以访问。这样可以实现软件设计上的封装，设计出很强大的类库、框架，比如我们常用的jQuery、AngularJS、Vue.js。 看一个ES6出现之前最常见的模块化封装的例子: 12345678910111213141516171819202122//定义一个模块function module(n) &#123; //私有属性 let name = n; //私有方法 function getModuleName() &#123; return name; &#125; //私有方法 function someMethod() &#123; console.log(\"coffe1891\"); &#125; //以一个对象的形式返回 return &#123; getModuleName: getModuleName, getXXX: someMethod &#125;;&#125;let myapp = module(\"myModule\");//定义一个模块console.log(myapp.getModuleName()); //&gt;&gt; myModuleconsole.log(myapp.getXXX()); //&gt;&gt; coffe1891 3. 闭包有什么缺点吗？javascript中的垃圾回收（GC）规则是这样的：如果对象不再被引用，或者对象互相引用形成数据孤岛后且没有被孤岛之外的其他对象引用，那么这些对象将会被JS引擎的垃圾回收器回收；反之，这些对象一直会保存在内存中。 由于闭包会引用包含它的外层函数作用域里的变量/函数，因此会比其他非闭包形式的函数占用更多内存。当外层函数执行完毕退出函数调用栈（call stack）的时候，外层函数作用域里变量因为被引用着，可能并不会被JS引擎的垃圾回收器回收，因而会引起内存泄漏。过度使用闭包，会导致内存占用过多，甚至内存泄漏。 123456789101112function A()&#123; var count = 0; function B()&#123; count ++; console.log(count); &#125; return B;//函数B保持了对count的引用&#125;var b = A();b();//&gt;&gt; 1b();//&gt;&gt; 2b();//&gt;&gt; 3 count是函数A中的一个变量，它的值在函数B中被改变，B每执行一次，count的值就在原来的基础上累加1。因此，函数A中的count一直保存在内存中，并没有因为函数A执行完毕退出函数调用栈后被JS引擎的垃圾回收器回收掉。 避免闭包导致内存泄漏的解决方法是，在函数A执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。 其他使用场景介绍除了上面介绍过的循环中的闭包、模块化封装之外，闭包还有一些其他写法。 1. 返回一个新函数123456789101112function sayHello2(name) &#123; var text = \"Hello \" + name; // 局部变量 var sayAlert = function() &#123; console.log(text); &#125;; return sayAlert;&#125;var say2 = sayHello2(\"coffe1891\");say2(); //&gt;&gt; Hello coffe1891 调用sayHello2()函数返回了sayAlert，赋值给say2。注意say2是一个引用变量，指向一个函数本身，而不是指向一个变量。 2. 扩展全局对象的方法下面这种利用闭包扩展全局对象，可以有效地保护私有变量，形成一定的封装、持久性。 12345678910111213141516171819202122232425function setupSomeGlobals() &#123; //私有变量 var num = 666; gAlertNumber = function() &#123;//没有用var和let关键字声明，会成为全局对象的方法 console.log(num); &#125;; gIncreaseNumber = function() &#123; num++; &#125;; gSetNumber = function(x) &#123; num = x; &#125;;&#125;setupSomeGlobals();gAlertNumber(); //&gt;&gt; 666gIncreaseNumber();gAlertNumber(); //&gt;&gt; 667gSetNumber(1891);gAlertNumber(); //&gt;&gt; 1891 三个全局函数gAlertNumber，gIncreaseNumber，gSetNumber指向了同一个闭包，因为它们是在同一次setupSomeGlobals()调用中声明的。它们所指向的闭包是与setupSomeGlobals()函数关联一个作用域，该作用域包括了num变量的拷贝。也就是说，这三个函数操作的是同一个num变量。 3. 延长局部变量的生命日常开发时，Image对象经常被用于数据统计的上报，示例代码如下： 12345var report = function(src) &#123; var img = new Image(); img.src = src;&#125;report('http://www.xxx.com/getClientInfo');//把客户端信息上报数据 这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报。原因是Image对象是report函数中的局部变量，当report函数调用结束后，Image对象随即被JS引擎垃圾回收器回收，而此时可能还没来得及发出http请求，所以可能导致此次上报数据的请求失败。 怎么办呢？我们可以使用闭包把Image对象封闭起来，就可以解决数据丢失的问题，代码如下： 123456789var report = (function() &#123; var imgs = [];//在内存里持久化 return function(src) &#123; var img = new Image(); imgs.push(img);//引用局部变量imgs img.src = src; &#125;&#125;());report('http://www.xxx.com/getClientInfo');//把客户端信息上报数据","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://kobin.top/tags/%E9%97%AD%E5%8C%85/"}]},{"title":"完全理解javascript里的this","slug":"javascript-javascript里的this","date":"2018-02-01T14:03:22.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"javascript-javascript里的this/","link":"","permalink":"http://kobin.top/javascript-javascript%E9%87%8C%E7%9A%84this/","excerpt":"","text":"this是JavaScript世界最让人迷惑的关键字之一，很多人对它一知半解，本文希望详细的把this说明白。 为什么要有this？JavaScript 允许在函数体内部，引用当前执行上下文的其他变量。 123function func() &#123; console.log(a);&#125; 如上代码，函数func引用了当前执行上下文的变量a，问题是这个函数func可以在任意其他执行上下文中被调用，因此这个a可能就指向不同了。正因为如此，JS引擎需要有一个机制，可以依靠其 优雅地、准确地指向当前代码运行时所处的上下文环境（context）。 因此便催生了“this”。 何谓”优雅地“？12345678910//假设有个对象名字很长，而且有可能会改名var iAmALongLongLongNameObject=&#123; name:\"coffe\", func1()&#123; return iAmALongLongLongNameObject.name; &#125;, func2()&#123; return this.name; &#125;&#125; iAmALongLongLongNameObject的方法func2使用了this关键字，是不是优雅多了？然后即使以后对象名字变化，func2内部的代码也不用改变。func1这种确实也可以实现与func2同样的功能，但是就显得丑陋、不灵活了。 何谓“准确地”？this可以准确地指向（某个对象）而不会产生歧义。 123456789101112131415161718192021//全局变量var iAmALongLongLongNameObject = &#123; name: \"1891\"&#125;;(function() &#123; //局部变量 var iAmALongLongLongNameObject = &#123; name: \"coffe\", func1() &#123; //如果光看代码，是不是容易看成调用了全局变量的name？ return iAmALongLongLongNameObject.name; &#125;, func2() &#123; //这里光看代码就很准确地知道是调用了局部变量的name！ return this.name; &#125; &#125;; console.log(iAmALongLongLongNameObject.func1());//&gt;&gt; coffe&#125;)(); 与“Java等高级语言的this会指向对象的实例本身”不同，JavaScript的this指向函数的调用位置的对象，也即调用该函数的对象。你需要知道，JavaScript中所有的函数都有属性，就如对象有属性一样。函数执行阶段（也即执行上下文的执行阶段）会获取this属性的值，此时this就是一个变量，储存着调用该函数的对象的值。 12345var a = \"coffe\";function func() &#123; console.log(this.a);&#125;func();//&gt;&gt; coffe 上面代码中，func的调用者未通过点操作符.指明，那它的调用者就是默认的全局对象window，func函数作为window的一个方法，其体内的this.a就是明确指代window中属性a，这种指向是准确而清晰的，不会有歧义。this的这种灵活性在设计API的时候，会变得很方便和容易被复用。 调用位置调用位置就是函数在代码中被调用的位置，而不是声明的位置。研究调用位置，也即搞清“由谁在哪调用了这个函数”的问题。搞清楚了调用位置，才能准确地找到this的指向。 要找到调用位置，最重要的是要分析是被谁、在哪调用。 1234567891011var module = &#123; x: \"1891\", getX: function() &#123; return this.x; &#125;&#125;console.log(module.getX());//&gt;&gt; 1891var getX = module.getX;//注意：getX和module.getX都是指向内存中函数的地址而已，它们并没有被“()”以便执行 //这里实际上是【间接引用】的模式，见文尾【壹.2.3.6】解释console.log(getX()); //&gt;&gt; undefined 如上代码，要找到函数getX的调用位置，需要先看哪儿调用了它，很明显，有函数有两处位置调用了函数getX()，接下来分析是谁调用了它。 作为module对象的getX方法被调用。 这种情况被谁调用？很明显是被对象module调用，this是指向module。module对象里面有一个属性x，它的值是1891，因此console.log(module.getX())输出1891。 作为全局函数getX被调用。 这种情况是被谁调用？我们都知道全局函数可以看作为window对象的方法，那么，很明显现在getX是被当做全局对象window的一个方法被调用。 我们搞清楚了调用位置之后，接下来就会着手判断this的指向。 先看看很多人对this指向的一些误解this 既不指向函数自身也不指向函数的作用域，这之前是很多前端工程师容易误解的地方，现在澄清一下。 this的指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的； this 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）； 正因为在执行上下文的创建阶段this的指向就已经被确定了，在执行阶段this指向不可再被更改。 12345678910var obj = &#123; a: \"1891\"&#125;function func() &#123; this = obj; //报错，因为在执行阶段试图修改this的指向 console.log(this.a);&#125;func(); this的指向规则1. 默认指向独立函数调用（无法应用后面其他指向规则时），this指向全局对象window。 12345function func() &#123; console.log( this.a ); // this指向全局对象&#125;var a = 2;func(); //&gt;&gt; 2 对于默认指向来说，决定this指向对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会指向undefined，否则this会指向全局对象。 123456789function func() &#123; \"use strict\";//函数体处于严格模式下，this指向undefined console.log(this.a);&#125;var a = \"1891\";(function() &#123; func(); //&gt;&gt; 报错&#125;)(); 12345678910function func() &#123; console.log(this.a);&#125;var a = \"1891\";(function() &#123; \"use strict\"; func(); //&gt;&gt; 1891 //这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关&#125;)(); 还有一种默认指向，就是在SetTimeout或SetInterval结合使用时。代码示例如下。 1234567891011121314151617181920212223var num = 0;class Obj &#123; constructor(num)&#123; this.num = num; &#125; func()&#123; console.log(this.num); &#125; func1()&#123; setTimeout(function () &#123; console.log(\"setTimeout:\"+this.num); &#125;, 1000) &#125; func2()&#123; setInterval(function () &#123; console.log(this.num); &#125;, 2000) &#125;&#125;var obj = new Obj(1);obj.func();//&gt;&gt; 1 输出的是obj.numobj.func1()//&gt;&gt; setTimeout:0 输出的是window.numobj.func2()//&gt;&gt; 0 0 0 0 …… 输出的是window.num 可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。 2. 隐式指向隐式指向是日常开发中最常见的指向。 函数体内this的指向由调用位置的调用者决定。如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的this指向该对象。 1234567891011function func() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, func: func&#125;;obj.func(); //&gt;&gt; 2// 找到调用位置，由 obj 对象来调用函数func，// 此时可以说函数func被调用时，obj 对象“拥有”或者“包含”func函数，// 所以此时的 this 指向调用 func 函数的 obj 对象。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置，也就是说this指向最终调用函数的对象。这句话可能说得比较拗口，其实简单通俗地说，this指向最靠近被调用函数的对象，离得远的不是。举例来说： 12345678910111213141516function func() &#123; console.log(this.a);&#125;var obj2 = &#123; a: \"1891\", func: func&#125;;var obj1 = &#123; a: \"coffe\", obj2: obj2&#125;;//此时的 this 指向 obj2 对象，因为obj2离得近！obj1.obj2.func(); //&gt;&gt; 1891 再来看看隐式丢失： 1234567891011121314151617function func() &#123; console.log( this.a );&#125;var obj = &#123; a: \"coffe1891\", func: func&#125;;var bar = obj.func; // 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实 // 都指向内存中的函数func本身。var a = \"oops, global\"; // a 是全局对象window的属性，也是全局变量bar(); //&gt;&gt; oops, global// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a） 3. 显式指向JavaScript内置对象Function的三个原型方法call()、apply()和bind()，它们的第一个参数是一个对象，它们会把这个对象绑定到this，接着在调用函数时让this指向这个对象。 1234567891011var a = \"makai\";function func() &#123; console.log( this.a );&#125;var obj = &#123; a:\"coffe1891\"&#125;;func.call(obj); //&gt;&gt; coffe1891// 在调用 func 时强制把它的 this 绑定到 obj 上 另外，使用bind可以修正SetTimeout和SetInterval的this指向： 1234567891011121314151617181920212223var num = 0;class Obj &#123; constructor(num)&#123; this.num = num; &#125; func()&#123; console.log(this.num); &#125; func1()&#123; setTimeout(function () &#123; console.log(\"setTimeout:\"+this.num); &#125;.bind(this), 1000);//bind &#125; func2()&#123; setInterval(function () &#123; console.log(this.num); &#125;.bind(this), 2000);//bind &#125;&#125;var obj = new Obj(1);obj.func();//&gt;&gt; 1 输出的是obj.numobj.func1()//&gt;&gt; setTimeout:1 输出的是obj.numobj.func2()//&gt;&gt; 1 1 1 1 …… 输出的是obj.num 4. “new”操作符指向在JavaScript 中，构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们只是被new操作符调用的普通函数而已。 使用new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作： 创建（或者说构造）一个全新的对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性、方法等）； 如果函数没有返回其他对象，那么返回这个新对象。 123456function func(a) &#123; this.a = a;&#125;var bar = new func(\"coffe1891\");console.log(bar.a); //&gt;&gt; coffe1891// 使用new 来调用func(..)时，我们会构造一个新对象并把它绑定到func(..)调用中的this上 可以将函数的返回值分成三种情况： 返回一个对象 没有返回值，即默认返回undefined 返回基本数据类型 12345678910111213141516171819202122232425262728293031323334353637381、返回一个对象function Foo(name,age) &#123; this.name = name; return &#123; age &#125;&#125;var bar = new Foo(\"kobin\",\"18\");bar.name; // undefinedbar.age; // 182、没有返回值function Foo(name,age) &#123; this.name = name;&#125;var bar = new Foo(\"kobin\",\"18\");bar.name; // kobinbar.age; // undefined3、返回基本数据类型function Foo(name,age) &#123; this.name = name; return 123&#125;var bar = new Foo(\"kobin\",\"18\");bar.name; // kobinbar.age; // undefined 所以使用new绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么this会绑定到返回的对象上 如何利用规则判断this的指向this的指向判断，可以按照下面的优先级顺序来判断函数在某个调用位置应用的是哪条规则 1. 函数是否在new 中被调用（new 操作符指向）？如果是的话，this 绑定的是新创建的对象。 123456789function func(name) &#123; this.name = name; this.getName = function() &#123; return this.name; &#125;;&#125;var obj = new func(\"coffe\"); //this会指向objconsole.log(obj.getName()); //&gt;&gt; coffe 2. 函数是否通过call、apply、bind显式指向？如果是的话，this指向的是call、apply、bind三个方法的第一个参数指定的对象。 12345678var obj1 = &#123; name: \"coffe\"&#125;;function func() &#123; return this.name; //这里的this本来指向window&#125;var str = func.call(obj1); //改变了func函数里面this的指向，指向obj1console.log(str); //&gt;&gt; coffe 3. 函数是否被当做某个对象的方法而调用（隐式指向）？如果是的话，this指向的是这个对象。 123456789var obj1 = &#123; name: \"coffe\", func() &#123; return this.name; //指向obj1 &#125;&#125;;//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1console.log(obj1.func()); //&gt;&gt; coffe 4. 若以上都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。 12345678var a = \"coffe\"; //为全局对象window添加一个属性afunction func() &#123; \"use strict\";//开启严格模式 return this.a;&#125;//严格模式下，this指向undefinedconsole.log(func()); //&gt;&gt; TypeError 几个例外情况1. 被忽略的thisnull 或者undefined作为this指向的对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认指向规则。 1234567function func() &#123; console.log(this.a);&#125;var a = 2;func.call(null); //&gt;&gt; 2 //this指向了window 2. 间接引用间接引用最容易在赋值时发生；间接引用时，调用这个函数会应用默认指向规则。 12345678910function func() &#123; console.log(this.a);&#125;var a = 2;var o = &#123; a: 3, func: func &#125;;var p = &#123; a: 4 &#125;;o.func(); //&gt;&gt; 3(p.func = o.func)(); //&gt;&gt; 2// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用// 因此调用位置是 func() 而不是 p.func() 或者 o.func() 3. 箭头函数箭头函数并不是使用function关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定 义的。 箭头函数不遵守this的四种指向规则，而是根据函数定义时的作用域来决定 this 的指向。何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。 看下面代码加深理解： 1234567891011121314151617181920function func() &#123; // 返回一个箭头函数 return a =&gt; &#123; //this 继承自 func() console.log(this.a); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = func.call(obj1);bar.call(obj2); //&gt;&gt; 2 不是 3 ！// func() 内部创建的箭头函数会捕获调用时 func() 的 this。// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！） 这个特性甚至被mozilla的MDN称作“没有this”，这种说法很费解。其实应该这么理解：一般而言，this的指向是在函数运行之后才确定的，而箭头函数的this指向在定义时也即调用之前就定死了，在运行之后无法更改，那相当于当成一个固定值的变量，此时this失去了原来作为“指向当前代码运行时所处的上下文环境（context）”的意义，所以MDN说箭头函数没有了this，我觉得翻译成“把this阉割了”更贴切 🤣 。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"如何让centOS7下全局安装的npm模块在环境变量中生效","slug":"others-centOS7-npm","date":"2017-09-10T16:12:53.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"others-centOS7-npm/","link":"","permalink":"http://kobin.top/others-centOS7-npm/","excerpt":"记一次在centOS7下npm安装全局模块，依然无法使用相关全局命令的问题的解决方案","text":"记一次在centOS7下npm安装全局模块，依然无法使用相关全局命令的问题的解决方案 问题详述通过npm i -g cnpm安装的cnpm后，依然无法全局使用cnpm命令： 1-bash: cnpm: command not found 解决方案： 需要将node路径关联到环境变量中 具体操作 使用npm root -g获取node目录, 1&#x2F;usr&#x2F;sbin&#x2F;nodejs&#x2F;lib&#x2F;node_modules 通过vim编辑/etc/profile文件, 在文件最底下新增: 123# Node所在路径export NODE_HOME=/usr/sbin/nodejsexport PATH=$&#123;NODE_HOME&#125;/bin:$PATH 如果PATH有其他配置，通过export PATH=&lt;path1&gt;:&lt;path2&gt;:&lt;path3&gt;:$PATH方式配置 最后执行命令使环境变量生效 1source /etc/profile 查看环境变量 1echo $PATH 验证效果 以后通过npm全局安装的模块会自动在环境变量中生效","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kobin.top/tags/Linux/"},{"name":"centOS","slug":"centOS","permalink":"http://kobin.top/tags/centOS/"}]},{"title":"word-wrap,word-break,white-space强制换行和不换行总结","slug":"css-强制换行与不换行","date":"2017-05-15T17:30:05.000Z","updated":"2020-10-14T10:18:00.453Z","comments":true,"path":"css-强制换行与不换行/","link":"","permalink":"http://kobin.top/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/","excerpt":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的","text":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的 word-wrap 语法： word-wrap: normal(默认) | break-word normal: 允许内容顶开指定的容器边界 break-word: 内容将在边界内换行。必要时会触发 word-break 说明word-wrap 是控制是否“为词断行”的，设置或检索当前行超过指定容器的边界时是否断开转行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。 范例congratulation 这个单词属于长串英文，word-wrap:break-word 整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断，这就是对于长串文字不起作用的解释。word-wrap:normal 是默认情况，英文单词不被拆开。 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（如果为 td,th 加上宽度 word-wrap 在 IE 下是能够发挥效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。 word-break word-break: normal(默认) | break-all | keep-all normal: 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。 break-all: 该行为与亚洲语言的 normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本。 keep-all: 与所有非亚洲语言的 normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 说明word-break:break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题（恰恰弥补了上面 word-wrap:break-word 对于长串文字不起作用的缺陷） 范例继续以上面 congratulation 这个单词属于长串英文，word-break:break-all 它会把单词截断，该行末端就会变成类似 conra(congratulation 的前端部分)，下一行为 tulation（conguatulation）的后端部分了。word-break:keep-all，是指 Chinese, Japanese, and Korean 不断词。即只用此时，不用 word-wrap，中文就不会换行了。（英文语句正常。） 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（经测试 Chrome 下 word-break:break-all 是有效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。Firefox,Opera 是无法识别 word-break 的，更不用提 Firefox 下的 th,td 中使用 word-break 的效果了。 white-space white-space: normal(默认) | pre | nowrap normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 说明 对于 pre 属性，其实就是 HTML 中连续的多个空白符会被合并，然后为了不让他合并（最常用的场合就是表示代码文字缩进）让其中的空白符继续保留而不需要我们增加额外的样式和标签来控制它的缩进和换行。pre 标签的原理也是一样的内部默认有了个 white-space:pre。 对于 nowrap 属性，这个是强制不换行核心，一般强制不换行就是利用这个属性。Firefox 的 div 和 td 中，以及 IE 的 div 中，均没有问题。唯一的瑕疵就是在 IE 的 td 中会有一个问题，如果 td 没有指定宽度，则 nowrap 仍然有效，如果 td 有宽度，并且文字中无标点、无空格（例如中文长串文字），nowrap 则不再有效。解决方式就是可以加 word-break:keep-all;可以解决此问题。 总结强制换行 div（块级元素） word-wrap:break-word; word-break:break-all; td,th 这类 table 元素 先为 table 设定 table-layout:fixed，基本上设定完这个属性后基本的换行问题都能够解决而不会出现 table 中 td,th 因为里面各个内容的多寡发生抢夺其他 td,th 宽度的情形发生。这时如果你依旧有强制换行问题，那么在此 td 中内部加一层 div，那么情况就会像上面讨论的方式来解决。 总结强制不换行 white-space:nowrap 在文字与 td 之间再套一层 div，然后使用 nowrap overflow:hidden 防止文字溢出","categories":[{"name":"css","slug":"css","permalink":"http://kobin.top/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kobin.top/tags/css/"}]}],"categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://kobin.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"npm","slug":"npm","permalink":"http://kobin.top/categories/npm/"},{"name":"react","slug":"react","permalink":"http://kobin.top/categories/react/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"Chrome源码","slug":"Chrome源码","permalink":"http://kobin.top/categories/Chrome%E6%BA%90%E7%A0%81/"},{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/categories/JavaScript/"},{"name":"node","slug":"node","permalink":"http://kobin.top/categories/node/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/categories/%E9%9D%A2%E8%AF%95/"},{"name":"css","slug":"css","permalink":"http://kobin.top/categories/css/"}],"tags":[{"name":"IntersectionObserver","slug":"IntersectionObserver","permalink":"http://kobin.top/tags/IntersectionObserver/"},{"name":"生活","slug":"生活","permalink":"http://kobin.top/tags/%E7%94%9F%E6%B4%BB/"},{"name":"npm","slug":"npm","permalink":"http://kobin.top/tags/npm/"},{"name":"react","slug":"react","permalink":"http://kobin.top/tags/react/"},{"name":"keep alice","slug":"keep-alice","permalink":"http://kobin.top/tags/keep-alice/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://kobin.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://kobin.top/tags/LeetCode/"},{"name":"array","slug":"array","permalink":"http://kobin.top/tags/array/"},{"name":"命令","slug":"命令","permalink":"http://kobin.top/tags/%E5%91%BD%E4%BB%A4/"},{"name":"梯子","slug":"梯子","permalink":"http://kobin.top/tags/%E6%A2%AF%E5%AD%90/"},{"name":"Mac终端","slug":"Mac终端","permalink":"http://kobin.top/tags/Mac%E7%BB%88%E7%AB%AF/"},{"name":"software","slug":"software","permalink":"http://kobin.top/tags/software/"},{"name":"软件","slug":"软件","permalink":"http://kobin.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"Linux","slug":"Linux","permalink":"http://kobin.top/tags/Linux/"},{"name":"centOS","slug":"centOS","permalink":"http://kobin.top/tags/centOS/"},{"name":"java","slug":"java","permalink":"http://kobin.top/tags/java/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"},{"name":"堆","slug":"堆","permalink":"http://kobin.top/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"http://kobin.top/tags/%E6%A0%88/"},{"name":"node","slug":"node","permalink":"http://kobin.top/tags/node/"},{"name":"stdin","slug":"stdin","permalink":"http://kobin.top/tags/stdin/"},{"name":"promise","slug":"promise","permalink":"http://kobin.top/tags/promise/"},{"name":"iframe","slug":"iframe","permalink":"http://kobin.top/tags/iframe/"},{"name":"download","slug":"download","permalink":"http://kobin.top/tags/download/"},{"name":"全栈","slug":"全栈","permalink":"http://kobin.top/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"http://kobin.top/tags/nginx/"},{"name":"前端","slug":"前端","permalink":"http://kobin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/tags/%E9%9D%A2%E8%AF%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://kobin.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"继承","slug":"继承","permalink":"http://kobin.top/tags/%E7%BB%A7%E6%89%BF/"},{"name":"原型","slug":"原型","permalink":"http://kobin.top/tags/%E5%8E%9F%E5%9E%8B/"},{"name":"闭包","slug":"闭包","permalink":"http://kobin.top/tags/%E9%97%AD%E5%8C%85/"},{"name":"css","slug":"css","permalink":"http://kobin.top/tags/css/"}]}