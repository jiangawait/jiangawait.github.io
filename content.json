{"meta":{"title":"扬舲's blog","subtitle":"山重水复疑无路 柳暗花明又一村","description":"前端技术博客","author":"yangling","url":"http://kobin.top","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-05T20:50:09.000Z","updated":"2020-05-28T15:29:37.480Z","comments":false,"path":"categories/index.html","permalink":"http://kobin.top/categories/index.html","excerpt":"","text":""},{"title":"react-test","date":"2020-05-01T16:59:10.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"react-test/index.html","permalink":"http://kobin.top/react-test/index.html","excerpt":"","text":"XSS 即（Cross Site Scripting）：跨站脚本攻击 原理 恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到 web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。 分类 存储型（持久性 XSS 攻击）、反射型(非持久性 XSS 攻击）及 DOM-based 型 反射性反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。例子： 恶意链接的地址指向了 localhost:8001/?q=111&amp;p=222。然后，我再启一个简单的 Node 服务处理恶意链接的请求： 1234567891011const http = require(\"http\");function handleReequest(req, res) &#123; res.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.writeHead(200, &#123; \"Content-Type\": \"text/html; charset=UTF-8\" &#125;); res.write('&lt;script&gt;alert(\"反射型 XSS 攻击\")&lt;/script&gt;'); res.end();&#125;const server = new http.Server();server.listen(8001, \"127.0.0.1\");server.on(\"request\", handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如 cookie)的脚本，这取决于攻击者的目的。 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 基于 DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 123456789101112131415161718192021222324252627&lt;h2&gt;XSS:&lt;/h2&gt;&lt;input type=\"text\" id=\"input\" /&gt;&lt;button id=\"btn\"&gt;Submit&lt;/button&gt;&lt;div id=\"div\"&gt;&lt;/div&gt;&lt;script&gt; const input = document.getElementById(\"input\"); const btn = document.getElementById(\"btn\"); const div = document.getElementById(\"div\"); let val; input.addEventListener( \"change\", (e) =&gt; &#123; val = e.target.value; &#125;, false ); btn.addEventListener( \"click\", () =&gt; &#123; div.innerHTML = `&lt;a href=$&#123;val&#125;&gt;testLink&lt;/a&gt;`; &#125;, false );&lt;/script&gt; 点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容 &#39;&#39; onclick=alert(/xss/) 用户提交之后，页面代码就变成了： &lt;a href onlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt; 此时，用户点击生成的链接，就会执行对应的脚本： SQL 注入SQL 注入是通过客户端的输入把 SQL 命令注入到一个应用的数据库中，从而执行恶意的 SQL 语句,一个例子： 我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 ‘or ‘123’ = ‘123 这样的。 我们在查询用户名和密码是否正确的时候，本来执行的 sql 语句是：select _ from user where username = ‘’ and password = ‘’. 这样的 sql 语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的 sql 语句就是：select _ from user where username = ‘’ and password = ‘ ‘ or ‘123’ = ‘123 ‘; 这样的了，那么会有一个 or 语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：’; drop table user;, 这样的话，那么 sql 命令就变成了：select * from user where username = ‘’ and password = ‘’; drop table user;’ , 那么这个时候我们会把 user 表直接删除了。 sql 被攻击的原因是：sql 语句伪造参数，然后对参数进行拼接后形成 xss 攻击的 sql 语句。最后会导致数据库被攻击了。 防范的方法： 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用 sql 语句伪造成参数，到了服务端的时候，这个伪造 sql 语句的参数也只是简单的字符，并不能起到攻击的作用。 数据库中密码不应明文存储的，可以对密码使用 md5 进行加密，为了加大破解成本，所以可以采用加盐的方式。 XSS 攻击的防范 cookie 安全策略 http-only: 只允许 http 或 https 请求读取 cookie、JS 代码是无法读取 cookie 的(document.cookie 会显示 http-only 的 cookie 项被自动过滤掉)。发送请求时自动发送 cookie. secure-only: 只允许 https 请求读取，发送请求时自动发送 cookie。 host-only: 只允许主机域名与 domain 设置完成一致的网站才能访问该 cookie。 输入检查 对于用户的任何输入要进行检查、过滤和转义。 输出检查 利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 开启 CSP 网页安全政策防止 XSS 攻击 CSP 是网页安全政策(Content Security Policy)的缩写。主要用来防止 XSS 攻击。是一种由开发者定义的安全性政策申明，通过 CSP 所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot; default-src http: https: *.xxx.com &#39;self&#39; &#39;unsafe-inline&#39; ; style-src &#39;self&#39; &#39;unsafe-inline&#39; *.yyy.com; script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39; ; &quot;&gt; CSRF(跨站请求伪造)完成一次 CSRF 攻击，需要完成如下事情： 登录受信任的网站 A，并且在本地生成 cookie。 在不登出网站 A 的情况下，继续访问危险网站 B。 CSRF 基本原理是：假设 A 网站是一个银行网站，而我是该网站的用户，当我以受信任的身份登录了该网站的时候，这时候 A 网站是通过 cookie 保留了我们的登录状态，这个时候我去登录了恶意网站 B 的时候，B 网站就会拿到我登录 A 网站的 cookie 信息到，因此 B 网站就把拿到的 cookie 信息去重新请求 A 网站的接口，但是在该接口后面的参数做一些修改，因此就这样达到攻击的目的。 CSRF 防范措施 服务端验证 HTTP Referer 字段 加验证码 使用 Token"},{"title":"标签","date":"2020-05-05T20:52:32.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"tags/index.html","permalink":"http://kobin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用软件大全","slug":"others-常用软件推荐","date":"2020-05-27T22:51:15.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"others-常用软件推荐/","link":"","permalink":"http://kobin.top/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/","excerpt":"在此记录一些堪称神器的软件","text":"windows篇1. Listary它不仅可以在本地非常快速的搜索，还可以打开网站、在搜索引擎中搜索、随时随地打开快捷菜单、文件快速定位、快速打开cmd窗口等等优秀的功能； 比如输入 cmd打开cmd窗口，输入 cmda使用管理员权限打开cmd窗口，输入 wyyyy打开网易云音乐，找到某个文件的时候 Enter直接打开， Ctrl+Enter 是打开文件所在文件夹； 值得一提的是搜索关键词功能，让我们可以非常便捷的打开相应网站或在对应网站搜索，比如输入 gg我的存款呢？就可以直接使用默认浏览器在谷歌搜索中搜索了，我们还可以自定义输入其他关键字，只需把搜索链接中的关键字换成 {query} ~ 2. uTools可以作为程序启动器外，uTools最大的特点就是拥有强大的插件系统，每个插件都有简洁美观、易于操作的界面，输入plugins进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最趁手的工具合集，为各种日常操作提供便利。不断产生的新插件，也将为你带来无限可能。 个人常用图床、剪切板、todo、各种技术文档等 3. DittoDitto 是一款免费开源的windows剪切板管理工具，作为 CtrlC V工程师，复制粘贴少不了，更厉害的是，可以用它来批量的复制， Ctrl+C一堆别人的代码，一次性全粘上，岂不美哉； 使用快捷键打开剪切板历史，然后 Ctrl/Shift来选择你希望粘贴的内容， Enter即可选择性的粘贴多行内容；另外剪切板历史还可以搜索，快速找到复制内容； 只需设置寥寥几个快捷键，就可以很方便的操作剪切板，带来极大幸福~ 4. Winsnap看到上面的截图没，旁边都有很骚包的阴影，怎么做到的？不需要各种高大上的图片处理软件，只需 Winsnap ，它可以在截图的时候自动帮你加上背景阴影，然后帮你自动复制到剪切板； 它可以使用全屏、应用程序、窗口、对象等捕捉模式，更牛的是它还可以在截图的时候同时选择和捕捉多个对象，按住 Ctrl或 Shift选择多个窗口或对象…这个就比较厉害了，不信你试试？ 5. CmderCmder 是一个美观又实用的命令行工具，它支持大部分Linux命令，支持ssh连Linux，还可以在它的窗口中新建cmd和powershell，更多玩法等你来战~ 比较方便的是在安装目录下 \\config\\user-aliases.cmd设置 alias 别名，比如参见的 Git 操作： 12345678910111213ga=git add $*gb=git branch $*gc=git commit $*gch=git checkout $*gd=git diff $*gl=git log $*gs=git status $* 还可以将cmder配置到右键菜单，快捷在当前目录打开cmder，方法是先把这个地址加到系统的path环境变量里面，比如我的是 D:cmder，然后右键 Cmder.exe属性-兼容性-以管理员身份运行此程序，再重新打开 Cmder.exe输入 Cmder.exe/REGISTER ALL就行了~ 记得安装完在配置 Setting-Startup-Environment里面加上 setLANG=zh_CN.UTF8，否则输出的一些中文会乱码； 6. Typora使用过很多 Markdown 编辑器，最后选择了 Typora，与主流编辑器一边编辑一边预览的形式，Typora 是将编辑和预览合并到一起，简洁大方，目光也不需要在复杂的编辑区和预览区中来回切换了，只有当焦点移入的时候才显示 Markdown 语法； 另外 Typora 还支持 Latex、 [TOC]动态目录、拖拽图片自动生成本地预览链接、自定义主题等方便的功能； 7. Quick LookQuickLook 是在 Microsoft Store 里面下载的一个速览工具，有时候打开一个PDF、TXT、图片之类的需要等关联程序启动半天，有了它之后只要选中目标文件，按空格，就可以快速预览了，速度非常快，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML等格式； 用它来看一些代码什么的，甚至不需要 Sublime\\VSCode 启动就可以直接看了，如果只是速览一下的话是非常适合的了。 8. Myper SplashMyper Splash 也是可以在 Microsoft Store 里面下载的一款高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用，再加上简洁美观的UI/UX设计，让你体验一见钟情的感觉。 另外 MyperSplash 可以设置自动每天自动更换壁纸或锁屏，每天早晨来到办公室点亮屏幕就可以看到 Awesome 的锁屏或壁纸，让你带着好心情开启一天的工作。 9. GifCam / ScreenToGif相信大家都有过需要截一个 Gif 的时候，这里有两个免费 Gif 屏幕录制工具都很不错，小而美的 GifCam 和开源强大的 ScreenToGif ； 10. Free Download ManageFree Download Manage (FDM) 是一款免费的下载工具，如果你已经受够了国内一些软件的广告和限速，那么 FDM 是一个不错的选择，另外多线程、断点续传、计划任务等功能让 FDM 值得推介。 11. SourcetreeSourcetree 是跨平台免费的 Git 客户端管理工具，如果受够了手打各种 Git 操作命令，那么 Sourcetree 是一个不错的选择； Sourcetree 可以大大简化你的代码操作，特别是对于一些不甚熟悉 Git 命令的人来说灰常实用；一些对 Git 操作比较熟练的用户也可以用它来提升效率，减少出错。","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"software","slug":"software","permalink":"http://kobin.top/tags/software/"},{"name":"软件","slug":"软件","permalink":"http://kobin.top/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"centOS7安装Java环境","slug":"others-centOS7安装Java环境","date":"2020-05-22T16:28:42.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"others-centOS7安装Java环境/","link":"","permalink":"http://kobin.top/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/","excerpt":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程","text":"记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程 1. 选择合适的jdk版本 jdk下载地址 选择一下版本获取下载链接 2. 下载1wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b 此链接地址可能失效，请自行在步骤1中获取最新下载链接 下载后检查安装包大小是否符合预期（判断安装包是否损坏） 1ls -lht 3. 安装3.1. 创建安装目录： 1mkdir /usr/local/java/ 3.2 解压到安装目录： 1tar -zxvf jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b -C /usr/local/java 4. 配置环境变量打开profile文件 1vim /etc/profile 在末尾添加一下代码： 1234export JAVA_HOME=/usr/local/java/jdk1.8.0_251export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使环境变量生效 1source /etc/profile 添加软链接 1ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java 验证是否安装成功 1java -version","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"java","slug":"java","permalink":"http://kobin.top/tags/java/"}]},{"title":"post","slug":"javascript-ECMAScript特性分析","date":"2020-05-22T14:59:54.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"javascript-ECMAScript特性分析/","link":"","permalink":"http://kobin.top/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"post","slug":"框架相关-virtual-dom","date":"2020-05-13T17:28:22.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"框架相关-virtual-dom/","link":"","permalink":"http://kobin.top/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3-virtual-dom/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"typeof 实现原理","slug":"basic-typeof","date":"2020-05-06T23:11:22.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"basic-typeof/","link":"","permalink":"http://kobin.top/basic-typeof/","excerpt":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如","text":"typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断 number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof在判断一个 object 的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如 123let s = new String(\"abc\");typeof s === \"object\"; // trues instanceof String; // true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 `null`：所有机器码均为0 `undefined`：用 −2^30 整数来表示所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话 1null instanceof null; // TypeError: Right-hand side of 'instanceof' is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留 bug，可以参考 typeof. 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括 symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是 Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 123456789Object.prototype.toString.call(1); // \"[object Number]\"Object.prototype.toString.call(\"hi\"); // \"[object String]\"Object.prototype.toString.call(&#123; a: \"hi\" &#125;); // \"[object Object]\"Object.prototype.toString.call([1, \"a\"]); // \"[object Array]\"Object.prototype.toString.call(true); // \"[object Boolean]\"Object.prototype.toString.call(() =&gt; &#123;&#125;); // \"[object Function]\"Object.prototype.toString.call(null); // \"[object Null]\"Object.prototype.toString.call(undefined); // \"[object Undefined]\"Object.prototype.toString.call(Symbol(1)); // \"[object Symbol]\" instanceof 操作符的实现原理之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 123let person = function () &#123;&#125;;let nicole = new person();nicole instanceof person; // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 123456let person = function () &#123;&#125;;let programmer = function () &#123;&#125;;programmer.prototype = new person();let nicole = new programmer();nicole instanceof person; // truenicole instanceof programmer; // true instanceof 实现原理： 12345678910111213function new_instance_of(leftVaule, rightVaule) &#123; let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值 while (true) &#123; if (leftVaule === null) &#123; return false; &#125; if (leftVaule === rightProto) &#123; return true; &#125; leftVaule = leftVaule.__proto__; &#125;&#125; 总结简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。","categories":[{"name":"基础","slug":"基础","permalink":"http://kobin.top/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://kobin.top/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"一些 JS 关键技术的底层实现汇总","slug":"basic-js-basic-implementation","date":"2020-05-06T22:40:35.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"basic-js-basic-implementation/","link":"","permalink":"http://kobin.top/basic-js-basic-implementation/","excerpt":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。","text":"在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。 Function.prototype.call() Function.prototype.apply() Function.prototype.bind() new 的原理 reduce 实现原理 双向绑定 继承 Object.create instanceof 实现 Array.isArray 实现 getOwnPropertyNames 实现 Promise 实现 防抖/节流 函数柯里化实现 实现简单深拷贝 Function.prototype.call()call() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。 语法：fun.call(thisArg, arg1, arg2, ...) 1234567891011121314151617181920212223242526272829303132/** * call的实现原理 */const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;Function.prototype.mcall = function (context) &#123; context = context ? Object(context) : getGlobal(); context.fn = this; let args = [...arguments].slice(1); let r = context.fn(...args); delete context.fn; return r;&#125;;/** * 一个用call实现继承的例子 * @param &#123;*&#125; name * @param &#123;*&#125; price */function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Fruit(name, price) &#123; Product.mcall(this, name, price); this.category = \"fruit\";&#125;var apple = new Fruit(\"apple\", 5);console.log(apple); Function.prototype.apply()apply()调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数. 语法： func.apply(thisArg, [argsArray]) 1234567891011121314151617181920212223242526272829303132333435const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * apply原理 */Function.prototype.apply = function (context, arr) &#123; context = context ? Object(context) : getGlobal(); console.log(\"context\", context); context.fn = this; // let args = [...arguments][1]; if (!arr) &#123; let r = context.fn(); delete context.fn; return r; &#125; let r = context.fn(...arr); delete context.fn; return r;&#125;;//使用例子var array = [\"a\", \"b\"];var elements = [0, 1, 2];array.push.apply(array, elements);console.log(\"array\", array); // [\"a\", \"b\", 0, 1, 2]function A(x, y) &#123; console.log(this.b + \" \" + x + \" \" + y);&#125;var B = &#123; b: 1 &#125;;A.apply(B, [2, 3]); Function.prototype.bind()bind()方法创建一个新函数, 在调用时设置 this 关键字为提供的值。 语法：fun.bind(thisArg, arg1, arg2, ...) 12345678910111213141516171819202122const getGlobal = function () &#123; if (typeof self !== \"undefined\") return self; if (typeof window !== \"undefined\") return window; if (typeof global !== \"undefined\") return global;&#125;;/** * bind实现原理 */Function.prototype.bind = function (context) &#123; context = context ? Object(context) : getGlobal(); const me = this; const args = [...arguments].slice(1); return function () &#123; me.apply(context, [...args, ...arguments]); &#125;;&#125;;function A(x, y) &#123; console.log(this.b + \", \" + x + \", \" + y);&#125;var B = &#123; b: 1 &#125;;let fnc = A.bind(B, 2); //1 2 3fnc(3); new 的原理在了解 new 原理之前先看看 js 的内部机制图 我们需要知道当 new 的时候做了什么事情 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 new 没法重写，这里是有 mockNew 函数来模拟 1234567891011121314151617181920212223242526272829303132/** * new实现原理 */function mockNew() &#123; //创建一个实例 const obj = &#123;&#125;; //获得构造器 const constructor = [].shift.call(arguments); //实现继承，实例可以访问构造器熟悉 obj.__proto__ = constructor.prototype; //调用构造器，改变this指向为实例 const res = constructor.apply(obj, arguments); //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象 return res instanceof Object ? res : obj;&#125;/** * 使用例子 * @param &#123;*&#125; color * @param &#123;*&#125; name */function Car(color, name) &#123; this.color = color; return &#123; name: name, &#125;;&#125;let car = mockNew(Car, \"black\", \"BMW\");console.log(car.color);// undefinedconsole.log(car.name);// \"BMW\" reduce 实现原理12345678910111213141516171819202122232425262728293031323334/** * 实现原理 */Array.prototype.mockReduce = function (callback) &#123; const length = this.length; let reducer = undefined, //累加器，最终返回这个值 k = 0, //数组下标 initVal = [...arguments].length &gt; 1 ? [...arguments][1] : undefined; //传入reduce的初始值 if (typeof callback !== \"function\") &#123; throw new TypeError(callback + \" is not a function\"); &#125; if (length === 0 &amp;&amp; !initVal) &#123; throw new TypeError(\"Reduce of empty array with no initial value\"); &#125; if (initVal) &#123; reducer = initVal; &#125; else &#123; reducer = this[0]; k++; &#125; while (k &lt; length) &#123; if (this.hasOwnProperty(k)) &#123; const kValue = this[k]; reducer = callback(reducer, kValue); &#125; k++; &#125; return reducer;&#125;;const rReduce = [].reduce((a, b) =&gt; a + b, 3);const mReduce = [].mockReduce((a, b) =&gt; a + b);console.log(rReduce, mReduce); 双向绑定defineProperty实现 123456789101112131415161718// 数据const data = &#123; text: \"hello\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持Object.defineProperty(data, \"text\", &#123; // 数据变化 --&gt; 修改视图 set(newVal) &#123; input.value = newVal; p.innerHTML = newVal; &#125;,&#125;);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; data.text = e.target.value;&#125;); proxy实现 12345678910111213141516171819202122// 数据const data = &#123; text: \"default\",&#125;;const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");// 数据劫持const handler = &#123; set(target, key, value) &#123; target[key] = value; // 数据变化 --&gt; 修改视图 input.value = value; p.innerHTML = value; return value; &#125;,&#125;;const proxy = new Proxy(data, handler);// 视图更改 --&gt; 数据变化input.addEventListener(\"keyup\", function (e) &#123; proxy.text = e.target.value;&#125;); 继承12345678910111213141516171819202122232425function inheritPrototype(subType, superType) &#123; var protoType = Object.create(superType.prototype); //创建对象 protoType.constructor = subType; //增强对象 subType.prototype = protoType; //指定对象&#125;function SuperType(name) &#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function () &#123; alert(this.name);&#125;;function SubType(name, age) &#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function () &#123; alert(this.age);&#125;;var instance = new SubType(\"Bob\", 18);instance.sayName();instance.sayAge(); Object.create1234567891011121314151617181920if (typeof Object.create !== \"function\") &#123; Object.create = function (prototype, properties) &#123; if (typeof prototype !== \"object\") &#123; throw TypeError(); &#125; function Ctor() &#123;&#125; Ctor.prototype = prototype; var o = new Ctor(); if (prototype) &#123; o.constructor = Ctor; &#125; if (properties !== undefined) &#123; if (properties !== Object(properties)) &#123; throw TypeError(); &#125; Object.defineProperties(o, properties); &#125; return o; &#125;;&#125; instanceof 实现原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null 1234567891011// L 表示左表达式，R 表示右表达式function instance_of(L, R) &#123; var O = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; // 这里重点：当 O 严格等于 L 时，返回 true if (O === L) return true; L = L.__proto__; &#125;&#125; Array.isArray 实现12345Array.myIsArray = function (o) &#123; return Object.prototype.toString.call(Object(o)) === \"[object Array]\";&#125;;console.log(Array.myIsArray([])); // true getOwnPropertyNames 实现123456789101112131415if (typeof Object.getOwnPropertyNames !== \"function\") &#123; Object.getOwnPropertyNames = function (o) &#123; if (o !== Object(o)) &#123; throw TypeError(\"Object.getOwnPropertyNames called on non-object\"); &#125; var props = [], p; for (p in o) &#123; if (Object.prototype.hasOwnProperty.call(o, p)) &#123; props.push(p); &#125; &#125; return props; &#125;;&#125; Promise 实现实现原理：其实就是一个发布订阅者模式 构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数 then 时收集依赖，将回调函数收集到 成功/失败队列 executor 函数中调用 resolve/reject 函数 resolve/reject 函数被调用时会通知触发队列中的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209const isFunction = variable =&gt; typeof variable === 'function';// 定义Promise的三种状态常量const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';class MyPromise &#123; // 构造函数，new 时触发 constructor(handle: Function) &#123; try &#123; handle(this._resolve, this._reject); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 状态 pending fulfilled rejected private _status: string = PENDING; // 储存 value，用于 then 返回 private _value: string | undefined = undefined; // 失败队列，在 then 时注入，resolve 时触发 private _rejectedQueues: any = []; // 成功队列，在 then 时注入，resolve 时触发 private _fulfilledQueues: any = []; // resovle 时执行的函数 private _resolve = val =&gt; &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; this._status = FULFILLED; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* * 如果resolve的参数为Promise对象， * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变 * 且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; runRejected(err); &#125; ); &#125; else &#123; this._value = val; runFulfilled(val); &#125; &#125;; // 异步调用 setTimeout(run); &#125;; // reject 时执行的函数 private _reject = err =&gt; &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run); &#125;; // then 方法 then(onFulfilled?, onRejected?) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 const fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; const res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 const rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; const res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // catch 方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // finally 方法 finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125; // 静态 resolve 方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 静态 reject 方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 静态 all 方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; // 返回值的集合 let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125;&#125; 防抖/节流防抖函数 onscroll 结束时触发一次，延迟执行123456789101112131415function debounce(callback, wait) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; callback.apply(context, args); &#125;, wait); &#125;;&#125;// 使用window.onscroll = debounce(function () &#123; console.log(\"debounce\");&#125;, 1000); 节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样1234567891011121314function throttle(callback, delay) &#123; var prevTime = Date.now(); return function () &#123; var curTime = Date.now(); if (curTime - prevTime &gt; delay) &#123; callback.apply(this, arguments); prevTime = curTime; &#125; &#125;;&#125;// 使用window.onscroll = throttle(function () &#123; console.log(\"throtte\");&#125;, 1000); 函数柯里化实现其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。应用场景： 延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数） 动态创建函数 （参数不够时会返回接受剩下参数的函数） 参数复用（每个参数可以多次复用） 123456789101112const curry = (fn) =&gt; (judge = (...args) =&gt; args.length &gt;= fn.length ? fn(...args) : (...arg) =&gt; judge(...args, ...arg));const sum = (a, b, c, d) =&gt; a + b + c + d;const currySum = curry(sum);currySum(1)(2)(3)(4); // 10currySum(1, 2)(3)(4); // 10currySum(1)(2, 3)(4); // 10 实现简单深拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getType(obj) &#123; const str = Object.prototype.toString.call(obj); const map = &#123; \"[object Boolean]\": \"boolean\", \"[object Number]\": \"number\", \"[object String]\": \"string\", \"[object Function]\": \"function\", \"[object Array]\": \"array\", \"[object Date]\": \"date\", \"[object RegExp]\": \"regExp\", \"[object Undefined]\": \"undefined\", \"[object Null]\": \"null\", \"[object Object]\": \"object\", &#125;; if (obj instanceof Element) &#123; // 判断是否是dom元素，如div等 return \"element\"; &#125; return map[str];&#125;function deepCopy(original) &#123; const type = getType(original); let copy; switch (type) &#123; case \"array\": return copyArray(original, copy); case \"object\": return copyObject(original, copy); case \"function\": return copyFunction(original, copy); default: return original; &#125;&#125;function copyArray(original, copy = []) &#123; for (const [index, value] of original.entries()) &#123; copy[index] = deepCopy(value); &#125; return copy;&#125;function copyObject(original, copy = &#123;&#125;) &#123; for (const [key, value] of Object.entries(original)) &#123; copy[key] = deepCopy(value); &#125; return copy;&#125;function copyFunction(original, copy = () =&gt; &#123;&#125;) &#123; const fn = eval(original.toString()); fn.prototype = original.prototype; return fn;&#125;const arr1 = [1, 2, [3, 4], &#123; i: 6, j: 6 &#125;, (k, m) =&gt; k + m];console.log(deepCopy(arr1));","categories":[{"name":"基础","slug":"基础","permalink":"http://kobin.top/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://kobin.top/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"}]},{"title":"通过iframe下载文件如何判断下载完成","slug":"basic-iframe-download-complete","date":"2019-07-06T22:24:20.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"basic-iframe-download-complete/","link":"","permalink":"http://kobin.top/basic-iframe-download-complete/","excerpt":"当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。","text":"问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。 123456789var url = \"http://www.example.com/file.zip\";var iframe = document.createElement(\"iframe\");iframe.src = url;iframe.style.display = \"none\";iframe.onload = function () &#123; console.debug(\"start downloading...\"); document.body.removeAttribute(iframe);&#125;;document.body.appendChild(iframe); 当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。 这里说一下 Content-disposition： Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行 解决思路一：利用 cookie后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。 解决思路二：添加 header 配置123456// 不让浏览器自动检测文件类型// 说明资料：http://drops.wooyun.org/tips/1166response.addHeader(\"X-Content-Type-Options\", \"nosniff\");// 提示浏览器不让其在frame或iframe中加载资源的文件内容// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Optionsresponse.addHeader(\"X-Frame-Options\", \"deny\"); 但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。 解决思路三：轮询监听 readyState定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。 12345678910111213var timer = setInterval(function () &#123; iframe = document.getElementById(\"iframedownload\"); var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // Check if loading is complete if ( iframeDoc.readyState == \"complete\" || iframeDoc.readyState == \"interactive\" ) &#123; loadingOff(); clearInterval(timer); return; &#125;&#125;, 4000); 总结第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。","categories":[{"name":"基础","slug":"基础","permalink":"http://kobin.top/categories/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://kobin.top/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"nginx初试","slug":"others-nginx-basic","date":"2019-05-25T18:35:46.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"others-nginx-basic/","link":"","permalink":"http://kobin.top/others-nginx-basic/","excerpt":"“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。” 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。","text":"“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。” 作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。 一、初试 Nginx想要成为一个合格的大前端，又怎能不会 Nginx 呢？ Nginx 从 2004 年发展至今，从一开始的完善沉淀，再迅速蹿升为“网红”，再到现在占服务器市场中接近 1/3 份额，成为互联网网站搭建的必选技术之一。发展可谓相当迅速，之所以能取得如此成就，主要还是相对于其他 HTTP 服务器其有着不可替代的优势： 支持海量高并发：采用 IO 多路复用 epoll。官方测试 Nginx 能够支持 5 万并发链接，实际生产环境中可以支撑 2-4 万并发连接数。 内存消耗少：在主流的服务器中 Nginx 目前是内存消耗最小的了，比如我们用 Nginx+PHP，在 3 万并发链接下，开启 10 个 Nginx 进程消耗 150M 内存。 免费使用可以商业化：Nginx 为开源软件，采用的是 2-clause BSD-like 协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 而对于前端童鞋，在实际工作上，更倾向于用 Nodejs 来搭建服务器，进而实现一些需求，对 Nginx 有天然的疏远感。的确，Nginx 中的绝大部分功能，如果单纯的使用 Node.js 也可以满足和实现。但实际上，Nginx 和 Node.js 并不冲突，都有自己擅长的领域：Nginx 更擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长于上层具体业务逻辑的处理。如果将两者组合一起，则可以更加助力前端开发。 开始动手之前先交代下具体的系统环境： 系统环境说明：服务器：阿里云 ECS操作系统： CentOS 7.4 64 位Nginx 版本：nginx/1.16.1 二、Nginx 的安装首先可以查看下系统的 yum 源下是否有可用的 Nginx 包 1yum list | grep nginx 如果结果类似如图内容，说明 yum 源是存在的 如果不存在或者没有需要的 Nginx 版本，则可以自己配一个 yum 源。 打开终端，输入 1vim /etc/yum.repos.d/nginx.repo 往里面添加如下脚本： 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/$&#123;OS&#125;/$&#123;OSRELEASE&#125;/$basearch/gpgcheck=0enabled=1 需要注意：OS: 操作系统名称，如：centosOSRELEASE: 操作系统版本，如： 7对应的 baseurl: baseurl=http://nginx.org/packages/centos/7/$basearch/ 保存修改后，就可以安装 Nginx 了，安装命令： 1yum install nginx 安装完成后查看安装的 Nginx 版本: 1nginx -v 三、Nginx 基本配置安装完 Nginx 后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看： 1rpm -ql nginx rpm 是 linux 的 rpm 包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到 nginx 的所有安装位置了。 下面重点罗列下一些重要的文件 nginx.conf nginx.conf 文件是 Nginx 总配置文件，在我们搭建服务器时经常调整的文件。 进入 etc/nginx 目录下，然后用 vim 进行打开 12cd /etc/nginxvim nginx.conf 下面是文件的详细注释: 12345678910111213141516171819202122232425262728293031323334#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件&#125; default.conf进入 conf.d 目录，打开 default.conf，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 四、Nginx 常用操作启动 Nginx 服务 Nginx 直接启动（CentOS7.4 以上版本） 1nginx 使用 systemctl 命令启动 1systemctl start nginx.service 查看服务运行状态 1ps aux | grep nginx 关停 Nginx 服务 立即停止服务 1nginx -s stop 这种方法比较强硬，无论进程是否在工作，都直接停止进程。 从容停止服务 1nginx -s quit 这种方法较 stop 相比就比较温和一些了，需要进程完成当前工作后再停止。 killall 方法杀死进程 1killall nginx 这种方法也是比较野蛮的，直接杀死进程。 systemctl 停止 1systemctl stop nginx.service 重启 Nginx 服务1systemctl restart nginx.service 重新载入配置文件在重新编写或者修改 Nginx 的配置文件后，需要作一下重新载入，这时候可以用这个命令。 1nginx -s reload 查看端口号如果 80 端口被占用，可以使用此命令查看端口占用情况 1netstat -tlnp 80 五、自定义错误页面以及访问控制 多错误指向一个页面 1error_page 500 502 503 504 /50x.html; 单独为错误置顶处理方式 1error_page 404 /404_error.html; 把错误码换成一个地址 1error_page 404 http://kobin.top; 简单实现访问控制 有时候我们的服务器只允许特定主机访问，比如内部 OA 系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些 IP 访问，我们可以直接在 location 里进行配置。 可以直接在 default.conf 里进行配置。 1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 指令优先级 1234location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置表示只允许45.76.202.231进行访问，其他的 IP 是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？ 会发现所有的 IP 都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。 复杂访问控制权限匹配 在工作中，访问权限的控制需求更加复杂，例如，对于网站下的 img（图片目录）是运行所有用户访问，但对于网站下的 admin 目录则只允许公司内部固定 IP 访问。这时候仅靠 deny 和 allow 这两个指令，是无法实现的。我们需要 location 块来完成相关的需求匹配。 上面的需求，配置代码如下： 123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; 使用正则表达式设置访问权限 只有精确匹配(=)有时是完不成我们的工作任务的，比如现在我们要禁止访问所有 php 的页面，php 的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。 代码如下： 123location ~\\.php$ &#123; deny all; &#125; 这样我们再访问的时候就不能访问以 php 结尾的文件了。是不是让网站变的安全很多了那？ 六、Nginx 配置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供 Web 服务，并且互不干扰。用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上。可以大大节约服务器成本与维护成本。 基于端口号配置虚拟主机 基于端口号来配置虚拟主机，算是 Nginx 中最简单的一种方式了。原理就是 Nginx 监听多个端口，根据不同的端口号，来区分不同的网站 我习惯在 conf.d 里新建一个配置文件来配置新的虚拟主机，但也可以配置在主配置 etc/nginx/nginx.conf里，也可以配置在etc/nginx/conf.d/default.conf里。 12345678server&#123; listen 8088; server_name localhost; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于 IP 的虚拟主机 基于 IP 和基于端口的配置几乎一样，只是把server_name选项，配置成 IP 就可以了。 12345678server&#123; listen 80; server_name 112.74.164.244; location / &#123; root /usr/share/nginx/html/html8001; index index.html; &#125;&#125; 基于域名的虚拟主机 域名设置虚拟主机也非常简单，主要操作的是配置文件的 server_name 项 12345678910111213141516server&#123; listen 80; server_name nginx.kobin.com; location / &#123; root /usr/share/nginx/html/html; index index.html index.htm; &#125;&#125;server&#123; listen 80; server_name nginx2.kobin.com; location / &#123; root /usr/share/nginx/html/html8001; index index.html index.htm; &#125;&#125; 七、Nginx 反向代理的设置什么是反向代理？ 互联网应用基本都基于 CS 基本结构，即 client 端和 server 端。代理其实就是在 client 端和真正的 server 端之前增加一层提供特定服务的服务器，即代理服务器。 在了解反向代理前先了解什么是正向代理。 正向代理 翻墙工具就是一个典型的正向代理工具。它会把我们不能访问的墙外服务器 server 的网页请求，代理到一个可以访问该网站的代理服务器 proxy，这个代理服务器 proxy 把墙外服务器 server 上的网页内容获取，再转发给客户。具体的流程如下图。 其特点如下： 客户端和代理服务器可以直接互相访问，属于一个 LAN（局域网） 代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器 代理服务器通过代理用户端的请求来向域外服务器请求响应内容。 一句话总结： 代理的是客户端 反向代理 反向代理正好相反，客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。 其特点如下： 代理服务器和真正 server 服务器可以直接互相访问，属于一个 LAN（服务器内网） 代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作； 代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。 一句话总结： 代理的是服务器 反向代理的好处： 安全及权限使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须通过 Nginx。可以通过在 Nginx 层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。 负载均衡一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配 简单实现反向代理 举个例子，我们访问 home.kobin.top 这个网站，然后反向代理到 baidu.com 上。可做如下配置： 1234567server&#123; listen 80; server_name home.kobin.top; location / &#123; proxy_pass https://www.baidu.com; &#125;&#125; 结果如下： 其他常用的反向代理配置： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置 Nginx 与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间。 proxy_send_timeout：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的 Location 和 Refresh。 八、Nginx 适配移动端与 PC 端Nginx 通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是 PC 端，进而展示不同的页面给用户。 在 conf.d 目录下新建一个 demo.conf 文件，内容如下： 1234567891011server &#123; listen 80; server_name blog.kobin.top; location / &#123; root /yangling/app/pc; # 默认展示PC端页面 if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') &#123; # 如果匹配到mobile端的user_agent则展示mobile页面 root /yangling/app/mobile; &#125; index index.html; &#125;&#125; 九、Nginx 实现 Gzip 压缩Gzip 是网页的一种网页压缩技术，经过 gzip 压缩后，页面大小可以变为原来的 30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip 网页压缩的实现需要浏览器和服务器的支持。 gzip 是需要服务器和浏览器同事支持的。当浏览器支持 gzip 压缩时，会在请求消息中包含 Accept-Encoding:gzip,这样 Nginx 就会向浏览器发送听过 gzip 后的内容，同时在相应信息头中加入 Content-Encoding:gzip，声明这是 gzip 后的内容，告知浏览器要先解压后才能解析输出。 gzip 配置： gzip : 该指令用于开启或 关闭 gzip 模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。 gzip_comp_level : gzip 压缩比，压缩级别是 1-9，1 的压缩级别最低，9 的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的 User-Agent 不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的 Content-length 中进行获取。 gzip_http_version：识别 HTTP 协议版本，其值可以是 1.1.或 1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩。 gzip_vary : 用于在响应消息头中添加 Vary：Accept-Encoding,使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩。 简单配置： 123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用 gizp 模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和 CSS 文件进行压缩输出。 十、Nginx 与跨域请求举个例子：在 a.com 页面中有请求 b.com 的接口http://b.com/getHomeData, 出现了跨域问题。当然这种跨域问题的处理方式很多，这里主要说下用 Nginx 如何解决。 在 a.com 启个 Nginx 服务，配置如下： 12345678910server &#123; listen 80; server_name a.com; #请求跨域，这里约定代理请求url path是以/apis/开头 location ^~/apis/ &#123; # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配 rewrite ^/apis/(.*)$ /$1 break; proxy_pass https://www.b.com/; &#125;&#125; 这时请求接口 URL 换成http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。 十一、Nginx 与合并请求通过nginx-http-concat插件可以实现将多个资源请求合并为一个请求，达到性能优化目的。 十二、Nginx 与图片处理通过ngx_http_image_filter_module插件实现日常对图片的处理，包括缩放、裁剪、旋转、图片质量等的控制。","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"全栈","slug":"全栈","permalink":"http://kobin.top/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"http://kobin.top/tags/nginx/"}]},{"title":"文章摘录","slug":"collection","date":"2019-05-06T15:35:35.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"collection/","link":"","permalink":"http://kobin.top/collection/","excerpt":"在这里记录一些看到的好文章好博客","text":"在这里记录一些看到的好文章好博客 龙恩 0707 cdn 全栈修炼 前端进阶之道 大前端面试宝典 - 图解前端 未来可期的 TypeScript 别再说虚拟 DOM 快了，要被打脸的 深入理解虚拟 DOM，它真的不快 Deep In React 之详谈 React 16 Diff 策略(二) ReactFiber 在并发模式下的运行机制 前端浏览器输入 URL 后发生什么 大公司如何部署前端代码 Vuex、Flux、Redux、Redux-saga、Dva、MobX累死累活做业务，绩效还不怎么样，我只能帮你到这了……","categories":[{"name":"面试","slug":"面试","permalink":"http://kobin.top/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://kobin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"基于hexo搭建个人博客并使用GitHub Actions一键发布到GitHub pages & 阿里云ECS","slug":"others-hexo","date":"2019-04-28T15:15:23.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"others-hexo/","link":"","permalink":"http://kobin.top/others-hexo/","excerpt":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装前提安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序： Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本) Git 注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容 安装 Hexo使用 npm: 1$ npm install -g hexo-cli 使用 yarn: 1$ yarn global add hexo-cli 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 常用命令new新建一篇文章 1$ hexo new [layout] &lt;title&gt; generate生成静态文件。 1$ hexo generate publish发表草稿。 1$ hexo publish [layout] &lt;filename&gt; server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 1$ hexo server deploy部署网站。 1$ hexo deploy clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 1$ hexo clean list列出网站资料。 1$ hexo list &lt;type&gt; 注： 更多命令见官网 部署 GitHub pages如果您只是想部署到GitHub Actions上，那么可以直接用这节的方法。如果还想部署到阿里云等私人服务器上，那么可以跳过这步，直接看下一节。 新建 GitHub 项目打开 GitHub 点击右上角的new repository 然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建 安装 hexo-deployer-git。1$ npm install hexo-deployer-git --save 修改_config.yml 配置1234deploy: type: git repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git branch: master 执行命令执行 hexo deploy 将生成的文件部署到上一步配置的仓库对应的分支上去。 1hexo clean &amp;&amp; hexo deploy 至此，已经实现了个人博客的搭建并完成了一键发布到GitHub Pages的功能，如果只需要发布到GitHub Pages，那么至此已经可以愉快地写文章了。 但是由于总所周知的原因，GitHub在国内的访问速度总是时好时坏，不够畅快。 那么如果你手里恰好有闲置的云服务器，那么接下去就更进一步吧！🙂 GitHub Actions登场GitHub Actions 是 GitHub 于2018年10月推出的持续集成服务。功能非常强大，具体的基础用法不赘述，可以参阅阮一峰老师的教程。 这里主要介绍如何配置GitHub Actions实现自动部署功能。 创建workflow 文件GitHub Actions 的配置文件叫做 workflow 文件, 存放在代码仓库的.github/workflows目录。 新建.github/workflows/deploy.yml, 具体配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152name: Hexo build and deployon: push: branches: - blog # blog分支是本人的hexo源码分支jobs: build: runs-on: ubuntu-latest steps: # 切换分支 - name: Checkout uses: actions/checkout@v2 # If you're using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly. with: persist-credentials: false # checkout到你的hexo代码分支 ref: blog # hexo需要加载内部子模块 submodules: true # 使用 node:10 - name: use Node.js 10 uses: actions/setup-node@v1 with: node-version: 10 # 安装npm包 &amp; 生成静态文件 - name: Install and publish run: | npm install npm run build # 将静态文件部署到阿里云 - name: Deploy to aliyun server uses: easingthemes/ssh-deploy@v2.0.7 env: SSH_PRIVATE_KEY: $&#123;&#123; secrets.ALIYUN_SERVER_ACCESS_TOKEN &#125;&#125; ARGS: \"-avz --delete\" SOURCE: \"public\" REMOTE_HOST: $&#123;&#123; secrets.ALIYUN_SERVER_HOST &#125;&#125; REMOTE_USER: \"root\" TARGET: \"/code/hexo-blog\" # 静态资源存放目录 # 将静态文件部署到github pages - name: Deploy to Github Pages uses: JamesIves/github-pages-deploy-action@releases/v3 with: ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BASE_BRANCH: blog BRANCH: master FOLDER: public 配置参数说明 ALIYUN_SERVER_HOST： 阿里云服务器公网IP； ALIYUN_SERVER_ACCESS_TOKEN：阿里云.ssh下的私钥(id_rsa); 如果未生成过，可以执行如下命令：1ssh-keygen -m PEM -t rsa -b 4096 把公钥复制一份到authorized_keys中:12cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys ACCESS_TOKEN: GitHub 密钥, 按照官方文档生成一个秘钥。 以上三个参数都保存到自己仓库-&gt;settings-&gt;Secrets里面： 构建结果将整个仓库推送到GitHub，GitHub 发现了 workflow 文件以后，就会自动运行。 至此，我们已经将博客部署到GitHub Actions和阿里云上了。阿里云上我们可以使用Nginx托管静态资源： 12345678server &#123; listen 80; server_name kobin.top; location / &#123; root /code/hexo-blog/public; # 静态资源存放目录 index index.html; &#125;&#125; 一切大功告成！收工😄","categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://kobin.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"word-wrap,word-break,white-space强制换行和不换行总结","slug":"css-强制换行与不换行","date":"2017-05-15T17:30:05.000Z","updated":"2020-05-28T15:29:37.480Z","comments":true,"path":"css-强制换行与不换行/","link":"","permalink":"http://kobin.top/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/","excerpt":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的","text":"我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的 word-wrap 语法： word-wrap: normal(默认) | break-word normal: 允许内容顶开指定的容器边界 break-word: 内容将在边界内换行。必要时会触发 word-break 说明word-wrap 是控制是否“为词断行”的，设置或检索当前行超过指定容器的边界时是否断开转行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。 范例congratulation 这个单词属于长串英文，word-wrap:break-word 整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断，这就是对于长串文字不起作用的解释。word-wrap:normal 是默认情况，英文单词不被拆开。 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（如果为 td,th 加上宽度 word-wrap 在 IE 下是能够发挥效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。 word-break word-break: normal(默认) | break-all | keep-all normal: 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。 break-all: 该行为与亚洲语言的 normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本。 keep-all: 与所有非亚洲语言的 normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 说明word-break:break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题（恰恰弥补了上面 word-wrap:break-word 对于长串文字不起作用的缺陷） 范例继续以上面 congratulation 这个单词属于长串英文，word-break:break-all 它会把单词截断，该行末端就会变成类似 conra(congratulation 的前端部分)，下一行为 tulation（conguatulation）的后端部分了。word-break:keep-all，是指 Chinese, Japanese, and Korean 不断词。即只用此时，不用 word-wrap，中文就不会换行了。（英文语句正常。） 结论作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（经测试 Chrome 下 word-break:break-all 是有效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。Firefox,Opera 是无法识别 word-break 的，更不用提 Firefox 下的 th,td 中使用 word-break 的效果了。 white-space white-space: normal(默认) | pre | nowrap normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 说明 对于 pre 属性，其实就是 HTML 中连续的多个空白符会被合并，然后为了不让他合并（最常用的场合就是表示代码文字缩进）让其中的空白符继续保留而不需要我们增加额外的样式和标签来控制它的缩进和换行。pre 标签的原理也是一样的内部默认有了个 white-space:pre。 对于 nowrap 属性，这个是强制不换行核心，一般强制不换行就是利用这个属性。Firefox 的 div 和 td 中，以及 IE 的 div 中，均没有问题。唯一的瑕疵就是在 IE 的 td 中会有一个问题，如果 td 没有指定宽度，则 nowrap 仍然有效，如果 td 有宽度，并且文字中无标点、无空格（例如中文长串文字），nowrap 则不再有效。解决方式就是可以加 word-break:keep-all;可以解决此问题。 总结强制换行 div（块级元素） word-wrap:break-word; word-break:break-all; td,th 这类 table 元素 先为 table 设定 table-layout:fixed，基本上设定完这个属性后基本的换行问题都能够解决而不会出现 table 中 td,th 因为里面各个内容的多寡发生抢夺其他 td,th 宽度的情形发生。这时如果你依旧有强制换行问题，那么在此 td 中内部加一层 div，那么情况就会像上面讨论的方式来解决。 总结强制不换行 white-space:nowrap 在文字与 td 之间再套一层 div，然后使用 nowrap overflow:hidden 防止文字溢出","categories":[{"name":"css","slug":"css","permalink":"http://kobin.top/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://kobin.top/tags/css/"}]}],"categories":[{"name":"others","slug":"others","permalink":"http://kobin.top/categories/others/"},{"name":"基础","slug":"基础","permalink":"http://kobin.top/categories/%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/categories/%E9%9D%A2%E8%AF%95/"},{"name":"css","slug":"css","permalink":"http://kobin.top/categories/css/"}],"tags":[{"name":"software","slug":"software","permalink":"http://kobin.top/tags/software/"},{"name":"软件","slug":"软件","permalink":"http://kobin.top/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"java","slug":"java","permalink":"http://kobin.top/tags/java/"},{"name":"基础","slug":"基础","permalink":"http://kobin.top/tags/%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://kobin.top/tags/JavaScript/"},{"name":"全栈","slug":"全栈","permalink":"http://kobin.top/tags/%E5%85%A8%E6%A0%88/"},{"name":"nginx","slug":"nginx","permalink":"http://kobin.top/tags/nginx/"},{"name":"前端","slug":"前端","permalink":"http://kobin.top/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"http://kobin.top/tags/%E9%9D%A2%E8%AF%95/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://kobin.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"css","slug":"css","permalink":"http://kobin.top/tags/css/"}]}