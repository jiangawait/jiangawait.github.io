---
title: 前端如何学数据结构与算法 - 一篇讲完经典排序算法
date: 2020-06-30 16:48:08
tags: 数据结构与算法
categories: 数据结构与算法
---

本文基于JavaScript，实现常见的经典排序算法。

<!-- more -->

### 如何分析一个排序算法

学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。

分析一个排序算法，要从 执行效率、内存消耗、稳定性 三方面入手。

**执行效率**

1. 最好情况、最坏情况、平均情况时间复杂度

我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。 除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

2. 时间复杂度的系数、常数 、低阶

我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。

但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。

3. 比较次数和交换（或移动）次数

这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。

所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

**内存消耗**
也就是看空间复杂度。

还需要知道如下术语：

内排序：所有排序操作都在内存中完成；
外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
原地排序：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

**稳定性**
稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。 比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 前面；
不稳定：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序改变。 比如：a 原本在 b 前面，而 a = b，排序之后， a 在 b 后面；


### 十大经典排序算法

#### 1. 冒泡排序

给定一个N个元素的数组，冒泡法排序将：
如果元素大小关系不正确，交换这两个数（在本例中为a> b），
比较一对相邻元素（a，b），
重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）
到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N = 1。

**思路**

- 冒泡排序只会比较相邻的两个数据。
- 每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

**特点**

- 优点：排序算法的基础，简单实用易于理解。
- 缺点：比较次数多，效率较低。

**实现**

```js
const bubbleSort = (array) => {
  console.time("冒泡排序");
  for (let i = 0, len = array.length; i < len - 1; i++) {
    let hasSwap = false;// 提前退出冒泡循环的标志位
    // j < len - 1 - i 是因为内层的 len - 1 - i 到 length-1 的位置已经排好了，不需要再比较一次。
    for (let j = 0; j < len - 1 - i; j++) {
      if (array[j] > array[j + 1]) {
        const temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
        hasSwap = true
      }
    }
    // 如果本次没有冒泡了，说明数组已经有序，提前退出
    if (!hasSwap) break;
  }
  console.log("排序后数组", array);
  console.timeEnd("冒泡排序")
  return array;
}
const array = [9, 10, 7, 8, 4, 5, 6, 2, 3, 1];

bubbleSort(array)
```
