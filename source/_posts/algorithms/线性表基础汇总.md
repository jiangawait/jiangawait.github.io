---
title: 循序渐进数据结构与算法 - 线性表
date: 2019-12-05 14:25:24
tags:
 - 数据结构与算法
 - 数组
 - zhan
categories:
 - 数据结构与算法
---

数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。

本系列所有示例均采用JavaScript，旨在入门数据结构与算法。

本节主要是讲解下基础数据结构 - 线性表 相关的内容。

<!-- more -->

### 线性表 与 非线性表

线性表（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是典型线性表结构。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhenoep0wj30yg0pb76e.jpg)

非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。
![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfheoebis1j30yg0p0gn2.jpg)


### 数组

- 定义
数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。
数组的索引是从 0 开始的。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfkg30mej30em0fymxv.jpg)

- 特点
数组是用一组连续的内存空间来存储的。 所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。

低效的插入和删除。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)

- 实现
JavaScript 原生支持数组，而且提供了很多操作方法，JavaScript数组支持的方法可见下表：

| 方法          | 描述                                                 |
| :------------ | :--------------------------------------------------- |
| concat()      | 连接两个或更多的数组，并返回结果。                   |
| copyWithin()  | 从数组的指定位置拷贝元素到数组的另一个指定位置中。   |
| entries()     | 返回数组的可迭代对象。                               |
| every()       | 检测数值元素的每个元素是否都符合条件。               |
| fill()        | 使用一个固定值来填充数组。                           |
| filter()      | 检测数值元素，并返回符合条件所有元素的数组。         |
| find()        | 返回符合传入测试（函数）条件的数组元素。             |
| findIndex()   | 返回符合传入测试（函数）条件的数组元素索引。         |
| forEach()     | 数组每个元素都执行一次回调函数。                     |
| from()        | 通过给定的对象中创建一个数组。                       |
| includes()    | 判断一个数组是否包含一个指定的值。                   |
| indexOf()     | 搜索数组中的元素，并返回它所在的位置。               |
| isArray()     | 判断对象是否为数组。                                 |
| join()        | 把数组的所有元素放入一个字符串。                     |
| keys()        | 返回数组的可迭代对象，包含原始数组的键(key)。        |
| lastIndexOf() | 搜索数组中的元素，并返回它最后出现的位置。           |
| map()         | 通过指定函数处理数组的每个元素，并返回处理后的数组。 |
| pop()         | 删除数组的最后一个元素并返回删除的元素。             |
| push()        | 向数组的末尾添加一个或更多元素，并返回新的长度。     |
| reduce()      | 将数组元素计算为一个值（从左到右）。                 |
| reduceRight() | 将数组元素计算为一个值（从右到左）。                 |
| reverse()     | 反转数组的元素顺序。                                 |
| shift()       | 删除并返回数组的第一个元素。                         |
| slice()       | 选取数组的的一部分，并返回一个新数组。               |
| some()        | 检测数组元素中是否有元素符合指定条件。               |
| sort()        | 对数组的元素进行排序。                               |
| splice()      | 从数组中添加或删除元素。                             |
| toString()    | 把数组转换为字符串，并返回结果。                     |
| unshift()     | 向数组的开头添加一个或更多元素，并返回新的长度。     |
| valueOf()     | 返回数组对象的原始值。                               |

### 栈

- 定义
  - 后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。
  - 在栈里，新元素都靠近栈顶，旧元素都接近栈底。
  - 从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。
  - 不包含任何元素的栈称为空栈。

栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfvwdizbj30lc0i43zg.jpg)

- 实现

```js
function Stack() {
  this.data = [];

  /**
   * 添加一个（或几个）新元素到栈顶。
   */
  this.push = function (element) {
    this.data.push(element);
  };
  /**
   * 移除栈顶的元素，同时返回被移除的元素。
   */
  this.pop = function () {
    return this.data.pop();
  };
  /**
   * 返回栈顶的元素，不对栈做任何修改。
   */
  this.peek = function () {
    return this.data[this.data.length - 1];
  };
  /**
   * 如果栈里没有任何元素就返回 true，否则返回 false
   */
  this.isEmpty = function () {
    return this.data.length === 1;
  };
  /**
   * 移除栈里的所有元素
   */
  this.clear = function () {
    this.data = [];
  };
  /**
   * 返回栈里的元素个数。
   */
  this.size = function () {
    return this.data.length;
  };
  // 打印栈里的元素
  this.print = function () {
    console.log(this.data.toString());
  };
}
```

- 使用场景

举一个判断回文的例子：
```js
function isPalindrome(word) {
  var s = new Stack();
  for (var i = 0; i < word.length; i++) {
    s.push(word[i]);
  }
  var rword = "";
  while (s.length() > 0) {
    rword += s.pop();
  }

  return word == rword;
}

console.log(isPalindrome("level")); // true
console.log(isPalindrome("1001")); // true
console.log(isPalindrome("word")); // false
```

### 队列
- 定义
  - 队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。
  - 队列在尾部添加新元素，并从顶部移除元素。
  - 最新添加的元素必须排在队列的末尾。
  - 队列只有 入队 push() 和出队 pop()。
  - 队列又可以细分为普通队列、优先队列、循环队列。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhg3y5rzfj30pw0ck74z.jpg)


#### 普通队列

- 实现

```js
// Queue类
function Queue() {
  this.data = [];

  // 向队列尾部添加元素
  this.enqueue = function (element) {
    this.data.push(element);
  };

  // 移除队列的第一个元素，并返回被移除的元素
  this.dequeue = function () {
    return this.data.shift();
  };

  // 返回队列的第一个元素
  this.front = function () {
    return this.data[0];
  };

  // 判断是否为空队列
  this.isEmpty = function () {
    return this.data.length === 0;
  };

  // 获取队列的长度
  this.size = function () {
    return this.data.length;
  };

  // 清空队列
  this.clear = function () {
    this.data = [];
  };

  // 打印队列里的元素
  this.print = function () {
    console.log(this.data.toString());
  };
}
```

- 使用场景

击鼓传花游戏的实现：
```js

// 实现击鼓传花
function hotPotato(nameList, num) {
  var queue = new Queue();

  for (var i = 0; i < nameList.length; i++) {
    queue.enqueue(nameList[i]);
  }

  var eliminated = "";

  while (queue.size() > 1) {
    // 循环 num 次，队首出来去到队尾
    for (var i = 0; i < num; i++) {
      queue.enqueue(queue.dequeue());
    }
    // 循环 num 次过后，移除当前队首的元素
    eliminated = queue.dequeue();
    console.log(`${eliminated} 在击鼓传花中被淘汰！`);
  }

  // 最后只剩一个元素
  return queue.dequeue();
}

// 测试
var nameList = ["张三", "李四", "王五", "马六", "牛七"];
var winner = hotPotato(nameList, 5);
console.log(`最后的胜利者是：${winner}`);

// => 牛七 在击鼓传花中被淘汰！
// => 张三 在击鼓传花中被淘汰！
// => 王五 在击鼓传花中被淘汰！
// => 马六 在击鼓传花中被淘汰！
// => 最后的胜利者是：李四
```

#### 优先队列

- 定义
优先队列中元素的添加和移除会根据`优先级`来处理

- 场景
优先队列一个典型的场景就是机场登机，头等舱和商务舱乘客的优先级要高于经济舱乘客。
