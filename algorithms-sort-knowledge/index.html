<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.5'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>前端如何学数据结构与算法 - 一篇讲完经典排序算法 - 扬舲&#39;s blog</title>
  
    <meta name="keywords" content="数据结构与算法">
  
  
    <meta name="description" content="
文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。
">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
            <i class='https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/favicon/favicon.ico'></i>
          
          
            扬舲blog
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box reveal shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  <h1 class="title">
    <a href="/algorithms-sort-knowledge/">
      前端如何学数据结构与算法 - 一篇讲完经典排序算法
    </a>
  </h1>


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://github.com/jiangawait" target="_blank" rel="nofollow noopener">
    <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png">
    <p>扬舲</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>数据结构与算法</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2019年6月30日</p>
  </a>
</div>

            
          
            
              

            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <blockquote>
<p>文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。</p>
</blockquote>
<a id="more"></a>


<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote>
<p>算法为王。</p>
</blockquote>
<blockquote>
<p>想学好前端，先练好内功，内功不行，就算招式练的再花哨，终究成不了高手；只有内功深厚者，前端之路才会走得更远。</p>
</blockquote>
<p>笔者写的 <strong>JavaScript 数据结构与算法之美</strong> 系列用的语言是 <strong>JavaScript</strong> ，旨在入门数据结构与算法和方便以后复习。</p>
<p>文中包含了 <code>十大经典排序算法</code> 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。</p>
<p>这应该是目前最全的 <code>JavaScript 十大经典排序算法</code> 的讲解了吧。</p>
<h2 id="2-如何分析一个排序算法"><a href="#2-如何分析一个排序算法" class="headerlink" title="2. 如何分析一个排序算法"></a>2. 如何分析一个排序算法</h2><p>复杂度分析是整个算法学习的精髓。</p>
<ul>
<li>时间复杂度: 一个算法执行所耗费的时间。</li>
<li>空间复杂度: 运行完一个程序所需内存的大小。</li>
</ul>
<p>时间和空间复杂度的详解，请看 <a href="https://juejin.im/post/5cf37b6d6fb9a07eb15d3e88" target="_blank" rel="noopener">JavaScript 数据结构与算法之美 - 时间和空间复杂度</a>。</p>
<p>学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。</p>
<p>分析一个排序算法，要从 <code>执行效率</code>、<code>内存消耗</code>、<code>稳定性</code> 三方面入手。</p>
<h3 id="2-1-执行效率"><a href="#2-1-执行效率" class="headerlink" title="2.1 执行效率"></a>2.1 执行效率</h3><p><strong>1. 最好情况、最坏情况、平均情况时间复杂度</strong></p>
<p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。 除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p>
<p><strong>2. 时间复杂度的系数、常数 、低阶</strong></p>
<p>我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。</p>
<p>但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p>
<p><strong>3. 比较次数和交换（或移动）次数</strong></p>
<p>这一节和下一节讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。</p>
<p>所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p>
<h3 id="2-2-内存消耗"><a href="#2-2-内存消耗" class="headerlink" title="2.2 内存消耗"></a>2.2 内存消耗</h3><p>也就是看空间复杂度。</p>
<p>还需要知道如下术语：</p>
<ul>
<li><strong>内排序</strong>：所有排序操作都在内存中完成；</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li><strong>原地排序</strong>：原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</li>
</ul>
<h3 id="2-3-稳定性"><a href="#2-3-稳定性" class="headerlink" title="2.3 稳定性"></a>2.3 稳定性</h3><ul>
<li>稳定：如果待排序的序列中存在值<code>相等</code>的元素，经过排序之后，相等元素之间原有的先后顺序<code>不变</code>。 比如： a 原本在 b 前面，而 a = b，排序之后，a 仍然在 b 的前面；</li>
<li>不稳定：如果待排序的序列中存在值<code>相等</code>的元素，经过排序之后，相等元素之间原有的先后顺序<code>改变</code>。 比如：a 原本在 b 的前面，而 a = b，排序之后， a 在 b 的后面；</li>
</ul>
<h2 id="3-十大经典排序算法"><a href="#3-十大经典排序算法" class="headerlink" title="3. 十大经典排序算法"></a>3. 十大经典排序算法</h2><h3 id="3-1-冒泡排序（Bubble-Sort）"><a href="#3-1-冒泡排序（Bubble-Sort）" class="headerlink" title="3.1 冒泡排序（Bubble Sort）"></a>3.1 冒泡排序（Bubble Sort）</h3><p><img src="https://upload-images.jianshu.io/upload_images/12890819-d6851592702b589c.gif?imageMogr2/auto-orient/strip" alt="冒泡"></p>
<p><strong>思想</strong></p>
<ul>
<li>冒泡排序只会操作相邻的两个数据。</li>
<li>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。</li>
<li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>优点：排序算法的基础，简单实用易于理解。</li>
<li>缺点：比较次数多，效率较低。</li>
</ul>
<p><strong>实现</strong></p>
<pre><code>const bubbleSort = arr =&gt; {
    console.time(&apos;改进前冒泡排序耗时&apos;);
    const length = arr.length;
    if (length &lt;= 1) return;

    for (let i = 0; i &lt; length - 1; i++) {

        for (let j = 0; j &lt; length - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    console.log(&apos;改进前 arr :&apos;, arr);
    console.timeEnd(&apos;改进前冒泡排序耗时&apos;);
};</code></pre><p>优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。</p>
<pre><code>const bubbleSort2 = arr =&gt; {
    console.time(&apos;改进后冒泡排序耗时&apos;);
    const length = arr.length;
    if (length &lt;= 1) return;

    for (let i = 0; i &lt; length - 1; i++) {
        let hasChange = false;

        for (let j = 0; j &lt; length - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                const temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                hasChange = true;
            }
        }

        if (!hasChange) break;
    }
    console.log(&apos;改进后 arr :&apos;, arr);
    console.timeEnd(&apos;改进后冒泡排序耗时&apos;);
};</code></pre><p><strong>测试</strong></p>
<pre><code>// 测试
const arr = [7, 8, 4, 5, 6, 3, 2, 1];
bubbleSort(arr);
// 改进前 arr : [1, 2, 3, 4, 5, 6, 7, 8]
// 改进前冒泡排序耗时: 0.43798828125ms

const arr2 = [7, 8, 4, 5, 6, 3, 2, 1];
bubbleSort2(arr2);
// 改进后 arr : [1, 2, 3, 4, 5, 6, 7, 8]
// 改进后冒泡排序耗时: 0.318115234375ms</code></pre><p><strong>分析</strong></p>
<ul>
<li>第一，冒泡排序是原地排序算法吗 ？ 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个<code>原地</code>排序算法。</li>
<li>第二，冒泡排序是稳定的排序算法吗 ？ 在冒泡排序中，只有交换才可以改变两个元素的前后顺序。 为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。 所以冒泡排序是<code>稳定</code>的排序算法。</li>
<li>第三，冒泡排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-68d55469ac439bc6.gif?imageMogr2/auto-orient/strip" alt="冒泡排序动画"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-3948de96d4a28530.gif?imageMogr2/auto-orient/strip" alt="冒泡排序动画"></p>
<h3 id="3-2-插入排序（Insertion-Sort）"><a href="#3-2-插入排序（Insertion-Sort）" class="headerlink" title="3.2 插入排序（Insertion Sort）"></a>3.2 插入排序（Insertion Sort）</h3><p>插入排序又为分为 <strong>直接插入排序</strong> 和优化后的 <strong>拆半插入排序</strong> 与 <strong>希尔排序</strong>，我们通常说的插入排序是指直接插入排序。</p>
<p><strong>一、直接插入</strong></p>
<p><strong>思想</strong></p>
<p>一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。</p>
<p>插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>步骤</strong></p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2 ~ 5。</li>
</ul>
<p><strong>实现</strong></p>
<pre><code>const insertionSort = array =&gt; {
    const len = array.length;
    if (len &lt;= 1) return

    let preIndex, current;
    for (let i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = array[i];
        while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; current) {

            array[preIndex + 1] = array[preIndex];
            preIndex--;
        }
        if (preIndex + 1 != i) {

            array[preIndex + 1] = current;
            console.log(&apos;array :&apos;, array);
        }
    }
    return array;
};</code></pre><p>测试</p>
<pre><code>// 测试
const array = [5, 4, 3, 2, 1];
console.log(&quot;原始 array :&quot;, array);
insertionSort(array);
// 原始 array:    [5, 4, 3, 2, 1]
// array:           [4, 5, 3, 2, 1]
// array:           [3, 4, 5, 2, 1]
// array:          [2, 3, 4, 5, 1]
// array:           [1, 2, 3, 4, 5]</code></pre><p><strong>分析</strong></p>
<ul>
<li>第一，插入排序是原地排序算法吗 ？ 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个<code>原地</code>排序算法。</li>
<li>第二，插入排序是稳定的排序算法吗 ？ 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<code>稳定</code>的排序算法。</li>
<li>第三，插入排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-8ba117506372e97e.gif?imageMogr2/auto-orient/strip" alt="insertion-sort.gif"></p>
<p><strong>二、拆半插入</strong></p>
<p>插入排序也有一种优化算法，叫做<code>拆半插入</code>。</p>
<p><strong>思想</strong></p>
<p>折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组，我们不必按顺序依次寻找插入点，只需比较它们的中间值与待插入元素的大小即可。</p>
<p><strong>步骤</strong></p>
<ul>
<li>取 0 ~ i-1 的中间点 ( m = (i-1) &gt;&gt; 1 )，array[i] 与 array[m] 进行比较，若 array[i] &lt; array[m]，则说明待插入的元素 array[i] 应该处于数组的 0 ~ m 索引之间；反之，则说明它应该处于数组的 m ~ i-1 索引之间。</li>
<li>重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。</li>
<li>将数组中插入位置之后的元素全部后移一位。</li>
<li>在指定位置插入第 i 个元素。</li>
</ul>
<blockquote>
<p>注：x &gt;&gt; 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x &gt;&gt; 1 == Math.floor(x/2) 。</p>
</blockquote>
<pre><code>const binaryInsertionSort = array =&gt; {
    const len = array.length;
    if (len &lt;= 1) return;

    let current, i, j, low, high, m;
    for (i = 1; i &lt; len; i++) {
        low = 0;
        high = i - 1;
        current = array[i];

        while (low &lt;= high) {

            m = (low + high) &gt;&gt; 1;
            if (array[i] &gt;= array[m]) {

                low = m + 1;
            } else {
                high = m - 1;
            }
        }
        for (j = i; j &gt; low; j--) {

            array[j] = array[j - 1];
            console.log(&apos;array2 :&apos;, JSON.parse(JSON.stringify(array)));
        }
        array[low] = current;
    }
    console.log(&apos;array2 :&apos;, JSON.parse(JSON.stringify(array)));
    return array;
};</code></pre><p>测试</p>
<pre><code>const array2 = [5, 4, 3, 2, 1];
console.log(&apos;原始 array2:&apos;, array2);
binaryInsertionSort(array2);
// 原始 array2:  [5, 4, 3, 2, 1]
// array2 :     [5, 5, 3, 2, 1]
// array2 :     [4, 5, 5, 2, 1]
// array2 :     [4, 4, 5, 2, 1]
// array2 :     [3, 4, 5, 5, 1]
// array2 :     [3, 4, 4, 5, 1]
// array2 :     [3, 3, 4, 5, 1]
// array2 :     [2, 3, 4, 5, 5]
// array2 :     [2, 3, 4, 4, 5]
// array2 :     [2, 3, 3, 4, 5]
// array2 :     [2, 2, 3, 4, 5]
// array2 :     [1, 2, 3, 4, 5]</code></pre><p><code>注意</code>：和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。</p>
<p><strong>三、希尔排序</strong></p>
<p>希尔排序是一个平均时间复杂度为 O(n log n) 的算法，会在下一个章节和 归并排序、快速排序、堆排序 一起讲，本文就不展开了。</p>
<h3 id="3-3-选择排序（Selection-Sort）"><a href="#3-3-选择排序（Selection-Sort）" class="headerlink" title="3.3 选择排序（Selection Sort）"></a>3.3 选择排序（Selection Sort）</h3><p><strong>思路</strong></p>
<p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p><strong>步骤</strong></p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<p><strong>实现</strong></p>
<pre><code>const selectionSort = array =&gt; {
    const len = array.length;
    let minIndex, temp;
    for (let i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (let j = i + 1; j &lt; len; j++) {
            if (array[j] &lt; array[minIndex]) {

                minIndex = j;
            }
        }
        temp = array[i];
        array[i] = array[minIndex];
        array[minIndex] = temp;
        console.log(&apos;array: &apos;, array);
    }
    return array;
};</code></pre><p>测试</p>
<pre><code>// 测试
const array = [5, 4, 3, 2, 1];
console.log(&apos;原始array:&apos;, array);
selectionSort(array);
// 原始 array:  [5, 4, 3, 2, 1]
// array:           [1, 4, 3, 2, 5]
// array:           [1, 2, 3, 4, 5]
// array:          [1, 2, 3, 4, 5]
// array:           [1, 2, 3, 4, 5]</code></pre><p><strong>分析</strong></p>
<ul>
<li>第一，选择排序是原地排序算法吗 ？ 选择排序空间复杂度为 O(1)，是一种<code>原地</code>排序算法。</li>
<li>第二，选择排序是稳定的排序算法吗 ？ 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种<code>不稳定</code>的排序算法。</li>
<li>第三，选择排序的时间复杂度是多少 ？ 无论是正序还是逆序，选择排序都会遍历 n2 / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。 最佳情况：T(n) = O(n2)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n2)。</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-27ddfb636eabff03.gif?imageMogr2/auto-orient/strip" alt="selection-sort.gif"></p>
<h3 id="3-4-归并排序（Merge-Sort）"><a href="#3-4-归并排序（Merge-Sort）" class="headerlink" title="3.4 归并排序（Merge Sort）"></a>3.4 归并排序（Merge Sort）</h3><p><strong>思想</strong></p>
<p>排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>归并排序采用的是<code>分治思想</code>。</p>
<p>分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-a186be41b62d6f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="merge-sort-example.png"></p>
<blockquote>
<p>注：x &gt;&gt; 1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x &gt;&gt; 1 === Math.floor(x / 2) 。</p>
</blockquote>
<p><strong>实现</strong></p>
<pre><code>const mergeSort = arr =&gt; {

    const len = arr.length;
    if (len &lt; 2) {
        return arr;
    }

    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
};

const merge = (left, right) =&gt; {
    const result = [];

    while (left.length &amp;&amp; right.length) {

        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length) result.push(left.shift());

    while (right.length) result.push(right.shift());

    return result;
};</code></pre><p><strong>测试</strong></p>
<pre><code>// 测试
const arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.time(&apos;归并排序耗时&apos;);
console.log(&apos;arr :&apos;, mergeSort(arr));
console.timeEnd(&apos;归并排序耗时&apos;);
// arr : [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
// 归并排序耗时: 0.739990234375ms</code></pre><p><strong>分析</strong></p>
<ul>
<li><p>第一，归并排序是原地排序算法吗 ？ 这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。 实际上，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。 所以，归并排序<code>不是</code>原地排序算法。</p>
</li>
<li><p>第二，归并排序是稳定的排序算法吗 ？ merge 方法里面的 left[0] &lt;= right[0] ，保证了值相同的元素，在合并前后的先后顺序不变。归并排序<code>是稳定</code>的排序方法。</p>
</li>
<li><p>第三，归并排序的时间复杂度是多少 ？ 从效率上看，归并排序可算是排序算法中的<code>佼佼者</code>。假设数组长度为 n，那么拆分数组共需 logn 步，又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)，故其综合时间复杂度为 O(n log n)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log n)。 平均情况：T(n) = O(n log n)。</p>
</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-32372625906df3ae.gif?imageMogr2/auto-orient/strip" alt="merge-sort.gif"></p>
<h3 id="3-5-快速排序-（Quick-Sort）"><a href="#3-5-快速排序-（Quick-Sort）" class="headerlink" title="3.5 快速排序 （Quick Sort）"></a>3.5 快速排序 （Quick Sort）</h3><p>快速排序的特点就是快，而且效率高！它是处理大数据最快的排序算法之一。</p>
<p><strong>思想</strong></p>
<ul>
<li>先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。</li>
<li>左右分别用一个空数组去存储比较后的数据。</li>
<li>最后递归执行上述操作，直到数组长度 &lt;= 1;</li>
</ul>
<p>特点：快速，常用。</p>
<p>缺点：需要另外声明两个数组，浪费了内存空间资源。</p>
<p><strong>实现</strong></p>
<p>方法一：</p>
<pre><code>const quickSort1 = arr =&gt; {
    if (arr.length &lt;= 1) {
        return arr;
    }

    const midIndex = Math.floor(arr.length / 2);

    const valArr = arr.splice(midIndex, 1);
    const midIndexVal = valArr[0];
    const left = [];
    const right = [];

    for (let i = 0; i &lt; arr.length; i++) {
        if (arr[i] &lt; midIndexVal) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }

    return quickSort1(left).concat(midIndexVal, quickSort1(right));
};
const array2 = [5, 4, 3, 2, 1];
console.log(&apos;quickSort1 &apos;, quickSort1(array2));</code></pre><p>方法二：</p>
<pre><code>const quickSort = (arr, left, right) =&gt; {
    let len = arr.length,
        partitionIndex;
    left = typeof left != &apos;number&apos; ? 0 : left;
    right = typeof right != &apos;number&apos; ? len - 1 : right;

    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
    }
    return arr;
};

const partition = (arr, left, right) =&gt; {

    let pivot = left,
        index = pivot + 1;
    for (let i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }
    }
    swap(arr, pivot, index - 1);
    return index - 1;
};

const swap = (arr, i, j) =&gt; {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
};</code></pre><p>测试</p>
<pre><code>// 测试
const array = [5, 4, 3, 2, 1];
console.log(&apos;原始array:&apos;, array);
const newArr = quickSort(array);
console.log(&apos;newArr:&apos;, newArr);
// 原始 array:  [5, 4, 3, 2, 1]
// newArr:     [1, 4, 3, 2, 5]</code></pre><p><strong>分析</strong></p>
<ul>
<li><p>第一，快速排序是原地排序算法吗 ？ 因为 partition() 函数进行分区时，不需要很多额外的内存空间，所以快排是<code>原地排序</code>算法。</p>
</li>
<li><p>第二，快速排序是稳定的排序算法吗 ？ 和选择排序相似，快速排序每次交换的元素都有可能不是相邻的，因此它有可能打破原来值为相同的元素之间的顺序。因此，快速排序并<code>不稳定</code>。</p>
</li>
<li><p>第三，快速排序的时间复杂度是多少 ？ 极端的例子：如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n / 2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n log n)。</p>
</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-708f5b687f6bde65.gif?imageMogr2/auto-orient/strip" alt="quick-sort.gif"></p>
<p><strong>解答开篇问题</strong></p>
<p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢 ？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-3e29b9d2d936905d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速排序与归并排序"></p>
<p>可以发现：</p>
<ul>
<li>归并排序的处理过程是<code>由下而上</code>的，先处理子问题，然后再合并。</li>
<li>而快排正好相反，它的处理过程是<code>由上而下</code>的，先分区，然后再处理子问题。</li>
<li>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。</li>
<li>归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。</li>
<li>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</li>
</ul>
<h3 id="3-6-希尔排序（Shell-Sort）"><a href="#3-6-希尔排序（Shell-Sort）" class="headerlink" title="3.6 希尔排序（Shell Sort）"></a>3.6 希尔排序（Shell Sort）</h3><p><strong>思想</strong></p>
<ul>
<li>先将整个待排序的记录序列分割成为若干子序列。</li>
<li>分别进行直接插入排序。</li>
<li>待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序。</li>
</ul>
<p><strong>过程</strong></p>
<ol>
<li>举个易于理解的例子：[35, 33, 42, 10, 14, 19, 27, 44]，我们采取间隔 4。创建一个位于 4 个位置间隔的所有值的虚拟子列表。下面这些值是 { 35, 14 }，{ 33, 19 }，{ 42, 27 } 和 { 10, 44 }。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-e58310e3c89561da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栗子"></p>
<ol start="2">
<li>我们比较每个子列表中的值，并在原始数组中交换它们（如果需要）。完成此步骤后，新数组应如下所示。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-4d6b2b51ca3f04bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栗子"></p>
<ol start="3">
<li>然后，我们采用 2 的间隔，这个间隙产生两个子列表：{ 14, 27, 35, 42 }， { 19, 10, 33, 44 }。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-38dcc34caa3a9d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栗子"></p>
<ol start="4">
<li>我们比较并交换原始数组中的值（如果需要）。完成此步骤后，数组变成：[14, 10, 27, 19, 35, 33, 42, 44]，图如下所示，10 与 19 的位置互换一下。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-4fdc3019a8c4ec11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ol start="5">
<li>最后，我们使用值间隔 1 对数组的其余部分进行排序，Shell sort 使用插入排序对数组进行排序。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-25f5e05762daaa49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栗子"></p>
<p><strong>实现</strong></p>
<pre><code>const shellSort = arr =&gt; {
    let len = arr.length,
        temp,
        gap = 1;
    console.time(&apos;希尔排序耗时&apos;);
    while (gap &lt; len / 3) {

        gap = gap * 3 + 1;
    }
    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) {
        for (let i = gap; i &lt; len; i++) {
            temp = arr[i];
            let j = i - gap;
            for (; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
            console.log(&apos;arr  :&apos;, arr);
        }
    }
    console.timeEnd(&apos;希尔排序耗时&apos;);
    return arr;
};</code></pre><p>测试</p>
<pre><code>// 测试
const array = [35, 33, 42, 10, 14, 19, 27, 44];
console.log(&apos;原始array:&apos;, array);
const newArr = shellSort(array);
console.log(&apos;newArr:&apos;, newArr);
// 原始 array:   [35, 33, 42, 10, 14, 19, 27, 44]
// arr      :   [14, 33, 42, 10, 35, 19, 27, 44]
// arr      :   [14, 19, 42, 10, 35, 33, 27, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [14, 19, 27, 10, 35, 33, 42, 44]
// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]
// arr      :   [10, 14, 19, 27, 35, 33, 42, 44]
// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]
// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]
// arr      :   [10, 14, 19, 27, 33, 35, 42, 44]
// 希尔排序耗时: 3.592041015625ms
// newArr:     [10, 14, 19, 27, 33, 35, 42, 44]</code></pre><p><strong>分析</strong></p>
<ul>
<li><p>第一，希尔排序是原地排序算法吗 ？ 希尔排序过程中，只涉及相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1) 。所以，希尔排序是<code>原地排序</code>算法。</p>
</li>
<li><p>第二，希尔排序是稳定的排序算法吗 ？ 我们知道，单次直接插入排序是稳定的，它不会改变相同元素之间的相对顺序，但在多次不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，可能导致相同元素相对顺序发生变化。 因此，希尔排序<code>不稳定</code>。</p>
</li>
<li><p>第三，希尔排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log2 n)。 平均情况：T(n) = O(n log2 n)。</p>
</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-cdac5dafc537a06a.gif?imageMogr2/auto-orient/strip" alt="shell-sort.gif"></p>
<h3 id="3-7-堆排序（Heap-Sort）"><a href="#3-7-堆排序（Heap-Sort）" class="headerlink" title="3.7 堆排序（Heap Sort）"></a>3.7 堆排序（Heap Sort）</h3><p><strong>堆的定义</strong></p>
<p>堆其实是一种特殊的树。只要满足这两点，它就是一个堆。</p>
<ul>
<li>堆是一个完全二叉树。 完全二叉树：除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。 也可以说：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</li>
</ul>
<p>对于每个节点的值都<code>大于等于</code>子树中每个节点值的堆，我们叫作<code>大顶堆</code>。 对于每个节点的值都<code>小于等于</code>子树中每个节点值的堆，我们叫作<code>小顶堆</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-ba0004cfc2c4c8d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="区分堆、大顶堆、小顶堆"></p>
<p>其中图 1 和 图 2 是大顶堆，图 3 是小顶堆，图 4 不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p>
<p><strong>思想</strong></p>
<ol>
<li>将初始待排序关键字序列 (R1, R2 …. Rn) 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ….. Rn-1) 和新的有序区 (Rn) ，且满足 R[1, 2 … n-1] &lt;= R[n]。</li>
<li>由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2 …… Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2 …. Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程，直到有序区的元素个数为 n - 1，则整个排序过程完成。</li>
</ol>
<p><strong>实现</strong></p>
<pre><code>const heapSort = array =&gt; {
    console.time(&apos;堆排序耗时&apos;);

    for (let i = Math.floor(array.length / 2 - 1); i &gt;= 0; i--) {
        heapify(array, i, array.length);
    }

    for (let i = Math.floor(array.length - 1); i &gt; 0; i--) {

        swap(array, 0, i);

        heapify(array, 0, i);
    }
    console.timeEnd(&apos;堆排序耗时&apos;);
    return array;
};


const swap = (array, i, j) =&gt; {
    let temp = array[i];
    array[i] = array[j];
    array[j] = temp;
};






const heapify = (array, i, length) =&gt; {
    let temp = array[i];

    for (let j = 2 * i + 1; j &lt; length; j = 2 * j + 1) {
        temp = array[i];
        if (j + 1 &lt; length &amp;&amp; array[j] &lt; array[j + 1]) {
            j++;
        }
        if (temp &lt; array[j]) {
            swap(array, i, j);
            i = j;
        } else {
            break;
        }
    }
};</code></pre><p>测试</p>
<pre><code>const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];
console.log(&apos;原始array:&apos;, array);
const newArr = heapSort(array);
console.log(&apos;newArr:&apos;, newArr);
// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]
// 堆排序耗时: 0.15087890625ms
// newArr:     [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]</code></pre><p><strong>分析</strong></p>
<ul>
<li><p>第一，堆排序是原地排序算法吗 ？ 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序<code>是</code>原地排序算法。</p>
</li>
<li><p>第二，堆排序是稳定的排序算法吗 ？ 因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。 所以，堆排序是<code>不稳定</code>的排序算法。</p>
</li>
<li><p>第三，堆排序的时间复杂度是多少 ？ 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。 最佳情况：T(n) = O(n log n)。 最差情况：T(n) = O(n log n)。 平均情况：T(n) = O(n log n)。</p>
</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-62cc8c35ce449e02.gif?imageMogr2/auto-orient/strip" alt="heap-sort.gif"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-7946ab6ef624c184.gif?imageMogr2/auto-orient/strip" alt="heap-sort2.gif"></p>
<h3 id="3-8-桶排序（Bucket-Sort）"><a href="#3-8-桶排序（Bucket-Sort）" class="headerlink" title="3.8 桶排序（Bucket Sort）"></a>3.8 桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版，也采用了<code>分治思想</code>。</p>
<p><strong>思想</strong></p>
<ul>
<li>将要排序的数据分到有限数量的几个有序的桶里。</li>
<li>每个桶里的数据再单独进行排序（一般用插入排序或者快速排序）。</li>
<li>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</li>
</ul>
<p>比如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-fbe2b3e3d6d56b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量。</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中。</li>
</ul>
<p>桶排序的核心：就在于怎么把元素平均分配到每个桶里，合理的分配将大大提高排序的效率。</p>
<p><strong>实现</strong></p>
<pre><code>const bucketSort = (array, bucketSize) =&gt; {
  if (array.length === 0) {
    return array;
  }

  console.time(&apos;桶排序耗时&apos;);
  let i = 0;
  let minValue = array[0];
  let maxValue = array[0];
  for (i = 1; i &lt; array.length; i++) {
    if (array[i] &lt; minValue) {
      minValue = array[i];
    } else if (array[i] &gt; maxValue) {
      maxValue = array[i];
    }
  }


  const DEFAULT_BUCKET_SIZE = 5;
  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
  const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;
  const buckets = new Array(bucketCount);
  for (i = 0; i &lt; buckets.length; i++) {
    buckets[i] = [];
  }


  for (i = 0; i &lt; array.length; i++) {
    buckets[Math.floor((array[i] - minValue) / bucketSize)].push(array[i]);
  }

  array.length = 0;
  for (i = 0; i &lt; buckets.length; i++) {
    quickSort(buckets[i]);
    for (var j = 0; j &lt; buckets[i].length; j++) {
      array.push(buckets[i][j]);
    }
  }
  console.timeEnd(&apos;桶排序耗时&apos;);

  return array;
};


const quickSort = (arr, left, right) =&gt; {
    let len = arr.length,
        partitionIndex;
    left = typeof left != &apos;number&apos; ? 0 : left;
    right = typeof right != &apos;number&apos; ? len - 1 : right;

    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
    }
    return arr;
};

const partition = (arr, left, right) =&gt; {

    let pivot = left,
        index = pivot + 1;
    for (let i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }
    }
    swap(arr, pivot, index - 1);
    return index - 1;
};

const swap = (arr, i, j) =&gt; {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
};</code></pre><p><strong>测试</strong></p>
<pre><code>const array = [4, 6, 8, 5, 9, 1, 2, 5, 3, 2];
console.log(&apos;原始array:&apos;, array);
const newArr = bucketSort(array);
console.log(&apos;newArr:&apos;, newArr);
// 原始 array:  [4, 6, 8, 5, 9, 1, 2, 5, 3, 2]
// 堆排序耗时:   0.133056640625ms
// newArr:       [1, 2, 2, 3, 4, 5, 5, 6, 8, 9]</code></pre><p><strong>分析</strong></p>
<ul>
<li><p>第一，桶排序是原地排序算法吗 ？ 因为桶排序的空间复杂度，也即内存消耗为 O(n)，所以<code>不是</code>原地排序算法。</p>
</li>
<li><p>第二，桶排序是稳定的排序算法吗 ？ 取决于每个桶的排序方式，比如：快排就不稳定，归并就稳定。</p>
</li>
<li><p>第三，桶排序的时间复杂度是多少 ？ 因为桶内部的排序可以有多种方法，是会对桶排序的时间复杂度产生很重大的影响。所以，桶排序的时间复杂度可以是多种情况的。 <code>总的来说</code> 最佳情况：当输入的数据可以均匀的分配到每一个桶中。 最差情况：当输入的数据被分配到了同一个桶中。 以下是<code>桶的内部排序</code>为<code>快速排序</code>的情况： 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k =n / m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。 m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k = n / m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。 当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。 最佳情况：T(n) = O(n)。当输入的数据可以均匀的分配到每一个桶中。 最差情况：T(n) = O(nlogn)。当输入的数据被分配到了同一个桶中。 平均情况：T(n) = O(n)。</p>
</li>
</ul>
<blockquote>
<p>桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。 很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
</blockquote>
<p><strong>适用场景</strong></p>
<ul>
<li>桶排序比较适合用在外部排序中。</li>
<li>外部排序就是数据存储在外部磁盘且数据量大，但内存有限，无法将整个数据全部加载到内存中。</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-96021a791180eba0.gif?imageMogr2/auto-orient/strip" alt="bocket-sort.gif"></p>
<h3 id="3-9-计数排序（Counting-Sort）"><a href="#3-9-计数排序（Counting-Sort）" class="headerlink" title="3.9 计数排序（Counting Sort）"></a>3.9 计数排序（Counting Sort）</h3><p><strong>思想</strong></p>
<ul>
<li>找出待排序的数组中最大和最小的元素。</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入新数组 countArr 的第 i 项。</li>
<li>对所有的计数累加（从 countArr 中的第一个元素开始，每一项和前一项相加）。</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 countArr[i] 项，每放一个元素就将 countArr[i] 减去 1 。</li>
</ul>
<p>关键在于理解最后反向填充时的操作。</p>
<p><strong>使用条件</strong></p>
<ul>
<li>只能用在数据范围不大的场景中，若数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序。</li>
<li>计数排序只能给非负整数排序，其他类型需要在不改变相对大小情况下，转换为非负整数。</li>
<li>比如如果考试成绩精确到小数后一位，就需要将所有分数乘以 10，转换为整数。</li>
</ul>
<p><strong>实现</strong></p>
<p>方法一：</p>
<pre><code>const countingSort = array =&gt; {
    let len = array.length,
        result = [],
        countArr = [],
        min = (max = array[0]);
    console.time(&apos;计数排序耗时&apos;);
    for (let i = 0; i &lt; len; i++) {
        // 获取最小，最大 值
        min = min &lt;= array[i] ? min : array[i];
        max = max &gt;= array[i] ? max : array[i];
        countArr[array[i]] = countArr[array[i]] ? countArr[array[i]] + 1 : 1;
    }
    console.log(&apos;countArr :&apos;, countArr);
    // 从最小值 -&gt; 最大值,将计数逐项相加
    for (let j = min; j &lt; max; j++) {
        countArr[j + 1] = (countArr[j + 1] || 0) + (countArr[j] || 0);
    }
    console.log(&apos;countArr 2:&apos;, countArr);
    // countArr 中,下标为 array 数值，数据为 array 数值出现次数；反向填充数据进入 result 数据
    for (let k = len - 1; k &gt;= 0; k--) {
        // result[位置] = array 数据
        result[countArr[array[k]] - 1] = array[k];
        // 减少 countArr 数组中保存的计数
        countArr[array[k]]--;
        // console.log(&quot;array[k]:&quot;, array[k], &apos;countArr[array[k]] :&apos;, countArr[array[k]],)
        console.log(&apos;result:&apos;, result);
    }
    console.timeEnd(&apos;计数排序耗时&apos;);
    return result;
};</code></pre><p>测试</p>
<pre><code>const array = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];
console.log(&apos;原始 array: &apos;, array);
const newArr = countingSort(array);
console.log(&apos;newArr: &apos;, newArr);</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12890819-f2541143bcd69138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试结果"></p>
<p>方法二：</p>
<pre><code>const countingSort2 = (arr, maxValue) =&gt; {
    console.time(&apos;计数排序耗时&apos;);
    maxValue = maxValue || arr.length;
    let bucket = new Array(maxValue + 1),
        sortedIndex = 0;
    (arrLen = arr.length), (bucketLen = maxValue + 1);

    for (let i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }

    for (let j = 0; j &lt; bucketLen; j++) {
        while (bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
    console.timeEnd(&apos;计数排序耗时&apos;);
    return arr;
};</code></pre><p>测试</p>
<pre><code>const array2 = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];
console.log(&apos;原始 array2: &apos;, array2);
const newArr2 = countingSort2(array2, 21);
console.log(&apos;newArr2: &apos;, newArr2);</code></pre><p><strong>例子</strong></p>
<p>可以认为，<strong>计数排序其实是桶排序的一种特殊情况</strong>。</p>
<p>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p>
<ul>
<li>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。</li>
<li>根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。</li>
<li>我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。</li>
<li>因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>第一，计数排序是原地排序算法吗 ？ 因为计数排序的空间复杂度为 O(k)，k 桶的个数，所以不是原地排序算法。</li>
<li>第二，计数排序是稳定的排序算法吗 ？ 计数排序不改变相同元素之间原本相对的顺序，因此它是稳定的排序算法。</li>
<li>第三，计数排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n + k) 最差情况：T(n) = O(n + k) 平均情况：T(n) = O(n + k) k 是待排序列最大值。</li>
</ul>
<p><strong>动画</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-43b26f260d905c77.gif?imageMogr2/auto-orient/strip" alt="counting-sort.gif"></p>
<h3 id="3-10-基数排序（Radix-Sort）"><a href="#3-10-基数排序（Radix-Sort）" class="headerlink" title="3.10 基数排序（Radix Sort）"></a>3.10 基数排序（Radix Sort）</h3><p><strong>思想</strong></p>
<p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。</p>
<p><strong>例子</strong></p>
<p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢 ？</p>
<p>这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。所以是基于<code>位</code>来比较的。</p>
<p>桶排序、计数排序能派上用场吗 ？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢 ？ 有，就是基数排序。</p>
<p><strong>使用条件</strong></p>
<ul>
<li>要求数据可以分割独立的<code>位</code>来比较；</li>
<li>位之间由递进关系，如果 a 数据的高位比 b 数据大，那么剩下的地位就不用比较了；</li>
<li>每一位的数据范围不能太大，要可以用线性排序，否则基数排序的时间复杂度无法做到 O(n)。</li>
</ul>
<p><strong>方案</strong></p>
<p>按照优先从高位或低位来排序有两种实现方案:</p>
<ul>
<li>MSD：由高位为基底，先按 k1 排序分组，同一组中记录, 关键码 k1 相等，再对各组按 k2 排序分成子组, 之后，对后面的关键码继续这样的排序分组，直到按最次位关键码 kd 对各子组排序后，再将各组连接起来，便得到一个有序序列。MSD 方式适用于位数多的序列。</li>
<li>LSD：由低位为基底，先从 kd 开始排序，再对 kd - 1 进行排序，依次重复，直到对 k1 排序后便得到一个有序序列。LSD 方式适用于位数少的序列。</li>
</ul>
<p><strong>实现</strong></p>
<pre><code>const radixSort = (array, max) =&gt; {
    console.time(&apos;计数排序耗时&apos;);
    const buckets = [];
    let unit = 10,
        base = 1;
    for (let i = 0; i &lt; max; i++, base *= 10, unit *= 10) {
        for (let j = 0; j &lt; array.length; j++) {
            let index = ~~((array[j] % unit) / base);
            if (buckets[index] == null) {
                buckets[index] = [];
            }
            buckets[index].push(array[j]);
        }
        let pos = 0,
            value;
        for (let j = 0, length = buckets.length; j &lt; length; j++) {
            if (buckets[j] != null) {
                while ((value = buckets[j].shift()) != null) {
                    array[pos++] = value;
                }
            }
        }
    }
    console.timeEnd(&apos;计数排序耗时&apos;);
    return array;
};</code></pre><p>测试</p>
<pre><code>const array = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(&apos;原始array:&apos;, array);
const newArr = radixSort(array, 2);
console.log(&apos;newArr:&apos;, newArr);
// 原始 array:  [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
// 堆排序耗时:   0.064208984375ms
// newArr:       [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</code></pre><p><strong>分析</strong></p>
<ul>
<li><p>第一，基数排序是原地排序算法吗 ？ 因为计数排序的空间复杂度为 O(n + k)，所以不是原地排序算法。</p>
</li>
<li><p>第二，基数排序是稳定的排序算法吗 ？ 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p>
</li>
<li><p>第三，基数排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k) 其中，k 是待排序列最大值。</p>
</li>
</ul>
<p><strong>动画</strong></p>
<p>LSD 基数排序动图演示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12890819-aff01ef4a1e19f74.gif?imageMogr2/auto-orient/strip" alt="radixSort.gif"></p>
<h2 id="4-复杂度对比"><a href="#4-复杂度对比" class="headerlink" title="4. 复杂度对比"></a>4. 复杂度对比</h2><p>十大经典排序算法的 <strong>时间复杂度与空间复杂度</strong> 比较。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>平均</th>
<th>最好</th>
<th>最坏</th>
<th>空间</th>
<th>稳定性</th>
<th>排序方式</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>Yes</td>
<td>In-place</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n2)</td>
<td>O(n)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>Yes</td>
<td>In-place</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>No</td>
<td>In-place</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>Yes</td>
<td>Out-place</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n2)</td>
<td>O(logn)</td>
<td>No</td>
<td>In-place</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n log n)</td>
<td>O(n log2 n)</td>
<td>O(n log2 n)</td>
<td>O(1)</td>
<td>No</td>
<td>In-place</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>No</td>
<td>In-place</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n2)</td>
<td>O(n + k)</td>
<td>Yes</td>
<td>Out-place</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(k)</td>
<td>Yes</td>
<td>Out-place</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n + k)</td>
<td>Yes</td>
<td>Out-place</td>
</tr>
</tbody></table>
<p>名词解释：</p>
<ul>
<li>n：数据规模；</li>
<li>k：桶的个数；</li>
<li>In-place: 占用常数内存，不占用额外内存；</li>
<li>Out-place: 占用额外内存。</li>
</ul>
<h2 id="5-算法可视化工具"><a href="#5-算法可视化工具" class="headerlink" title="5. 算法可视化工具"></a>5. 算法可视化工具</h2><ul>
<li><p>算法可视化工具 <a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener">algorithm-visualizer</a> 算法可视化工具 algorithm-visualizer 是一个交互式的在线平台，可以从代码中可视化算法，还可以看到代码执行的过程。旨在通过交互式可视化的执行来揭示算法背后的机制。 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-0af779615ee7fc27.gif?imageMogr2/auto-orient/strip" alt="算法可视化工具"></p>
</li>
<li><p>算法可视化动画网站 <a href="https://visualgo.net/en" target="_blank" rel="noopener">https://visualgo.net/en</a> 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-661bf75741df7c9a.gif?imageMogr2/auto-orient/strip" alt="quick-sort.gif"></p>
</li>
<li><p>算法可视化动画网站 <a href="https://www.ee.ryerson.ca/~courses/coe428/sorting/insertionsort.html" target="_blank" rel="noopener">www.ee.ryerson.ca</a> 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-2453edc1c19e14b8.gif?imageMogr2/auto-orient/strip" alt="insert-sort.gif"></p>
</li>
</ul>
<ul>
<li><a href="https://github.com/skidding/illustrated-algorithms" target="_blank" rel="noopener">illustrated-algorithms</a> 变量和操作的可视化表示增强了控制流和实际源代码。您可以快速前进和后退执行，以密切观察算法的工作方式。 效果如下图： <img src="https://upload-images.jianshu.io/upload_images/12890819-22bd05d89a89af8c.gif?imageMogr2/auto-orient/strip" alt="binary-search.gif"></li>
</ul>
<h2 id="6-系列文章"><a href="#6-系列文章" class="headerlink" title="6. 系列文章"></a>6. 系列文章</h2><p><strong>JavaScript 数据结构与算法之美</strong> 系列文章，暂时写了如下的 11 篇文章，后续还有想写的内容，再补充。</p>
<p>所写的内容只是数据结构与算法内容的冰山一角，如果你还想学更多的内容，推荐学习王争老师的 <a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener">数据结构与算法之美</a>。</p>
<p>从时间和空间复杂度、基础数据结构到排序算法，文章的内容有一定的关联性，所以阅读时推荐按顺序来阅读，效果更佳。</p>
<ul>
<li><a href="https://github.com/biaochenxuying/blog/issues/29" target="_blank" rel="noopener">1. JavaScript 数据结构与算法之美 - 时间和空间复杂度</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/34" target="_blank" rel="noopener">2. JavaScript 数据结构与算法之美 - 线性表（数组、队列、栈、链表）</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/30" target="_blank" rel="noopener">3. JavaScript 数据结构与算法之美 - 实现一个前端路由，如何实现浏览器的前进与后退 ？</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/35" target="_blank" rel="noopener">4. JavaScript 数据结构与算法之美 - 栈内存与堆内存 、浅拷贝与深拷贝</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/36" target="_blank" rel="noopener">5. JavaScript 数据结构与算法之美 - 递归</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/37" target="_blank" rel="noopener">6. JavaScript 数据结构与算法之美 - 非线性表（树、堆）</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/39" target="_blank" rel="noopener">7. JavaScript 数据结构与算法之美 - 冒泡排序、选择排序、插入排序</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/40" target="_blank" rel="noopener">8. JavaScript 数据结构与算法之美 - 归并排序、快速排序、希尔排序、堆排序</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/41" target="_blank" rel="noopener">9. JavaScript 数据结构与算法之美 - 计数排序、桶排序、基数排序</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/42" target="_blank" rel="noopener">10. JavaScript 数据结构与算法之美 - 十大经典排序算法汇总</a></li>
<li><a href="https://github.com/biaochenxuying/blog/issues/43" target="_blank" rel="noopener">11. JavaScript 数据结构与算法之美 - 强烈推荐 GitHub 上值得前端学习的数据结构与算法项目</a></li>
</ul>
<blockquote>
<p>如果有错误或者不严谨的地方，请务必给予指正，以免误人子弟，十分感谢。</p>
</blockquote>
<p><a href="https://biaochenxuying.cn/articleDetail?article_id=5d4059b896cf541789792485" target="_blank" rel="noopener">Source</a></p>

          
            <div class='article_footer'>
              
                
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=http://blog.kobingo.xyz/algorithms-sort-knowledge/>http://blog.kobingo.xyz/algorithms-sort-knowledge/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


              
            </div>
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-01-19T06:41:41+00:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2021年1月19日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>数据结构与算法</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.kobingo.xyz/algorithms-sort-knowledge/&title=前端如何学数据结构与算法 - 一篇讲完经典排序算法 - 扬舲's blog&summary=
文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.kobingo.xyz/algorithms-sort-knowledge/&title=前端如何学数据结构与算法 - 一篇讲完经典排序算法 - 扬舲's blog&summary=
文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://blog.kobingo.xyz/algorithms-sort-knowledge/&title=前端如何学数据结构与算法 - 一篇讲完经典排序算法 - 扬舲's blog&summary=
文中包含了 十大经典排序算法 的思想、代码实现、一些例子、复杂度分析、动画、还有算法可视化工具。
"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/javascript-iframe-download-complete/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>通过iframe下载文件如何判断下载完成</p>
                <p class='content'>问题当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文...</p>
              </a>
            
            
              <a class='next' href='/others-nginx-basic/'>
                <p class='title'>nginx初试<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>
“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。”

作为前端开发，即使没用过 Ngin...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box reveal comments shadow">
    <section class="article typo">
      <p ct><i class='fas fa-comments'></i> 评论</p>
      
      
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
          </div>
        </section>
      
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '前端如何学数据结构与算法 - 一篇讲完经典排序算法',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-前言"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-如何分析一个排序算法"><span class="toc-text">2. 如何分析一个排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-执行效率"><span class="toc-text">2.1 执行效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-内存消耗"><span class="toc-text">2.2 内存消耗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-稳定性"><span class="toc-text">2.3 稳定性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-十大经典排序算法"><span class="toc-text">3. 十大经典排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-冒泡排序（Bubble-Sort）"><span class="toc-text">3.1 冒泡排序（Bubble Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-插入排序（Insertion-Sort）"><span class="toc-text">3.2 插入排序（Insertion Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-选择排序（Selection-Sort）"><span class="toc-text">3.3 选择排序（Selection Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-归并排序（Merge-Sort）"><span class="toc-text">3.4 归并排序（Merge Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-快速排序-（Quick-Sort）"><span class="toc-text">3.5 快速排序 （Quick Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-希尔排序（Shell-Sort）"><span class="toc-text">3.6 希尔排序（Shell Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-堆排序（Heap-Sort）"><span class="toc-text">3.7 堆排序（Heap Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-桶排序（Bucket-Sort）"><span class="toc-text">3.8 桶排序（Bucket Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-计数排序（Counting-Sort）"><span class="toc-text">3.9 计数排序（Counting Sort）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-基数排序（Radix-Sort）"><span class="toc-text">3.10 基数排序（Radix Sort）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-复杂度对比"><span class="toc-text">4. 复杂度对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-算法可视化工具"><span class="toc-text">5. 算法可视化工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-系列文章"><span class="toc-text">6. 系列文章</span></a></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="mailto:jiangawait@163.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/jiangawait"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
      
        本站使用
        <a href="https://volantis.js.org/" target="_blank" class="codename">Volantis</a>
        作为主题，总访问量为
          <span id="busuanzi_value_site_pv"><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
          次
        
      
    
      
        <div class='copyright'>
        <p><a href="http://beian.miit.gov.cn/" target="_blank" rel="noopener">Copyright© All Rights Reserved. kobin 浙ICP备20008569号</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      ScrollReveal().reveal('.l_main .reveal', {
        distance: '8px',
        duration: '800',
        interval: '100',
        scale: '1'
      });
    });
  </script>


  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  









  
    
<script src="https://unpkg.com/valine@latest/dist/Valine.min.js"></script>

  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var meta = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var REQUIRED_FIELDS = ['nick','mail','link'];
  var requiredFields = 'nick,mail'.split(',').filter(function(item){
    return REQUIRED_FIELDS.indexOf(item) > -1
  });
  var valine = new Valine();
  function emoji(path, idx, ext) {
      return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  valine.init({
    el: '#valine_container',
    meta: meta,
    
    appId: "5sFYD7w0OI6I1UaD3iifvim1-gzGzoHsz",
    appKey: "bnpoUc3tr7wSd41wVcrc6Uzr",
    placeholder: "快来发表你的评论吧~",
    pageSize:'10',
    avatar:'robohash',
    lang:'zh-cn',
    visitor: 'true',
    highlight: 'true',
    mathJax: 'false',
    enableQQ: 'true',
    requiredFields: requiredFields,
    emojiCDN: 'https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/',
    emojiMaps: emojiMaps
  })
  </script>





  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>
