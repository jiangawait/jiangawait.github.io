<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/04/hello-world/"/>
      <url>/2020/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文章摘录</title>
      <link href="/2019/05/06/collection/"/>
      <url>/2019/05/06/collection/</url>
      
        <content type="html"><![CDATA[<p>在这里记录一些看到的好文章好博客</p><a id="more"></a><p><a href="https://www.cnblogs.com/tugenhua0707" target="_blank" rel="noopener">龙恩 0707</a></p><p><a href="https://github.com/renaesop/blog/issues/1" target="_blank" rel="noopener">cdn</a></p><p><a href="https://biaochenxuying.cn/" target="_blank" rel="noopener">全栈修炼</a></p><p><a href="https://yuchengkai.cn/" target="_blank" rel="noopener">前端进阶之道</a></p><p><a href="https://lucifer.ren/fe-interview/#/" target="_blank" rel="noopener">大前端面试宝典 - 图解前端</a></p><p><a href="https://mp.weixin.qq.com/s/FwrId8d2kCJKvtGTdM2xHw" target="_blank" rel="noopener">未来可期的 TypeScript</a></p><p><a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ" target="_blank" rel="noopener">别再说虚拟 DOM 快了，要被打脸的</a></p><p><a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A" target="_blank" rel="noopener">深入理解虚拟 DOM，它真的不快</a></p><p><a href="https://juejin.im/post/5d3e3231e51d4510926a7c39" target="_blank" rel="noopener">Deep In React 之详谈 React 16 Diff 策略(二)</a></p><p><a href="https://zhuanlan.zhihu.com/p/54042084" target="_blank" rel="noopener">ReactFiber 在并发模式下的运行机制</a></p><p><a href="https://zhuanlan.zhihu.com/p/78677852" target="_blank" rel="noopener">前端浏览器输入 URL 后发生什么</a></p><p><a href="https://github.com/fouber/blog/issues/6" target="_blank" rel="noopener">大公司如何部署前端代码</a></p><p><a href="https://zhuanlan.zhihu.com/p/53599723" target="_blank" rel="noopener">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo操作实录</title>
      <link href="/2019/04/03/hexo_note/"/>
      <url>/2019/04/03/hexo_note/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-操作实录"><a href="#hexo-操作实录" class="headerlink" title="hexo 操作实录"></a>hexo 操作实录</h2><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p><em>注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容</em></p><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>使用 npm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>使用 yarn:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add hexo-cli</span><br></pre></td></tr></table></figure><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</p><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>新建一篇文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><p>发表草稿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p><em>注： 更多命令见<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">官网</a></em></p><h3 id="部署-GitHub-pages"><a href="#部署-GitHub-pages" class="headerlink" title="部署 GitHub pages"></a>部署 GitHub pages</h3><h4 id="新建-GitHub-项目"><a href="#新建-GitHub-项目" class="headerlink" title="新建 GitHub 项目"></a>新建 GitHub 项目</h4><p>打开 GitHub 点击右上角的<code>new repository</code><br><img src="http://yanxuan.nosdn.127.net/e4ab3a5d71b66640072d74bd000cae04.png" alt="UTOOLS1588764262695.png"></p><p>然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建<br><img src="http://yanxuan.nosdn.127.net/5204b23ad8733af70ec1d2132e9dacff.png" alt="UTOOLS1588764393885.png"></p><h4 id="安装-hexo-deployer-git。"><a href="#安装-hexo-deployer-git。" class="headerlink" title="安装 hexo-deployer-git。"></a>安装 hexo-deployer-git。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="修改-config-yml-配置"><a href="#修改-config-yml-配置" class="headerlink" title="修改_config.yml 配置"></a>修改_config.yml 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>执行 hexo deploy 将生成的文件部署上去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="https://s1.ax1x.com/2020/05/06/YERAts.png" alt="YERAts.png"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo——轻量、简易、高逼格的博客</title>
      <link href="/2018/08/31/hexo/"/>
      <url>/2018/08/31/hexo/</url>
      
        <content type="html"><![CDATA[<p>这种方法可以根据文章的内容，自己在合适的位置添加标签，使用灵活，也是 Hexo 推荐的方法 ，这种方式也可以让 Hexo 中的插件更好的识别。</p><a id="more"></a><h1 id="通过-iframe-下载文件判断下载完成的方法"><a href="#通过-iframe-下载文件判断下载完成的方法" class="headerlink" title="通过 iframe 下载文件判断下载完成的方法"></a>通过 iframe 下载文件判断下载完成的方法</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"http://www.example.com/file.zip"</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">iframe.src = url;</span><br><span class="line">iframe.style.display = <span class="string">"none"</span>;</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">"start downloading..."</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.removeAttribute(iframe);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><p>当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。</p><p><code>Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行</code></p><h3 id="解决思路一：利用-cookie"><a href="#解决思路一：利用-cookie" class="headerlink" title="解决思路一：利用 cookie"></a>解决思路一：利用 cookie</h3><p>后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。<br>解决思路二：添加 header 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不让浏览器自动检测文件类型</span></span><br><span class="line"><span class="comment">// 说明资料：http://drops.wooyun.org/tips/1166</span></span><br><span class="line">response.addHeader(<span class="string">"X-Content-Type-Options"</span>, <span class="string">"nosniff"</span>);</span><br><span class="line"><span class="comment">// 提示浏览器不让其在frame或iframe中加载资源的文件内容</span></span><br><span class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</span></span><br><span class="line">response.addHeader(<span class="string">"X-Frame-Options"</span>, <span class="string">"deny"</span>);</span><br></pre></td></tr></table></figure><p>但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。</p><h3 id="解决思路三：轮询监听-readyState"><a href="#解决思路三：轮询监听-readyState" class="headerlink" title="解决思路三：轮询监听 readyState"></a>解决思路三：轮询监听 readyState</h3><p>定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframedownload"</span>);</span><br><span class="line">  <span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">  <span class="comment">// Check if loading is complete</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    iframeDoc.readyState == <span class="string">"complete"</span> ||</span><br><span class="line">    iframeDoc.readyState == <span class="string">"interactive"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    loadingOff();</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT技术 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo——轻量、简易、高逼格的博客</title>
      <link href="/2018/08/31/test/"/>
      <url>/2018/08/31/test/</url>
      
        <content type="html"><![CDATA[<p>当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。</p><a id="more"></a><h1 id="通过-iframe-下载文件判断下载完成的方法"><a href="#通过-iframe-下载文件判断下载完成的方法" class="headerlink" title="通过 iframe 下载文件判断下载完成的方法"></a>通过 iframe 下载文件判断下载完成的方法</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"http://www.example.com/file.zip"</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">iframe.src = url;</span><br><span class="line">iframe.style.display = <span class="string">"none"</span>;</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">"start downloading..."</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.removeAttribute(iframe);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><p>当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。</p><p><code>Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行</code></p><h3 id="解决思路一：利用-cookie"><a href="#解决思路一：利用-cookie" class="headerlink" title="解决思路一：利用 cookie"></a>解决思路一：利用 cookie</h3><p>后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。<br>解决思路二：添加 header 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不让浏览器自动检测文件类型</span></span><br><span class="line"><span class="comment">// 说明资料：http://drops.wooyun.org/tips/1166</span></span><br><span class="line">response.addHeader(<span class="string">"X-Content-Type-Options"</span>, <span class="string">"nosniff"</span>);</span><br><span class="line"><span class="comment">// 提示浏览器不让其在frame或iframe中加载资源的文件内容</span></span><br><span class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</span></span><br><span class="line">response.addHeader(<span class="string">"X-Frame-Options"</span>, <span class="string">"deny"</span>);</span><br></pre></td></tr></table></figure><p>但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。</p><h3 id="解决思路三：轮询监听-readyState"><a href="#解决思路三：轮询监听-readyState" class="headerlink" title="解决思路三：轮询监听 readyState"></a>解决思路三：轮询监听 readyState</h3><p>定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframedownload"</span>);</span><br><span class="line">  <span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">  <span class="comment">// Check if loading is complete</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    iframeDoc.readyState == <span class="string">"complete"</span> ||</span><br><span class="line">    iframeDoc.readyState == <span class="string">"interactive"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    loadingOff();</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT技术 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
