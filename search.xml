<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用软件大全</title>
      <link href="/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/others-%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h2 id="windows篇"><a href="#windows篇" class="headerlink" title="windows篇"></a>windows篇</h2><h3 id="1-Listary"><a href="#1-Listary" class="headerlink" title="1. Listary"></a>1. Listary</h3><p>它不仅可以在本地非常快速的搜索，还可以打开网站、在搜索引擎中搜索、随时随地打开快捷菜单、文件快速定位、快速打开cmd窗口等等优秀的功能；</p><p>比如输入 cmd打开cmd窗口，输入 cmda使用管理员权限打开cmd窗口，输入 wyyyy打开网易云音乐，找到某个文件的时候 Enter直接打开， Ctrl+Enter 是打开文件所在文件夹；</p><p>值得一提的是搜索关键词功能，让我们可以非常便捷的打开相应网站或在对应网站搜索，比如输入 gg我的存款呢？就可以直接使用默认浏览器在谷歌搜索中搜索了，我们还可以自定义输入其他关键字，只需把搜索链接中的关键字换成 {query} ~</p><h3 id="2-uTools"><a href="#2-uTools" class="headerlink" title="2. uTools"></a>2. uTools</h3><p>可以作为程序启动器外，uTools最大的特点就是拥有强大的插件系统，每个插件都有简洁美观、易于操作的界面，输入plugins进入插件管理，你就可以根据自己的需求挑选安装，组合成自己最趁手的工具合集，为各种日常操作提供便利。不断产生的新插件，也将为你带来无限可能。</p><blockquote><p>个人常用图床、剪切板、todo、各种技术文档等</p></blockquote><h3 id="3-Ditto"><a href="#3-Ditto" class="headerlink" title="3. Ditto"></a>3. Ditto</h3><p>Ditto 是一款免费开源的windows剪切板管理工具，作为 CtrlC V工程师，复制粘贴少不了，更厉害的是，可以用它来批量的复制， Ctrl+C一堆别人的代码，一次性全粘上，岂不美哉；</p><p>使用快捷键打开剪切板历史，然后 Ctrl/Shift来选择你希望粘贴的内容， Enter即可选择性的粘贴多行内容；另外剪切板历史还可以搜索，快速找到复制内容；</p><p>只需设置寥寥几个快捷键，就可以很方便的操作剪切板，带来极大幸福~<br><img src="http://yanxuan.nosdn.127.net/10fd3cf8452793dde3fd68c9d914f044.png" alt="UTOOLS1590592067470.png"></p><h3 id="4-Winsnap"><a href="#4-Winsnap" class="headerlink" title="4. Winsnap"></a>4. Winsnap</h3><p>看到上面的截图没，旁边都有很骚包的阴影，怎么做到的？不需要各种高大上的图片处理软件，只需 Winsnap ，它可以在截图的时候自动帮你加上背景阴影，然后帮你自动复制到剪切板；</p><p>它可以使用全屏、应用程序、窗口、对象等捕捉模式，更牛的是它还可以在截图的时候同时选择和捕捉多个对象，按住 Ctrl或 Shift选择多个窗口或对象…这个就比较厉害了，不信你试试？</p><p><img src="http://yanxuan.nosdn.127.net/89455e91edbd563fc808103fd3662506.png" alt="UTOOLS1590592103032.png"></p><h3 id="5-Cmder"><a href="#5-Cmder" class="headerlink" title="5. Cmder"></a>5. Cmder</h3><p>Cmder 是一个美观又实用的命令行工具，它支持大部分Linux命令，支持ssh连Linux，还可以在它的窗口中新建cmd和powershell，更多玩法等你来战~</p><p>比较方便的是在安装目录下 \config\user-aliases.cmd设置 alias 别名，比如参见的 Git 操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ga=git add $*</span><br><span class="line"></span><br><span class="line">gb=git branch $*</span><br><span class="line"></span><br><span class="line">gc=git commit $*</span><br><span class="line"></span><br><span class="line">gch=git checkout $*</span><br><span class="line"></span><br><span class="line">gd=git diff $*</span><br><span class="line"></span><br><span class="line">gl=git <span class="built_in">log</span> $*</span><br><span class="line"></span><br><span class="line">gs=git status $*</span><br></pre></td></tr></table></figure><p>还可以将cmder配置到右键菜单，快捷在当前目录打开cmder，方法是先把这个地址加到系统的path环境变量里面，比如我的是 D:cmder，然后右键 Cmder.exe属性-兼容性-以管理员身份运行此程序，再重新打开 Cmder.exe输入 Cmder.exe/REGISTER ALL就行了~</p><p>记得安装完在配置 Setting-Startup-Environment里面加上 setLANG=zh_CN.UTF8，否则输出的一些中文会乱码；</p><p><img src="http://yanxuan.nosdn.127.net/4eca0107c4b9cf08de8de8ae6ec58269.png" alt="UTOOLS1590592268002.png"></p><h3 id="6-Typora"><a href="#6-Typora" class="headerlink" title="6. Typora"></a>6. Typora</h3><p>使用过很多 Markdown 编辑器，最后选择了 Typora，与主流编辑器一边编辑一边预览的形式，Typora 是将编辑和预览合并到一起，简洁大方，目光也不需要在复杂的编辑区和预览区中来回切换了，只有当焦点移入的时候才显示 Markdown 语法；</p><p>另外 Typora 还支持 Latex、 [TOC]动态目录、拖拽图片自动生成本地预览链接、自定义主题等方便的功能；<br><img src="http://yanxuan.nosdn.127.net/f6c6fec071e757f18925e5c034a16c59.png" alt="UTOOLS1590592303191.png"></p><h3 id="7-Quick-Look"><a href="#7-Quick-Look" class="headerlink" title="7. Quick Look"></a>7. Quick Look</h3><p>QuickLook 是在 Microsoft Store 里面下载的一个速览工具，有时候打开一个PDF、TXT、图片之类的需要等关联程序启动半天，有了它之后只要选中目标文件，按空格，就可以快速预览了，速度非常快，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML等格式；</p><p>用它来看一些代码什么的，甚至不需要 Sublime\VSCode 启动就可以直接看了，如果只是速览一下的话是非常适合的了。</p><h3 id="8-Myper-Splash"><a href="#8-Myper-Splash" class="headerlink" title="8. Myper Splash"></a>8. Myper Splash</h3><p>Myper Splash 也是可以在 Microsoft Store 里面下载的一款高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用，再加上简洁美观的UI/UX设计，让你体验一见钟情的感觉。</p><p>另外 MyperSplash 可以设置自动每天自动更换壁纸或锁屏，每天早晨来到办公室点亮屏幕就可以看到 Awesome 的锁屏或壁纸，让你带着好心情开启一天的工作。</p><h3 id="9-GifCam-ScreenToGif"><a href="#9-GifCam-ScreenToGif" class="headerlink" title="9. GifCam / ScreenToGif"></a>9. GifCam / ScreenToGif</h3><p>相信大家都有过需要截一个 Gif 的时候，这里有两个免费 Gif 屏幕录制工具都很不错，小而美的 GifCam 和开源强大的 ScreenToGif ；</p><h3 id="10-Free-Download-Manage"><a href="#10-Free-Download-Manage" class="headerlink" title="10. Free Download Manage"></a>10. Free Download Manage</h3><p>Free Download Manage (FDM) 是一款免费的下载工具，如果你已经受够了国内一些软件的广告和限速，那么 FDM 是一个不错的选择，另外多线程、断点续传、计划任务等功能让 FDM 值得推介。</p><h3 id="11-Sourcetree"><a href="#11-Sourcetree" class="headerlink" title="11. Sourcetree"></a>11. Sourcetree</h3><p>Sourcetree 是跨平台免费的 Git 客户端管理工具，如果受够了手打各种 Git 操作命令，那么 Sourcetree 是一个不错的选择；</p><p>Sourcetree 可以大大简化你的代码操作，特别是对于一些不甚熟悉 Git 命令的人来说灰常实用；一些对 Git 操作比较熟练的用户也可以用它来提升效率，减少出错。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centOS7安装Java环境</title>
      <link href="/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/"/>
      <url>/others-centOS7%E5%AE%89%E8%A3%85Java%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>记录一次在阿里云（系统CentOS 7.4 64位）安装配置Java环境的过程</p><a id="more"></a><h3 id="1-选择合适的jdk版本"><a href="#1-选择合适的jdk版本" class="headerlink" title="1. 选择合适的jdk版本"></a>1. 选择合适的jdk版本</h3><blockquote><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">jdk下载地址</a></p></blockquote><p>选择一下版本获取下载链接<br><img src="http://yanxuan.nosdn.127.net/3f479b3d56b3bfc9acad57e9a09fa94f.png" alt="UTOOLS1590136537164.png"></p><h3 id="2-下载"><a href="#2-下载" class="headerlink" title="2. 下载"></a>2. 下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b</span><br></pre></td></tr></table></figure><blockquote><p>此链接地址可能失效，请自行在步骤1中获取最新下载链接</p></blockquote><p>下载后检查安装包大小是否符合预期（判断安装包是否损坏）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lht</span><br></pre></td></tr></table></figure><p><img src="http://yanxuan.nosdn.127.net/a9167b8a26ab786fadfaad86f432d0e9.png" alt="UTOOLS1590136951543.png"></p><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><p>3.1. 创建安装目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/java/</span><br></pre></td></tr></table></figure><p>3.2 解压到安装目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u251-linux-x64.tar.gz?AuthParam=1590135363_2f6dbe12605da3b1164a50e7c1a8db7b -C /usr/local/java</span><br></pre></td></tr></table></figure><h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h3><p>打开profile文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure><p>在末尾添加一下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_251</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>使环境变量生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>添加软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/java/jdk1.8.0_251/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><p>验证是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="http://yanxuan.nosdn.127.net/7e0334391843b73fbfbc4963591ab65e.png" alt="UTOOLS1590137306874.png"></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript新特性</title>
      <link href="/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/javascript-ECMAScript%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>2015年6月发布了ES 6，也就是我们今天广泛使用的版本。这之后每年6月发布一个极小更新的ES版本，比如2016年6月发布的 ES  2016 叫做ES 7，而这个版本只增加了两个新特性。截止目前，ES 11的提案已经定稿了。</p><a id="more"></a><h2 id="ES-7-新特性"><a href="#ES-7-新特性" class="headerlink" title="ES 7 新特性"></a>ES 7 新特性</h2><table><thead><tr><th align="left">功能点</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Array.prototype.includes</td><td align="left">查找数组</td></tr><tr><td align="left">Exponentiation operator</td><td align="left">指数函数的中缀表示法</td></tr></tbody></table><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>includes是一个Array上很有用的方法，用于快速查找数组中是否包含某个元素，包括NaN（和indexOf不一样的点)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="number">2</span>)) &#123;</span><br><span class="line">  <span class="comment">//查找2是否存在于arr数组中</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"找到了!"</span>); <span class="comment">//&gt;&gt; 找到了！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!arr.includes(<span class="number">2</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="comment">//第二个参数3表示数组下标为3的项，也即第4项开始查找</span></span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">"不存在!"</span>); <span class="comment">//&gt;&gt; 不存在！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两句说明incluedes和indexOf的区别</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>) != <span class="number">-1</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="指数函数用法"><a href="#指数函数用法" class="headerlink" title="指数函数用法"></a>指数函数用法</h3><p>JavaScript采用两个星符号**来表示Math.pow，相对于Math.pow的好处：</p><ol><li>中缀表示法比函数表示法更简洁，这使它更可取。</li><li>方便数学、物理、机器人学等领域的计算。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法一：x ** y</span></span><br><span class="line"><span class="keyword">let</span> squared = <span class="number">2</span> ** <span class="number">2</span>;<span class="comment">//等同于: 2 * 2</span></span><br><span class="line"><span class="keyword">let</span> cubed = <span class="number">2</span> ** <span class="number">3</span>;<span class="comment">//等同于: 2 * 2 * 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法二：x **= y</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">a **= <span class="number">2</span>;<span class="comment">//等同于: a = a * a;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">b **= <span class="number">3</span>;<span class="comment">//等同于: b = b * b * b;</span></span><br></pre></td></tr></table></figure><h2 id="ES-8-新特性"><a href="#ES-8-新特性" class="headerlink" title="ES 8 新特性"></a>ES 8 新特性</h2><table><thead><tr><th align="left">功能点</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Object.values / Object.entries</td><td align="left"></td></tr><tr><td align="left">String padding</td><td align="left">字符串追加</td></tr><tr><td align="left">Object.getOwnPropertyDescriptors</td><td align="left">返回指定对象自己所有的属性内容</td></tr><tr><td align="left">Async functions</td><td align="left">异步函数</td></tr><tr><td align="left">Shared memory and atomics</td><td align="left">共享内存和 Atomics 对象</td></tr></tbody></table><h3 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values() / Object.entries"></a>Object.values() / Object.entries</h3><ul><li>Object.values(obj)，obj 参数是对目标对象的操作，它可以是一个对象或者数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['xxx', 1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>]; <span class="comment">// 等同于 &#123; 0: 'e', 1: 's', 2: '8' &#125;;</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['e', 's', '8']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当把数字对象的当键的时候，返回的数组以键的值升序排序</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ['yyy', 'zzz', 'xxx']</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="string">'es8'</span>); <span class="comment">// ['e', 's', '8']</span></span><br></pre></td></tr></table></figure><ul><li>Object.entries方法返回一个给定对象可枚举属性值的数组[key, value]，与Object.values类似</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="string">'xxx'</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['x', 'xxx'], ['y', 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = [<span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'8'</span>];</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">'xxx'</span>, <span class="number">1</span>: <span class="string">'yyy'</span>, <span class="number">3</span>: <span class="string">'zzz'</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['1', 'yyy'], ['3', 'zzz'], ['10', 'xxx']]</span></span><br><span class="line"><span class="built_in">Object</span>.entries(<span class="string">'es8'</span>); <span class="comment">// [['0', 'e'], ['1', 's'], ['2', '8']]</span></span><br></pre></td></tr></table></figure><h3 id="字符串追加"><a href="#字符串追加" class="headerlink" title="字符串追加"></a>字符串追加</h3><p>在 ES 8 中String新增了两个实例函数String.prototype.padStart和String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。<br><code>String.padStart(targetLength,[padString])</code><br>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。<br>padString：(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为空格。<br><code>String.padEnd(targetLength,padString]) 参数释义同上。</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">2</span>);          <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">5</span>);          <span class="comment">// '  es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">6</span>, <span class="string">'1891'</span>);  <span class="comment">// '189es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">14</span>, <span class="string">'coffe'</span>);  <span class="comment">// 'coffecoffecoffes8'</span></span><br><span class="line"><span class="string">'es8'</span>.padStart(<span class="number">7</span>, <span class="string">'0'</span>);     <span class="comment">// '0000es8'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">2</span>);            <span class="comment">// 'es8'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">5</span>);            <span class="comment">// 'es8  '</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">6</span>, <span class="string">'1891'</span>);    <span class="comment">// 'es81891'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">14</span>, <span class="string">'coffe'</span>);    <span class="comment">// 'es8coffecoffecoff'</span></span><br><span class="line"><span class="string">'es8'</span>.padEnd(<span class="number">7</span>, <span class="string">'9'</span>);       <span class="comment">// 'es89999'</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p><code>getOwnPropertyDescriptors</code>方法返回指定对象自己所有的属性内容，并且属性内容只是自身直接定义的，而不是从object的原型继承而来的。<br>定义是：<code>Object.getOwnPropertyDescriptors(obj)</code>，<code>obj</code> 是指目标对象，这个方法返回的值可能是 configurable、enumerable、writable、get、set 和 value。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> es7() &#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;,</span><br><span class="line">  <span class="keyword">get</span> es8() &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   es7: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es7()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   es8: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function es8()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>getOwnPropertyDescriptors可以用来创建子类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">superclass.prototype = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">subclass.prototype = <span class="built_in">Object</span>.create(superclass.prototype, <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>Async Functions也就是我们常说的Async/Await,已经用的很频繁了，在此不再赘述。</p><h3 id="SharedArrayBuffer-amp-Atomics"><a href="#SharedArrayBuffer-amp-Atomics" class="headerlink" title="SharedArrayBuffer &amp; Atomics"></a>SharedArrayBuffer &amp; Atomics</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p><blockquote><p>请注意，作为对Spectre的响应，所有主流浏览器均默认于2018年1月5日禁用SharedArrayBuffer。 Chrome在启用了网站隔离功能的平台上的v67中重新启用了该功能，以防止出现Spectre风格的漏洞。</p></blockquote><ul><li>语法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>length 所创建的数组缓冲区的大小，以字节(byte)为单位。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;SharedArrayBuffer&#125;</span> </span>一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> SharedArrayBuffer(length)</span><br></pre></td></tr></table></figure><p>共享内存能被同时创建和更新于工作者线程或主线程。依赖于系统（CPU，操作系统，浏览器），变化传递给所有上下文环境需要一段时间。需要通过 atomic 操作来进行同步。</p><p><code>Atomics</code> 对象提供了一组静态方法用来对 <code>SharedArrayBuffer</code> 对象进行原子操作。这些原子操作属于 <code>Atomics</code> 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 <code>Math</code>  对象一样）。</p><p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/add" target="_blank" rel="noopener">Atomics.add()</a></td><td align="left">将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/and" target="_blank" rel="noopener">Atomics.and()</a></td><td align="left">将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/compareExchange" target="_blank" rel="noopener">Atomics.compareExchange()</a></td><td align="left">如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/exchange" target="_blank" rel="noopener">Atomics.exchange()</a></td><td align="left">将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/load" target="_blank" rel="noopener">Atomics.load()</a></td><td align="left">返回数组中指定元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/or" target="_blank" rel="noopener">Atomics.or()</a></td><td align="left">将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/store" target="_blank" rel="noopener">Atomics.store()</a></td><td align="left">将数组中指定的元素设置为给定的值，并返回该值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/sub" target="_blank" rel="noopener">Atomics.sub()</a></td><td align="left">将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/xor" target="_blank" rel="noopener">Atomics.xor()</a></td><td align="left">将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wait" target="_blank" rel="noopener">Atomics.wait()</a></td><td align="left">检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/wake" target="_blank" rel="noopener">Atomics.wake()</a></td><td align="left">唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</td></tr><tr><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics/isLockFree" target="_blank" rel="noopener">Atomics.isLockFree(size)</a></td><td align="left">可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</td></tr></tbody></table><h2 id="ES-9-新特性"><a href="#ES-9-新特性" class="headerlink" title="ES 9 新特性"></a>ES 9 新特性</h2><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Asynchronous Iteration</td><td align="left">异步迭代器</td></tr><tr><td align="left"><code>Promise.prototype.finally</code></td><td align="left"></td></tr><tr><td align="left">Lifting template literal restriction</td><td align="left">重新修订了字面量的转义</td></tr><tr><td align="left">Rest/Spread Properties</td><td align="left">Rest/Spread 属性</td></tr><tr><td align="left"><code>s</code> (dotAll) flag for regular expressions</td><td align="left">正则表达式dotAll模式</td></tr><tr><td align="left">RegExp named capture groups</td><td align="left">正则表达式命名捕获组</td></tr><tr><td align="left">RegExp Lookbehind Assertions</td><td align="left">正则表达式反向断言</td></tr><tr><td align="left">RegExp Unicode Property Escapes</td><td align="left">正则表达式 Unicode 转义</td></tr></tbody></table><h3 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h3><p>在<code>async</code>/<code>await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> someFunc(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不会达到预期目的，下面这段同样也不会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> someFunc(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，循环本身依旧保持同步，并在内部异步函数之前全部调用完成。</p><p>引入异步迭代器后，就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;<span class="comment">//异步迭代</span></span><br><span class="line">    someFunc(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细论述见“壹.2.12”。</p><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p>一个Promise调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除数组、删除对话、关闭数据库连接等，<code>.finally()</code>允许实现这样的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  promiseFunc() <span class="comment">//返回一个Promise对象</span></span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//无论promiseFunc()运行成功还是失败，这里的代码会被调用到</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多详细论述见“壹.2.12”。</p><h3 id="重新修订了字面量的转义"><a href="#重新修订了字面量的转义" class="headerlink" title="重新修订了字面量的转义"></a>重新修订了字面量的转义</h3><p>ES9 之前，<code>\u</code>表示 unicode 转义，<code>\x</code>表示十六进制转义，<code>\</code>后跟一个数字表示八进制转义，这使得创建特定的字符串变得不可能，例如Windows文件路径<code>C:\uuu\xxx\111</code>。</p><p>要取消转义序列的语法限制，可在模板字符串之前使用标记函数<code>String.raw</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">`\u&#123;54&#125;`</span> <span class="comment">//会转义成unicode "T"</span></span><br><span class="line"><span class="built_in">console</span>.log(s);<span class="comment">//&gt;&gt; T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="built_in">String</span>.raw<span class="string">`\u&#123;54&#125;`</span>; <span class="comment">//不会被转义</span></span><br><span class="line"><span class="built_in">console</span>.log(str);<span class="comment">//&gt;&gt; \u&#123;54&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest / Spread 属性"></a>Rest / Spread 属性</h3><p>这个就是我们通常所说的三个点<code>...</code>，在<code>=</code>左边的是<strong>rest参数</strong>，放在<code>=</code>右边或者作为参数的是<strong>扩展运算符</strong>，这项特性在ES6中已经引入，但是ES6中的作用对象仅限于数组。在ES9中，为对象提供了像数组一样的rest参数和扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a, ...param &#125; = obj; <span class="comment">//这里...是rest参数</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//&gt;&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(param); <span class="comment">//&gt;&gt; &#123;b: 2, c: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; a, ...param &#125;</span>) </span>&#123;<span class="comment">//这里...是扩展运算符</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//&gt;&gt; 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(param); <span class="comment">//&gt;&gt; &#123;b: 2, c: 3&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h3><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许匹配回车换行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">'hello\nworld'</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">'hello\nworld'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/hello.world/</span>s.test(<span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span>))   <span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><p>Javascript正则表达式中使用<code>exec()</code>匹配后，能够返回一个包含匹配字符串的类数组对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>,</span><br><span class="line">  match = reDate.exec(<span class="string">"2018-08-06"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);<span class="comment">//&gt;&gt; [2018-08-06, 2018, 08, 06]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样就可以直接用索引来获取年月日：</span></span><br><span class="line"><span class="keyword">let</span> year = match[<span class="number">1</span>]; <span class="comment">//&gt;&gt; 2018</span></span><br><span class="line"><span class="keyword">let</span> month = match[<span class="number">2</span>]; <span class="comment">//&gt;&gt; 08</span></span><br><span class="line"><span class="keyword">let</span> day = match[<span class="number">3</span>]; <span class="comment">//&gt;&gt; 06</span></span><br></pre></td></tr></table></figure><p>返回数组的第0项为与正则表达式相匹配的文本，第 1 项是与 <code>reDate</code> 的第 1 个分组<code>\d{4}</code>相匹配的文本（如果有的话），第 2 项是与 <code>reDate</code> 的第 2 个分组<code>\d{2}</code>相匹配的文本（如果有的话），以此类推。正则表达式的组以<code>()</code>包起来。</p><p>上面的案例，若是日期格式变成<code>月日年</code>，那么改变正则表达式的结构后，还有可能会改变变量的赋值部分的代码。如下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(\d&#123;2&#125;)-(\d&#123;2&#125;)-(\d&#123;4&#125;)/</span>,<span class="comment">//表达式结构变化了</span></span><br><span class="line">  match = reDate.exec(<span class="string">"08-06-2018"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);<span class="comment">//&gt;&gt; [08-06-2018, 08, 06, 2018]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时年月日的赋值代码也要改了,改的地方真多啊！怎么办？</span></span><br><span class="line"><span class="keyword">let</span> year = match[<span class="number">3</span>]; <span class="comment">//&gt;&gt; 2018</span></span><br><span class="line"><span class="keyword">let</span> month = match[<span class="number">1</span>]; <span class="comment">//&gt;&gt; 08</span></span><br><span class="line"><span class="keyword">let</span> day = match[<span class="number">2</span>]; <span class="comment">//&gt;&gt; 06</span></span><br></pre></td></tr></table></figure><p>可以发现上面的写法改的地方太多了，有没有办法少改点代码省省事呢？有！ ES9 允许使用符号<code>?&lt;name&gt;</code>来命名<strong>捕获组</strong>（也即“匹配到的组”），示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>,</span><br><span class="line">  match = reDate.exec(<span class="string">"2018-08-06"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match);</span><br><span class="line"><span class="comment">//&gt;&gt; [2018-08-06, 08, 06, 2018, groups: &#123;day: 06, month: 08, year: 2018&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时用groups对象来获取年月日，无论正则表达式怎么变换，这下面三行不用改了，省事！</span></span><br><span class="line"><span class="keyword">let</span> year = match.groups.year; <span class="comment">//&gt;&gt; 2018</span></span><br><span class="line"><span class="keyword">let</span> month = match.groups.month; <span class="comment">//&gt;&gt; 08</span></span><br><span class="line"><span class="keyword">let</span> day = match.groups.day; <span class="comment">//&gt;&gt; 06</span></span><br></pre></td></tr></table></figure><p>命名捕获组的写法相当于是把每个捕获组都定义了一个名字，然后存储到返回值的<code>groups</code>属性中。</p><h3 id="正则表达式后行断言"><a href="#正则表达式后行断言" class="headerlink" title="正则表达式后行断言"></a>正则表达式后行断言</h3><p>先看看正则表达式<strong>先行断言</strong>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/\D(\d+)/</span>,</span><br><span class="line">    re2 = <span class="regexp">/\D(?=\d+)/</span>,<span class="comment">//"?="是正向先行断言</span></span><br><span class="line">    match1 = re1.exec(<span class="string">"$123.45"</span>),</span><br><span class="line">    match2 = re2.exec(<span class="string">"$123.45"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1[<span class="number">0</span>]); <span class="comment">//&gt;&gt; $123</span></span><br><span class="line"><span class="built_in">console</span>.log(match2[<span class="number">0</span>]); <span class="comment">//&gt;&gt; $</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>(?=pattern)</strong> 零宽正向先行断言(zero-width positive lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p>(<strong>?!pattern)</strong> 零宽负向先行断言(zero-width negative lookahead assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之后</strong>的字符序列<strong>不能匹配</strong>pattern；</p><p><strong>(?&lt;=pattern)</strong> 零宽正向后行断言(zero-width positive lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>能够匹配</strong>pattern；</p><p><strong>(?&lt;!pattern)</strong> 零宽负向后行断言(zero-width negative lookbehind assertion)<br>代表字符串中的一个位置，<strong>紧接该位置之前</strong>的字符序列<strong>不能匹配</strong>pattern。</p></blockquote><p>在ES9中，可以允许使用<code>?&lt;=</code>进行<strong>正向后行断言</strong>，可以获取货币的价格而忽略货币符号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re= <span class="regexp">/(?&lt;=\D)[\d\.]+/</span>,</span><br><span class="line">    match = re.exec(<span class="string">"$123.45"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>]); <span class="comment">//&gt;&gt; 123.45</span></span><br></pre></td></tr></table></figure><p>上面的正向后行断言，也就是说<code>\D</code>这个条件必须满足，但<code>\D</code>匹配的字符不会作为结果输出（因为<strong>先行/后行断言</strong>其实只是匹配了一个位置）。如果是下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re= <span class="regexp">/(?&lt;=\D)[\d\.]+/</span>,</span><br><span class="line">    match1 = re.exec(<span class="string">"123.45"</span>),</span><br><span class="line">    match2 = re.exec(<span class="string">"12345"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match1 &amp;&amp; match1[<span class="number">0</span>]); <span class="comment">//&gt;&gt; 45</span></span><br><span class="line"><span class="built_in">console</span>.log(match2 &amp;&amp; match1[<span class="number">0</span>]); <span class="comment">//&gt;&gt; null</span></span><br></pre></td></tr></table></figure><p>可以看到<code>match1</code>匹配到的是<code>45</code>,这是由于在<code>.</code>前面没有任何符合<code>\D</code>的匹配内容，它会一直找到符合<code>\D</code>的内容，也就是<code>.</code>然后返回后面的内容。而<code>match2</code>若是没有满足前面肯定反向断言的条件的话，则结果返回<code>null</code>。</p><h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>ES9 之前，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES9 添加了 Unicode 属性转义，形式为<code>\p{...}</code>和<code>\P{...}</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\p</code>的<code>{...}</code>内，可用键值对的方式设置需要匹配的属性而非具体内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;<span class="comment">//Greek为希腊语的意思</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">'a'</span>)); <span class="comment">//&gt;&gt; flase</span></span><br><span class="line"><span class="built_in">console</span>.log(regex.test(<span class="string">'Σ'</span>)); <span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure><h2 id="ES-10-新特性"><a href="#ES-10-新特性" class="headerlink" title="ES 10 新特性"></a>ES 10 新特性</h2><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left">Optional <code>catch</code> binding</td><td align="left">可选的 catch 变量绑定</td></tr><tr><td align="left">JSON superset</td><td align="left">JSON超集</td></tr><tr><td align="left"><code>Symbol.prototype.description</code></td><td align="left">Symbol 对象的 description 属性</td></tr><tr><td align="left"><code>Function.prototype.toString</code> revision</td><td align="left">修订<code>Function.prototype.toString</code></td></tr><tr><td align="left"><code>Object.fromEntries</code></td><td align="left"></td></tr><tr><td align="left">Well-formed <code>JSON.stringify</code></td><td align="left">更加友好的JSON.stringify</td></tr><tr><td align="left"><code>String.prototype.{trimStart,trimEnd}</code></td><td align="left"></td></tr><tr><td align="left"><code>Array.prototype.{flat,flatMap}</code></td><td align="left"></td></tr></tbody></table><h3 id="可选的-catch-变量绑定"><a href="#可选的-catch-变量绑定" class="headerlink" title="可选的 catch 变量绑定"></a>可选的 catch 变量绑定</h3><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的，而 ES10 使我们能够简单的把变量省略掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前是</span></span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES10之后可以写成，</span></span><br><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> &#123;&#125;<span class="comment">//省掉了变量e</span></span><br></pre></td></tr></table></figure><h3 id="JSON超集"><a href="#JSON超集" class="headerlink" title="JSON超集"></a>JSON超集</h3><p>什么是 JSON 超集？简单来说就是 JSON 是 ECMAScript 的子集，也就是说让 ECMAScript 兼容 JSON 的内容所支持的全部文本。</p><p>ECMAScript 在标准 <a href="https://tc39.es/ecma262/#sec-json.parse" target="_blank" rel="noopener">JSON.parse</a> 部分阐明了 JSON 确为其一个子集，但由于 JSON 的内容可以正常包含 <code>U+2028</code> 行分隔符与 <code>U+2029</code> 段落分隔符，而 ECMAScript 却不行，所以，该草案旨在解决这一问题。在这之前，如果你使用 <code>JSON.parse()</code> 执行带如上特殊字符的字符串时，只会收到 <code>SyntaxError</code> 的错误提示。该草案同样是向后兼容的，其对用户唯一的影响是保持原样，即在暂不支持特殊字符解析的运行环境中保持报错 <code>SyntaxError</code> 。</p><h3 id="Symbol-对象的-description-属性"><a href="#Symbol-对象的-description-属性" class="headerlink" title="Symbol 对象的 description 属性"></a>Symbol 对象的 description 属性</h3><p>ES10 中为 Symbol 对象添加了只读属性 <code>description</code> ，该对象返回包含 Symbol 描述的字符串。在创建Symbol时向其添加<code>description</code> (描述)，能够直接访问<code>description</code> ，对调试是很有用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);<span class="comment">//添加的描述内容为“foo”</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.description);<span class="comment">//&gt;&gt; foo</span></span><br><span class="line"></span><br><span class="line">sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(sym.description);<span class="comment">//&gt;&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//和 Symbol() 不同的是，用 Symbol.for() 方法创建的的 symbol 会被放入一个全局</span></span><br><span class="line"><span class="comment">//symbol 注册表中。Symbol.for() 并不是每次都会创建一个新的 symbol，它会首先检</span></span><br><span class="line"><span class="comment">//查给定的 key 是否已经在注册表中了。假如是，则会直接返回上次存储的那个。否则，它</span></span><br><span class="line"><span class="comment">//会再新建一个。</span></span><br><span class="line">sym = <span class="built_in">Symbol</span>.for(<span class="string">'bar'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sym.description);<span class="comment">//&gt;&gt; bar</span></span><br></pre></td></tr></table></figure><h3 id="修订Function-prototype-toString"><a href="#修订Function-prototype-toString" class="headerlink" title="修订Function.prototype.toString"></a>修订Function.prototype.toString</h3><p>函数原型上的方法<code>toString()</code>现在返回精确字符，包括空格和注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">comment</span> */ <span class="title">foo</span> /* <span class="title">another</span> <span class="title">comment</span> */(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES10之前不会打印注释部分</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">//&gt;&gt; function foo()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES10里，会把注释一同打印</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">//&gt;&gt; function /* comment */ foo /* another comment */ ()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//箭头函数是个例外</span></span><br><span class="line"><span class="keyword">const</span> bar <span class="comment">/* comment */</span> = <span class="comment">/* another comment */</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(bar.toString()); <span class="comment">//&gt;&gt; () =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>在 JavaScript 操作中，数据在各种数据结构之间的转换都是很容易的，比如 Map 到数组、Map 到 Set、对象到 Map 等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'foo'</span>, <span class="literal">true</span>).set(<span class="string">'bar'</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(map);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(map.values());</span><br><span class="line"></span><br><span class="line">let obj = &#123; foo: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="comment">//下一句 Object.entries() 方法返回给定对象 obj 自身可枚举属性的键值对数组,</span></span><br><span class="line"><span class="comment">//形如：[["foo",true],["bar",false]]</span></span><br><span class="line"><span class="keyword">let</span> newMap = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure><p>但是如果我们需要将一个键值对列表转换为对象，就要写点费劲的代码了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"foo"</span>, <span class="literal">true</span>).set(<span class="string">"bar"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Array</span>.from(map).reduce(<span class="function">(<span class="params">acc, [key, val]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(acc, &#123;</span><br><span class="line">    [key]: val</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, &#123;&#125;);</span><br></pre></td></tr></table></figure><p>该特性的目的在于为对象添加一个新的静态方法 <code>Object.fromEntries</code>，用于将符合键值对的列表（例如 Map、数组等）转换为一个对象。上一块的代码中的转换逻辑，现在我们只需要一行代码即可搞定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">"foo"</span>, <span class="literal">true</span>).set(<span class="string">"bar"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.fromEntries(map);</span><br></pre></td></tr></table></figure><h3 id="更加友好的-JSON-stringify"><a href="#更加友好的-JSON-stringify" class="headerlink" title="更加友好的 JSON.stringify"></a>更加友好的 JSON.stringify</h3><p>ES10 之前，当你使用 <code>JSON.stringify()</code> 处理无法用 UTF-8 编码表示的字符时（U+D800 至 U+DFFF），返回的结果会是一个乱码 Unicode 字符“�”。该特性提出用<code>JSON.stringify()</code>来安全的表示这些不正常的UTF-8字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r;</span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">"❤"</span>); <span class="comment">//正常的UTF-8字符原样输出</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "❤"</span></span><br><span class="line"></span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">'\u2764'</span>); <span class="comment">//正常的UTF-8字符编码，输出解码之后的模样</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "❤"</span></span><br><span class="line"></span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">"\uDF06\uD834"</span>); <span class="comment">//不正常的UTF-8字符编码，则以unicode形式输出</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "\udf06\ud834"</span></span><br><span class="line"></span><br><span class="line">r = <span class="built_in">JSON</span>.stringify(<span class="string">"\uDEAD"</span>); <span class="comment">//不正常的UTF-8字符编码，则以unicode形式输出</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; "\udead"</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trimStart-trimEnd"><a href="#String-prototype-trimStart-trimEnd" class="headerlink" title="String.prototype.{trimStart,trimEnd}"></a>String.prototype.{trimStart,trimEnd}</h3><p>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法，这两个方法很好理解，分别去除字符串首、尾的空白字符，就不举例占篇幅了。</p><h3 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.{flat,flatMap}"></a>Array.prototype.{flat,flatMap}</h3><p>这个特性新创造了两个方法，其中：</p><ul><li><code>Array.prototype.flat</code> 数组的所有项会以指定的维度降维（扁平化），然后组成新数组返回；</li><li><code>Array.prototype.flatMap</code> 首先会执行一次<code>map()</code>方法，然后再通过类似<code>flat()</code>方法<strong>扁平化</strong>数组。它等同于执行完 <code>map()</code> 后再执行一次 <code>flat()</code> 方法，所以当你执行 <code>map()</code> 返回的结果如果是个数组，然后又要将其扁平化时，这个方法会显得方便。</li></ul><p>来看几个例子解释一下，首先 <code>flat()</code> 方法支持多维数组的扁平化，其中<code>Infinity</code>可以将多维数组压扁成一维数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r;</span><br><span class="line">r = [<span class="string">"1"</span>, [<span class="string">"8"</span>, [<span class="string">"9"</span>, [<span class="string">"1"</span>]]]].flat();<span class="comment">//4维数组，默认降维1，变成3维数组</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ '1', '8', [ '9', ['1'] ] ]</span></span><br><span class="line"></span><br><span class="line">r = [<span class="string">"1"</span>, [<span class="string">"8"</span>, [<span class="string">"9"</span>, [<span class="string">"1"</span>]]]].flat(<span class="number">2</span>); <span class="comment">//4维数组，降维2，变成2维数组</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ '1', '8', '9', ['1'] ]</span></span><br><span class="line"></span><br><span class="line">r = [<span class="string">"1"</span>, [<span class="string">"8"</span>, [<span class="string">"9"</span>, [<span class="string">"1"</span>]]]].flat(<span class="literal">Infinity</span>);<span class="comment">//4维数组，最多变成1维数组</span></span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ '1', '8', '9', '1' ]</span></span><br></pre></td></tr></table></figure><p>接着来看看<code>flatMap()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r;</span><br><span class="line">r = [<span class="string">"I love"</span>, <span class="string">"coffe 1891"</span>].map(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt; [ [ 'I', 'love' ], [ 'coffe', '1891' ] ]</span></span><br><span class="line"></span><br><span class="line">r = [<span class="string">"I love"</span>, <span class="string">"coffe 1891"</span>].flatMap(<span class="function"><span class="params">item</span> =&gt;</span> item.split(<span class="string">" "</span>));</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">//&gt;&gt;[ 'I', 'love', 'coffe', '1891' ]</span></span><br></pre></td></tr></table></figure><h2 id="ES-11-新特性一览"><a href="#ES-11-新特性一览" class="headerlink" title="ES 11 新特性一览"></a>ES 11 新特性一览</h2><table><thead><tr><th align="left">新特性</th><th align="left">中文说明</th></tr></thead><tbody><tr><td align="left"><code>String.prototype.matchAll</code></td><td align="left"></td></tr><tr><td align="left"><code>import()</code></td><td align="left">import()函数</td></tr><tr><td align="left"><code>Promise.allSettled</code></td><td align="left"></td></tr></tbody></table><h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器（iterator）。 在 <code>matchAll</code> 出现之前，通过在循环中调用<code>Regexp.exec</code>来获取所有匹配项信息（<code>Regexp</code>需使用<code>/g</code>标志）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">'foo*'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'coffe football, foosball'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((matches = regexp.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`找到 <span class="subst">$&#123;matches[<span class="number">0</span>]&#125;</span>，下一轮循环从位置 <span class="subst">$&#123;regexp.lastIndex&#125;</span> 开始`</span>);</span><br><span class="line">  <span class="comment">//&gt;&gt; 找到 foo，下一轮循环从位置 9 开始</span></span><br><span class="line">  <span class="comment">//&gt;&gt; 找到 foo，下一轮循环从位置 19 开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<code>matchAll</code> ，就可以不必使用<code>while</code>循环加<code>exec</code>方式（且正则表达式需使用<code>/g</code>标志）。使用<code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>，<code>array spread</code>，<code>Array.from()</code> 可以更方便实现功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">'foo*'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'coffe football, foosball'</span>;</span><br><span class="line"><span class="keyword">let</span> matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> matches) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&gt;&gt; [ "foo" ]</span></span><br><span class="line"><span class="comment">//&gt;&gt; [ "foo" ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//matches的迭代器在for..of之后已经被消耗掉了，</span></span><br><span class="line"><span class="comment">//需要再次调用matchAll创建一个新的迭代器</span></span><br><span class="line">matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(matches, m =&gt; m[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//&gt;&gt; [ "foo", "foo" ]</span></span><br></pre></td></tr></table></figure><h3 id="import-函数"><a href="#import-函数" class="headerlink" title="import()函数"></a>import()函数</h3><p>这个特性为JavaScript添加了一个类函数（function-like）的<code>import()</code>功能，以便可以像函数传参那样传入参数实现<strong>动态</strong>（没错，<code>import</code>是静态引用的）引用模块（module）。下面有个单页应用简单示例，演示了用<code>import()</code>开启懒加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;nav&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;books.html&quot; data-entry-module&#x3D;&quot;books&quot;&gt;书籍&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;movies.html&quot; data-entry-module&#x3D;&quot;movies&quot;&gt;电影&lt;&#x2F;a&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;video-games.html&quot; data-entry-module&#x3D;&quot;video-games&quot;&gt;电视游戏&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br><span class="line"></span><br><span class="line">&lt;main&gt;内容将会加载到这里！&lt;&#x2F;main&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const main &#x3D; document.querySelector(&quot;main&quot;);</span><br><span class="line">  for (const link of document.querySelectorAll(&quot;nav &gt; a&quot;)) &#123;</span><br><span class="line">    link.addEventListener(&quot;click&quot;, e &#x3D;&gt; &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line"></span><br><span class="line">      import(&#96;.&#x2F;section-modules&#x2F;$&#123;link.dataset.entryModule&#125;.js&#96;)&#x2F;&#x2F;动态引用</span><br><span class="line">        .then(module &#x3D;&gt; &#123;&#x2F;&#x2F;加载模块成功以后，该模块会当作then方法的参数</span><br><span class="line">          module.loadPageInto(main);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err &#x3D;&gt; &#123;&#x2F;&#x2F;捕捉异常</span><br><span class="line">          main.textContent &#x3D; err.message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>请注意<code>import()</code>和<code>import</code>的区别：</p><ul><li>import() 可以用在script脚本区，不止是模块内；</li><li>如果在模块内使用import()，它可以在任何地方任何级别执行，而不是被提升到顶级（优先执行）；</li><li>import() 是运行时执行，也即什么时候运行到这句，就会加载参数指定的模块；参数也可以是动态可变的，不止是静态参数；</li><li>import() 不建立可静态分析的依赖关系（静态分析的情况下可以做很多优化），但是，在一些比较简单的情况下，比如<code>import（“/foo.js”）</code>中，实现仍然可以执行静态分析优化。</li></ul><p>如果模块采用<code>default</code>的形式对外暴露接口，则可用<code>default</code>属性直接获得。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./module.js'</span>)</span><br><span class="line">.then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>.default);<span class="comment">//直接通过default属性获得模块暴露的接口</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>为什么要有<code>Promise.allSettled()</code>？</p><p>举例说明，比如各位用户在页面上面同时填了3个独立的表单，这三个表单分三个接口提交到后端，三个接口独立，没有顺序依赖，这个时候我们需要等到请求全部完成后给与用户提示表单提交的情况。</p><p>在多个<code>promise</code>同时进行时咱们很快会想到使用<code>Promise.all</code>来进行包装，但是由于<code>Promise.all</code>的一票否决的特性，三个提交中若前面任意一个提交失败，则后面的表单也不会进行提交了，这就与咱们需求不符合。</p><p><code>Promise.allSettled</code>跟<code>Promise.all</code>类似，其参数接受一个<code>Promise</code>的数组，返回一个新的<code>Promise</code>，唯一的不同在于，其没有一票否决的特性，也就是说当<code>Promise</code>全部处理完成后我们可以拿到每个<code>Promise</code>的状态，而不管其是否处理成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([<span class="built_in">Promise</span>.resolve(<span class="string">"coffe"</span>), <span class="built_in">Promise</span>.reject(<span class="string">"1891"</span>)]).then(</span><br><span class="line">  arr =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">//&gt;&gt; [ &#123; status: "fulfilled", value: "coffe"&#125;,</span></span><br><span class="line">                      <span class="comment">//&gt;&gt;   &#123; status: "rejected", reason: "1891" &#125; ]</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="本篇结语"><a href="#本篇结语" class="headerlink" title="本篇结语"></a>本篇结语</h2><p>很显然ECMAScript接下来会持续不断地更新，按TC39的计划是每年都会发一个新版本。虽然节奏很快，但是我们完全没必要担心跟不上节奏。除了ES6这个史无前例的版本带来了超大量的新特性外，之后每年发的版本都仅仅带有少量的增量更新，你只需要花45分钟就能搞明白这一年更新的特性。保持一颗好奇的心，你会不断进步，变得更强！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>post</title>
      <link href="/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3-virtual-dom/"/>
      <url>/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3-virtual-dom/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>typeof 实现原理</title>
      <link href="/javascript-typeof/"/>
      <url>/javascript-typeof/</url>
      
        <content type="html"><![CDATA[<p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断 <code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>,<code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 <code>object</code> 类型的数据的时候，<code>typeof</code> 能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code>在判断一个 <code>object</code> 的数据的时候只能告诉我们这个数据是 <code>object</code>, 而不能细致的具体到是哪一种 <code>object</code>, 比如</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">typeof</span> s === <span class="string">"object"</span>; <span class="comment">// true</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要想判断一个数据具体是哪一种 <code>object</code> 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p><p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔</li><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p><pre><code>`null`：所有机器码均为0`undefined`：用 −2^30 整数来表示</code></pre><p>所以，<code>typeof</code> 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。</p><p>然而用 <code>instanceof</code> 来判断的话</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="literal">null</span>; <span class="comment">// TypeError: Right-hand side of 'instanceof' is not an object</span></span><br></pre></td></tr></table></figure><p><code>null</code> 直接被判断为不是 <code>object</code>，这也是 <code>JavaScript</code> 的历史遗留 bug，可以参考 <code>typeof</code>.</p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括 symbol），避免对 <code>null</code> 的判断。</p><p>还有一个不错的判断类型的方法，就是 <code>Object.prototype.toString</code>，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// "[object Number]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">"hi"</span>); <span class="comment">// "[object String]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123; <span class="attr">a</span>: <span class="string">"hi"</span> &#125;); <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>, <span class="string">"a"</span>]); <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>); <span class="comment">// "[object Boolean]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;); <span class="comment">// "[object Function]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// "[object Null]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>); <span class="comment">// "[object Undefined]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>(<span class="number">1</span>)); <span class="comment">// "[object Symbol]"</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> nicole = <span class="keyword">new</span> person();</span><br><span class="line">nicole <span class="keyword">instanceof</span> person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> programmer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">programmer.prototype = <span class="keyword">new</span> person();</span><br><span class="line"><span class="keyword">let</span> nicole = <span class="keyword">new</span> programmer();</span><br><span class="line">nicole <span class="keyword">instanceof</span> person; <span class="comment">// true</span></span><br><span class="line">nicole <span class="keyword">instanceof</span> programmer; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>instanceof 实现原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span>(<span class="params">leftVaule, rightVaule</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = rightVaule.prototype; <span class="comment">// 取右表达式的 prototype 值</span></span><br><span class="line">  leftVaule = leftVaule.__proto__; <span class="comment">// 取左表达式的__proto__值</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftVaule === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    leftVaule = leftVaule.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 JS 关键技术的底层实现汇总</title>
      <link href="/javascript-js-basic-implementation/"/>
      <url>/javascript-js-basic-implementation/</url>
      
        <content type="html"><![CDATA[<p>在这里汇总一些 JS 常用技术的源码实现，通过源码了解其内部原理，可以加深对其的理解。</p><a id="more"></a><ul><li><a href="#functionprototypecall">Function.prototype.call()</a></li><li><a href="#functionprototypeapply">Function.prototype.apply()</a></li><li><a href="#functionprototypebind">Function.prototype.bind()</a></li><li><a href="#new-的原理">new 的原理</a></li><li><a href="#reduce-实现原理">reduce 实现原理</a></li><li><a href="#双向绑定">双向绑定</a></li><li><a href="#继承">继承</a></li><li><a href="#objectcreate">Object.create</a></li><li><a href="#instanceof-实现">instanceof 实现</a></li><li><a href="#arrayisarray-实现">Array.isArray 实现</a></li><li><a href="#getownpropertynames-实现">getOwnPropertyNames 实现</a></li><li><a href="#promise-实现">Promise 实现</a></li><li><a href="#防抖节流">防抖/节流</a></li><li><a href="#函数柯里化实现">函数柯里化实现</a></li><li><a href="#实现简单深拷贝">实现简单深拷贝</a></li></ul><!-- # 一些 JS 关键技术的底层实现汇总 --><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数。</p><p>语法：<code>fun.call(thisArg, arg1, arg2, ...)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * call的实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mcall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : getGlobal();</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">"anything"</span>); <span class="comment">//创建一个不重复的常量</span></span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> r = context[fn](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个用call实现继承的例子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">name</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">price</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  Product.mcall(<span class="keyword">this</span>, name, price);</span><br><span class="line">  <span class="keyword">this</span>.category = <span class="string">"fruit"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> Fruit(<span class="string">"apple"</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(apple);</span><br></pre></td></tr></table></figure><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2><p><code>apply()</code>调用一个指定 this 值的函数, 接收作为一个数组或者类数组对象提供的参数.</p><p>语法： <code>func.apply(thisArg, [argsArray])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * apply原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : getGlobal();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"context"</span>, context);</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">"anything"</span>); <span class="comment">//创建一个不重复的常量</span></span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// let args = [...arguments][1];</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = context[fn]();</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> r = context[fn](...arr);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用例子</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>];</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">array.push.apply(array, elements);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array"</span>, array); <span class="comment">// ["a", "b", 0, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b + <span class="string">" "</span> + x + <span class="string">" "</span> + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">A.apply(B, [<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2><p><code>bind()</code>方法创建一个新函数, 在调用时设置 this 关键字为提供的值。</p><p>语法：<code>fun.bind(thisArg, arg1, arg2, ...)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bind实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context ? <span class="built_in">Object</span>(context) : getGlobal();</span><br><span class="line">  <span class="keyword">const</span> me = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    me.apply(context, [...args, ...arguments]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b + <span class="string">", "</span> + x + <span class="string">", "</span> + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> fnc = A.bind(B, <span class="number">2</span>); <span class="comment">//1 2 3</span></span><br><span class="line">fnc(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="new-的原理"><a href="#new-的原理" class="headerlink" title="new 的原理"></a>new 的原理</h2><p>在了解 new 原理之前先看看 js 的内部机制图</p><p><img src="https://user-gold-cdn.xitu.io/2019/3/14/1697cc831ea2af8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="js内部机制"></p><pre><code>我们需要知道当 new 的时候做了什么事情</code></pre><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象。</li></ol><p>new 没法重写，这里是有 mockNew 函数来模拟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个实例</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">//获得构造器</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">constructor</span> = [].shift.call(arguments);</span><br><span class="line">  //实现继承，实例可以访问构造器熟悉</span><br><span class="line">  obj.__proto__ = <span class="keyword">constructor</span>.prototype;</span><br><span class="line">  //调用构造器，改变this指向为实例</span><br><span class="line">  const res = <span class="keyword">constructor</span>.apply(obj, arguments);</span><br><span class="line">  //如果构造器函数返回值为对象，则返回这个对象，否则返回新的实例对象</span><br><span class="line">  return res instanceof Object ? res : obj;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 使用例子</span><br><span class="line"> * @param &#123;*&#125; color</span><br><span class="line"> * @param &#123;*&#125; name</span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">function Car(color, name) &#123;</span></span><br><span class="line"><span class="regexp">  this.color = color;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    name: name,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let car = mockNew(Car, "black", "BMW");</span></span><br><span class="line"><span class="regexp">console.log(car.color);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ undefined</span></span><br><span class="line"><span class="regexp">console.log(car.name);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ "BMW"</span></span><br></pre></td></tr></table></figure><h2 id="reduce-实现原理"><a href="#reduce-实现原理" class="headerlink" title="reduce 实现原理"></a>reduce 实现原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.mockReduce = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">let</span> reducer = <span class="literal">undefined</span>, <span class="comment">//累加器，最终返回这个值</span></span><br><span class="line">    k = <span class="number">0</span>, <span class="comment">//数组下标</span></span><br><span class="line">    initVal = [...arguments].length &gt; <span class="number">1</span> ? [...arguments][<span class="number">1</span>] : <span class="literal">undefined</span>; <span class="comment">//传入reduce的初始值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">" is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span> &amp;&amp; !initVal) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Reduce of empty array with no initial value"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (initVal) &#123;</span><br><span class="line">    reducer = initVal;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reducer = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="keyword">const</span> kValue = <span class="keyword">this</span>[k];</span><br><span class="line">      reducer = callback(reducer, kValue);</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reducer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rReduce = [].reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> mReduce = [].mockReduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rReduce, mReduce);</span><br></pre></td></tr></table></figure><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p><code>defineProperty</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">"hello"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">"text"</span>, &#123;</span><br><span class="line">  <span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">  <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">    input.value = newVal;</span><br><span class="line">    p.innerHTML = newVal;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  data.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>proxy</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">"default"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="comment">// 数据变化 --&gt; 修改视图</span></span><br><span class="line">    input.value = value;</span><br><span class="line">    p.innerHTML = value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  proxy.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> protoType = <span class="built_in">Object</span>.create(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  protoType.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = protoType; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">"Bob"</span>, <span class="number">18</span>);</span><br><span class="line">instance.sayName();</span><br><span class="line">instance.sayAge();</span><br></pre></td></tr></table></figure><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">prototype, properties</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prototype !== <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Ctor</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    Ctor.prototype = prototype;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> Ctor();</span><br><span class="line">    <span class="keyword">if</span> (prototype) &#123;</span><br><span class="line">      o.constructor = Ctor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (properties !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (properties !== <span class="built_in">Object</span>(properties)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperties(o, properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="instanceof-实现"><a href="#instanceof-实现" class="headerlink" title="instanceof 实现"></a>instanceof 实现</h2><p>原理： L 的 __proto__ 是不是等于 R.prototype，不等于再找 L.__proto__.__proto__ 直到 __proto__ 为 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L 表示左表达式，R 表示右表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> O = R.prototype;</span><br><span class="line">  L = L.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (O === L) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    L = L.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-isArray-实现"><a href="#Array-isArray-实现" class="headerlink" title="Array.isArray 实现"></a>Array.isArray 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>(o)) === <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.myIsArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="getOwnPropertyNames-实现"><a href="#getOwnPropertyNames-实现" class="headerlink" title="getOwnPropertyNames 实现"></a>getOwnPropertyNames 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.getOwnPropertyNames !== <span class="string">"function"</span>) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o !== <span class="built_in">Object</span>(o)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">"Object.getOwnPropertyNames called on non-object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> props = [],</span><br><span class="line">      p;</span><br><span class="line">    <span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(o, p)) &#123;</span><br><span class="line">        props.push(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h2><p>实现原理：其实就是一个发布订阅者模式</p><ol><li>构造函数接收一个 executor 函数，并会在 new Promise() 时立即执行该函数</li><li>then 时收集依赖，将回调函数收集到 成功/失败队列</li><li>executor 函数中调用 resolve/reject 函数</li><li>resolve/reject 函数被调用时会通知触发队列中的回调</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数，new 时触发</span></span><br><span class="line">  <span class="keyword">constructor</span>(handle: Function) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>._resolve, <span class="keyword">this</span>._reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 状态 pending fulfilled rejected</span></span><br><span class="line">  private _status: string = PENDING;</span><br><span class="line">  <span class="comment">// 储存 value，用于 then 返回</span></span><br><span class="line">  private _value: string | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 失败队列，在 then 时注入，resolve 时触发</span></span><br><span class="line">  private _rejectedQueues: any = [];</span><br><span class="line">  <span class="comment">// 成功队列，在 then 时注入，resolve 时触发</span></span><br><span class="line">  private _fulfilledQueues: any = [];</span><br><span class="line">  <span class="comment">// resovle 时执行的函数</span></span><br><span class="line">  private _resolve = <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">      <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._fulfilledQueues.shift())) &#123;</span><br><span class="line">          cb(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runRejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 如果resolve的参数为Promise对象，</span></span><br><span class="line"><span class="comment">       * 则必须等待该Promise对象状态改变后当前Promsie的状态才会改变</span></span><br><span class="line"><span class="comment">       * 且状态取决于参数Promsie对象的状态</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        val.then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = value;</span><br><span class="line">            runFulfilled(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = err;</span><br><span class="line">            runRejected(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = val;</span><br><span class="line">        runFulfilled(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 异步调用</span></span><br><span class="line">    setTimeout(run);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// reject 时执行的函数</span></span><br><span class="line">  private _reject = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">      <span class="keyword">this</span>._value = err;</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">        cb(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// then 方法</span></span><br><span class="line">  then(onFulfilled?, onRejected?) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">      <span class="keyword">const</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">            onFulfilledNext(value);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = onFulfilled(value);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">      <span class="keyword">const</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">            onRejectedNext(error);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._fulfilledQueues.push(fulfilled);</span><br><span class="line">          <span class="keyword">this</span>._rejectedQueues.push(rejected);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilled(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejected(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// catch 方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// finally 方法</span></span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      value =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      reason =&gt;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态 resolve 方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态 reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 静态 all 方法</span></span><br><span class="line">  <span class="keyword">static</span> all(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 返回值的集合</span></span><br><span class="line">      <span class="keyword">let</span> values = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [i, p] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">        <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            values[i] = res;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态race方法</span></span><br><span class="line">  <span class="keyword">static</span> race(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h2><pre><code>防抖函数 onscroll 结束时触发一次，延迟执行</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout);</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      callback.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"debounce"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><pre><code>节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span> (curTime - prevTime &gt; delay) &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      prevTime = curTime;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"throtte"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="函数柯里化实现"><a href="#函数柯里化实现" class="headerlink" title="函数柯里化实现"></a>函数柯里化实现</h2><pre><code>其实我们无时无刻不在使用柯里化函数，只是没有将它总结出来而已。它的本质就是将一个参数很多的函数分解成单一参数的多个函数。</code></pre><p>应用场景：</p><ul><li>延迟计算 （用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数）</li><li>动态创建函数 （参数不够时会返回接受剩下参数的函数）</li><li>参数复用（每个参数可以多次复用）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span></span><br><span class="line">  (judge = <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    args.length &gt;= fn.length</span><br><span class="line">      ? fn(...args)</span><br><span class="line">      : <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> a + b + c + d;</span><br><span class="line"><span class="keyword">const</span> currySum = curry(sum);</span><br><span class="line"></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br><span class="line">currySum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br><span class="line">currySum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="实现简单深拷贝"><a href="#实现简单深拷贝" class="headerlink" title="实现简单深拷贝"></a>实现简单深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">Object</span>.prototype.toString.call(obj);</span><br><span class="line">  <span class="keyword">const</span> map = &#123;</span><br><span class="line">    <span class="string">"[object Boolean]"</span>: <span class="string">"boolean"</span>,</span><br><span class="line">    <span class="string">"[object Number]"</span>: <span class="string">"number"</span>,</span><br><span class="line">    <span class="string">"[object String]"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="string">"[object Function]"</span>: <span class="string">"function"</span>,</span><br><span class="line">    <span class="string">"[object Array]"</span>: <span class="string">"array"</span>,</span><br><span class="line">    <span class="string">"[object Date]"</span>: <span class="string">"date"</span>,</span><br><span class="line">    <span class="string">"[object RegExp]"</span>: <span class="string">"regExp"</span>,</span><br><span class="line">    <span class="string">"[object Undefined]"</span>: <span class="string">"undefined"</span>,</span><br><span class="line">    <span class="string">"[object Null]"</span>: <span class="string">"null"</span>,</span><br><span class="line">    <span class="string">"[object Object]"</span>: <span class="string">"object"</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">    <span class="comment">// 判断是否是dom元素，如div等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"element"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map[str];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = getType(original);</span><br><span class="line">  <span class="keyword">let</span> copy;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"array"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyArray(original, copy);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"object"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyObject(original, copy);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"function"</span>:</span><br><span class="line">      <span class="keyword">return</span> copyFunction(original, copy);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> original;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArray</span>(<span class="params">original, copy = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> original.entries()) &#123;</span><br><span class="line">    copy[index] = deepCopy(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObject</span>(<span class="params">original, copy = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(original)) &#123;</span><br><span class="line">    copy[key] = deepCopy(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyFunction</span>(<span class="params">original, copy = (</span>) =&gt; </span>&#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">eval</span>(original.toString());</span><br><span class="line">  fn.prototype = original.prototype;</span><br><span class="line">  <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], &#123; <span class="attr">i</span>: <span class="number">6</span>, <span class="attr">j</span>: <span class="number">6</span> &#125;, (k, m) =&gt; k + m];</span><br><span class="line"><span class="built_in">console</span>.log(deepCopy(arr1));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循序渐进数据结构与算法 - 线性表</title>
      <link href="/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/"/>
      <url>/algorithms-%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>数据结构和算法是编程的内功，深厚的内功可以有效保障写出的代码性能良好，可以提前预估代码运行达到预期目的，提高工作产出，也能让学习其他编程语言和框架变得事半功倍。</p><p>本系列所有示例均采用JavaScript，旨在入门数据结构与算法。</p><p>本节主要是讲解下基础数据结构 - 线性表 相关的内容。</p><a id="more"></a><h3 id="线性表-与-非线性表"><a href="#线性表-与-非线性表" class="headerlink" title="线性表 与 非线性表"></a>线性表 与 非线性表</h3><p>线性表（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是典型线性表结构。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhenoep0wj30yg0pb76e.jpg" alt=""></p><p>非线性表：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfheoebis1j30yg0p0gn2.jpg" alt=""></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>定义<br>数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。<br>数组的索引是从 0 开始的。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfkg30mej30em0fymxv.jpg" alt=""></p><ul><li>特点<br>数组是用一组连续的内存空间来存储的。 所以数组支持 随机访问，根据下标随机访问的时间复杂度为 O(1)。</li></ul><p>低效的插入和删除。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)</p><ul><li>实现<br>JavaScript 原生支持数组，而且提供了很多操作方法，JavaScript数组支持的方法可见下表：</li></ul><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">concat()</td><td align="left">连接两个或更多的数组，并返回结果。</td></tr><tr><td align="left">copyWithin()</td><td align="left">从数组的指定位置拷贝元素到数组的另一个指定位置中。</td></tr><tr><td align="left">entries()</td><td align="left">返回数组的可迭代对象。</td></tr><tr><td align="left">every()</td><td align="left">检测数值元素的每个元素是否都符合条件。</td></tr><tr><td align="left">fill()</td><td align="left">使用一个固定值来填充数组。</td></tr><tr><td align="left">filter()</td><td align="left">检测数值元素，并返回符合条件所有元素的数组。</td></tr><tr><td align="left">find()</td><td align="left">返回符合传入测试（函数）条件的数组元素。</td></tr><tr><td align="left">findIndex()</td><td align="left">返回符合传入测试（函数）条件的数组元素索引。</td></tr><tr><td align="left">forEach()</td><td align="left">数组每个元素都执行一次回调函数。</td></tr><tr><td align="left">from()</td><td align="left">通过给定的对象中创建一个数组。</td></tr><tr><td align="left">includes()</td><td align="left">判断一个数组是否包含一个指定的值。</td></tr><tr><td align="left">indexOf()</td><td align="left">搜索数组中的元素，并返回它所在的位置。</td></tr><tr><td align="left">isArray()</td><td align="left">判断对象是否为数组。</td></tr><tr><td align="left">join()</td><td align="left">把数组的所有元素放入一个字符串。</td></tr><tr><td align="left">keys()</td><td align="left">返回数组的可迭代对象，包含原始数组的键(key)。</td></tr><tr><td align="left">lastIndexOf()</td><td align="left">搜索数组中的元素，并返回它最后出现的位置。</td></tr><tr><td align="left">map()</td><td align="left">通过指定函数处理数组的每个元素，并返回处理后的数组。</td></tr><tr><td align="left">pop()</td><td align="left">删除数组的最后一个元素并返回删除的元素。</td></tr><tr><td align="left">push()</td><td align="left">向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="left">reduce()</td><td align="left">将数组元素计算为一个值（从左到右）。</td></tr><tr><td align="left">reduceRight()</td><td align="left">将数组元素计算为一个值（从右到左）。</td></tr><tr><td align="left">reverse()</td><td align="left">反转数组的元素顺序。</td></tr><tr><td align="left">shift()</td><td align="left">删除并返回数组的第一个元素。</td></tr><tr><td align="left">slice()</td><td align="left">选取数组的的一部分，并返回一个新数组。</td></tr><tr><td align="left">some()</td><td align="left">检测数组元素中是否有元素符合指定条件。</td></tr><tr><td align="left">sort()</td><td align="left">对数组的元素进行排序。</td></tr><tr><td align="left">splice()</td><td align="left">从数组中添加或删除元素。</td></tr><tr><td align="left">toString()</td><td align="left">把数组转换为字符串，并返回结果。</td></tr><tr><td align="left">unshift()</td><td align="left">向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="left">valueOf()</td><td align="left">返回数组对象的原始值。</td></tr></tbody></table><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>定义<ul><li>后进者先出，先进者后出，简称 后进先出（LIFO），这就是典型的栈结构。</li><li>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li><li>从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。</li><li>不包含任何元素的栈称为空栈。</li></ul></li></ul><p>栈被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈、前端路由等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhfvwdizbj30lc0i43zg.jpg" alt=""></p><ul><li>实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加一个（或几个）新元素到栈顶。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(element);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除栈顶的元素，同时返回被移除的元素。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.pop();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回栈顶的元素，不对栈做任何修改。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="keyword">this</span>.data.length - <span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果栈里没有任何元素就返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除栈里的所有元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回栈里的元素个数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 打印栈里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景</li></ul><p>举一个判断回文的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">    s.push(word[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> rword = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rword += s.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> word == rword;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"level"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"1001"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"word"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>定义<ul><li>队列是遵循 FIFO（First In First Out，先进先出）原则的一组有序的项。</li><li>队列在尾部添加新元素，并从顶部移除元素。</li><li>最新添加的元素必须排在队列的末尾。</li><li>队列只有 入队 push() 和出队 pop()。</li><li>队列又可以细分为普通队列、优先队列、循环队列。</li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfhg3y5rzfj30pw0ck74z.jpg" alt=""></p><h4 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h4><ul><li>实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Queue类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向队列尾部添加元素</span></span><br><span class="line">  <span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(element);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除队列的第一个元素，并返回被移除的元素</span></span><br><span class="line">  <span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列的第一个元素</span></span><br><span class="line">  <span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[<span class="number">0</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为空队列</span></span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length === <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取队列的长度</span></span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.length;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空队列</span></span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = [];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印队列里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.toString());</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景</li></ul><p>击鼓传花游戏的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 实现击鼓传花</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">    queue.enqueue(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环 num 次，队首出来去到队尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.enqueue(queue.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环 num 次过后，移除当前队首的元素</span></span><br><span class="line">    eliminated = queue.dequeue();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;eliminated&#125;</span> 在击鼓传花中被淘汰！`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后只剩一个元素</span></span><br><span class="line">  <span class="keyword">return</span> queue.dequeue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> nameList = [<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"马六"</span>, <span class="string">"牛七"</span>];</span><br><span class="line"><span class="keyword">var</span> winner = hotPotato(nameList, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`最后的胜利者是：<span class="subst">$&#123;winner&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; 牛七 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 张三 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 王五 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 马六 在击鼓传花中被淘汰！</span></span><br><span class="line"><span class="comment">// =&gt; 最后的胜利者是：李四</span></span><br></pre></td></tr></table></figure><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><ul><li><p>定义<br>优先队列中元素的添加和移除会根据<code>优先级</code>来处理</p></li><li><p>场景<br>优先队列一个典型的场景就是机场登机，头等舱和商务舱乘客的优先级要高于经济舱乘客。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> zhan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise高级用法</title>
      <link href="/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/javascript-promise%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="实现多个promise串行执行"><a href="#实现多个promise串行执行" class="headerlink" title="实现多个promise串行执行"></a>实现多个promise串行执行</h2><p>在 async/await 以前 Promise 串行执行还是比较麻烦的，除了依赖 <a href="https://github.com/caolan/async" target="_blank" rel="noopener">async</a>、<a href="https://github.com/sindresorhus/promise-fun" target="_blank" rel="noopener">promise-fun</a> 等工具库，我们还可以使用 Array.prototype.reduce() 自己实现一个简单的串行Promise了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心代码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runPromiseByQueue</span>(<span class="params">myPromises</span>) </span>&#123;</span><br><span class="line">  myPromises.reduce(</span><br><span class="line">    (previousPromise, nextPromise) =&gt; previousPromise.then(<span class="function"><span class="params">()</span> =&gt;</span> nextPromise()),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上一个 Promise 开始执行（previousPromise.then），当其执行完毕后再调用下一个 Promise，并作为一个新 Promise 返回，下次迭代就会继续这个循环。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createPromise = <span class="function">(<span class="params">time, id</span>) =&gt;</span> <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">solve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"time"</span> + id);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"promise"</span>, id);</span><br><span class="line">      <span class="built_in">console</span>.timeEnd(<span class="string">"time"</span> + id);</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">"timeall"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      solve();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"timeall"</span>);</span><br><span class="line">runPromiseByQueue([</span><br><span class="line">  createPromise(<span class="number">3000</span>, <span class="number">1</span>),</span><br><span class="line">  createPromise(<span class="number">2000</span>, <span class="number">2</span>),</span><br><span class="line">  createPromise(<span class="number">1000</span>, <span class="number">3</span>),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>最后的输出结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfexoo9xmvj307702yt8p.jpg" alt=""></p><p>说明确实是串行依次执行了三个promise。</p><h2 id="实现多个promise并行执行"><a href="#实现多个promise并行执行" class="headerlink" title="实现多个promise并行执行"></a>实现多个promise并行执行</h2><p>这个目前ES官方已经实现了promise.all/promise.allSettled/promise.race等方法，以promise.all()为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'foo'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: Array [3, 42, "foo"]</span></span><br></pre></td></tr></table></figure><p><code>Promise.all</code>可以保证，<code>promises</code>数组中所有promise对象都达到<code>resolve</code>状态，才执行<code>then</code>回调。</p><p>那么如果<code>promises</code>数组是包含几十个甚至几百个http请求，直接用<code>Promise.all</code>的话，会瞬间发出所有的http请求，造成请求拥堵甚至失败。</p><p>这时候就需要对<code>Promise.all</code>做并发限制。</p><h2 id="promise-all并行限制"><a href="#promise-all并行限制" class="headerlink" title="promise.all并行限制"></a>promise.all并行限制</h2><p>首先需要明白的是，promise并不是在调用Promise.all才执行，而是在实例化promise对象的时候就执行了，在理解这一点的基础上，就可以从promise实例化上下手实现并发限制。具体实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise并发限制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">array</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">poolLimit</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LimitPromiseAll</span>(<span class="params">array, poolLimit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">//待执行元素的数组下标</span></span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// promise.all的promises数组</span></span><br><span class="line">  <span class="keyword">const</span> executing = []; <span class="comment">// 存放正在执行</span></span><br><span class="line">  <span class="keyword">const</span> enqueue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 边界处理，array为空数组</span></span><br><span class="line">    <span class="keyword">if</span> (i === array.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每调一次enqueue，初始化一个promise</span></span><br><span class="line">    <span class="keyword">const</span> fn = array[i++];</span><br><span class="line">    <span class="comment">// 如果curPromise不是Promise对象。则转成Promise 对象</span></span><br><span class="line">    <span class="comment">// 等同于 const p = Promise.resolve(fn());</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> fn());</span><br><span class="line">    <span class="comment">// 放入promises数组</span></span><br><span class="line">    results.push(p);</span><br><span class="line">    <span class="comment">// promise执行完毕，从executing数组中删除</span></span><br><span class="line">    <span class="keyword">const</span> e = p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      executing.splice(executing.indexOf(e), <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//正在执行的promise, 插入executing数组</span></span><br><span class="line">    executing.push(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当executing数组中promise数量低于poolLimit，就实例化新的promise并执行,</span></span><br><span class="line">    <span class="comment">// 否则调用promise.race()获取到最快执行完成的promise（将其从executing数组删除，便可继续后续执行）</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">if</span> (executing.length &gt;= poolLimit) &#123;</span><br><span class="line">      r = <span class="built_in">Promise</span>.race(executing);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归，直到遍历完array</span></span><br><span class="line">    <span class="keyword">return</span> r.then(<span class="function"><span class="params">()</span> =&gt;</span> enqueue());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enqueue().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.all(results));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"all-time"</span>);</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">i</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(i), i));</span><br><span class="line"></span><br><span class="line">LimitPromiseAll(</span><br><span class="line">  [</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">1000</span>),</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">5000</span>),</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">2000</span>),</span><br><span class="line">    timeout.bind(<span class="literal">null</span>, <span class="number">4000</span>),</span><br><span class="line">  ],</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">"all-time"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出： [ 1000, 5000, 2000, 4000 ]</span></span><br><span class="line"><span class="comment">      all-time: 7037.285ms</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><p>其实，目前社区里已经有一些开源包实现了这个功能，比如<a href="https://github.com/rxaviers/async-pool" target="_blank" rel="noopener">async-pool</a>、<a href="https://github.com/timdp/es6-promise-pool" target="_blank" rel="noopener">es6-promise-pool</a>、<a href="https://github.com/sindresorhus/p-limit" target="_blank" rel="noopener">p-limit</a>。上述实现代码也是参考async-pool的实现。</p><h2 id="使用Promise实现fetch超时处理"><a href="#使用Promise实现fetch超时处理" class="headerlink" title="使用Promise实现fetch超时处理"></a>使用Promise实现fetch超时处理</h2><p>因为<code>fetch</code>默认没有请求超时设置，以及中断请求操作，在这里我们尝试使用<code>Promise</code>结合<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FetchController" target="_blank" rel="noopener">AbortController</a>封装一个简单的请求超时和中断请求的<code>fetch</code>。</p><blockquote><p>AbortController接口代表一个控制器对象，允许你在需要时中止一个或多个DOM请求<br>目前IE外的主流浏览器基本都实现了AbortController功能；</p></blockquote><p>AbortController的浏览器兼容情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfg4gbzyt9j30s70c5tax.jpg" alt=""></p><p>核心代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutFetch</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.controller = <span class="keyword">new</span> AbortController(); <span class="comment">//实例化AbortController</span></span><br><span class="line">  <span class="keyword">this</span>.signal = <span class="keyword">this</span>.controller.signal; <span class="comment">//signal用来 abort 请求</span></span><br><span class="line">  <span class="keyword">this</span>.timeout = <span class="number">5000</span>; <span class="comment">//默认超时时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimeoutFetch.prototype.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.timeout = ms;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装fetch请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimeoutFetch.prototype.fetch = <span class="function"><span class="keyword">function</span> (<span class="params">url, data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timeoutPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        code: <span class="number">1</span>,</span><br><span class="line">        msg: <span class="string">`timeout of <span class="subst">$&#123;<span class="keyword">this</span>.timeout&#125;</span>ms`</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.controller.abort();</span><br><span class="line">    &#125;, <span class="keyword">this</span>.timeout);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> fetchPromise = fetch(url, &#123;</span><br><span class="line">    signal: <span class="keyword">this</span>.signal, <span class="comment">//设置信号</span></span><br><span class="line">    ...data,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([fetchPromise, timeoutPromise]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手动中断请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimeoutFetch.prototype.abort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.controller.abort();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeoutFetch = <span class="keyword">new</span> TimeoutFetch();</span><br><span class="line">timeoutFetch.setTimeout(<span class="number">30</span>);</span><br><span class="line">timeoutFetch.fetch(<span class="string">"http://localhost/data"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过iframe下载文件如何判断下载完成</title>
      <link href="/javascript-iframe-download-complete/"/>
      <url>/javascript-iframe-download-complete/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当使用 iframe 作为文件下载的载体时，如何知道文件已经下载完毕。现有的 iframe 的 onLoad 方法具有兼容性问题，在 chrome、IE 下无法监听 onLoad 事件监听文件下载完毕，因为 onLoad 事件本身也是对 iframe 中的 html 结构的加载进度监听。</p><!-- more --><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">"http://www.example.com/file.zip"</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span><br><span class="line">iframe.src = url;</span><br><span class="line">iframe.style.display = <span class="string">"none"</span>;</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">"start downloading..."</span>);</span><br><span class="line">  <span class="built_in">document</span>.body.removeAttribute(iframe);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br></pre></td></tr></table></figure><p>当 chrome、IE 下时，如果 HTTP 文件头中包含 Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件 onLoad 事件。</p><p>这里说一下 Content-disposition：</p><p><code>Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。 Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示 注意事项： 1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;);一定要确保没有做过关于禁止浏览器缓存的操作。 代码如下: response.setHeader(&#39;Pragma&#39;, &#39;No-cache&#39;); response.setHeader(&#39;Cache-Control&#39;, &#39;No-cache&#39;); response.setDateHeader(&#39;Expires&#39;, 0); 不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行</code></p><h3 id="解决思路一：利用-cookie"><a href="#解决思路一：利用-cookie" class="headerlink" title="解决思路一：利用 cookie"></a>解决思路一：利用 cookie</h3><p>后端将文件下载进度放在 cookie 中，通过轮询 cookie 的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。 缺陷： 1、需要后端配合 2、如果客户端禁用了 cookie，则该方案完全失效；在无痕浏览模式下，读取 cookie，甚至代码报错。</p><h3 id="解决思路二：添加-header-配置"><a href="#解决思路二：添加-header-配置" class="headerlink" title="解决思路二：添加 header 配置"></a>解决思路二：添加 header 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不让浏览器自动检测文件类型</span></span><br><span class="line"><span class="comment">// 说明资料：http://drops.wooyun.org/tips/1166</span></span><br><span class="line">response.addHeader(<span class="string">"X-Content-Type-Options"</span>, <span class="string">"nosniff"</span>);</span><br><span class="line"><span class="comment">// 提示浏览器不让其在frame或iframe中加载资源的文件内容</span></span><br><span class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</span></span><br><span class="line">response.addHeader(<span class="string">"X-Frame-Options"</span>, <span class="string">"deny"</span>);</span><br></pre></td></tr></table></figure><p>但是在 chorome v58 版本将 header 的 X-Frame-Options 设为 deny 会报错。并且下载的时候网络连接会出现失败。</p><h3 id="解决思路三：轮询监听-readyState"><a href="#解决思路三：轮询监听-readyState" class="headerlink" title="解决思路三：轮询监听 readyState"></a>解决思路三：轮询监听 readyState</h3><p>定时器轮询监听 readyState 的状态，如果是 complete 或者 interactive 说明文件加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframedownload"</span>);</span><br><span class="line">  <span class="keyword">var</span> iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">  <span class="comment">// Check if loading is complete</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    iframeDoc.readyState == <span class="string">"complete"</span> ||</span><br><span class="line">    iframeDoc.readyState == <span class="string">"interactive"</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    loadingOff();</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第三种方法比较好，因为不需要后端进行配合，且不依赖与 cookie 等变量带来的问题，能更好实现我们的需求。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iframe </tag>
            
            <tag> download </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx初试</title>
      <link href="/others-nginx-basic/"/>
      <url>/others-nginx-basic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>“Nginx 是一款轻量级的 HTTP 服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的 IO 性能，时常用于服务端的反向代理和负载均衡。”</p></blockquote><p>作为前端开发，即使没用过 Nginx，但一定听说过 Nginx。上述这段描述，基本构成了所有人对 Nginx 的第一印象。笔者对于 Nginx 也是慕名已久，直到现在才开始试尝这道大餐，本文是记录笔者学习并使用 Nginx 的过程，通过此文可以简单入门并搭建一套 Nginx 服务。</p> <a id="more"></a><h3 id="一、初试-Nginx"><a href="#一、初试-Nginx" class="headerlink" title="一、初试 Nginx"></a>一、初试 Nginx</h3><p>想要成为一个合格的大前端，又怎能不会 Nginx 呢？</p><p>Nginx 从 2004 年发展至今，从一开始的完善沉淀，再迅速蹿升为“网红”，再到现在占服务器市场中接近 1/3 份额，成为互联网网站搭建的必选技术之一。发展可谓相当迅速，之所以能取得如此成就，主要还是相对于其他 HTTP 服务器其有着不可替代的优势：</p><ul><li>支持海量高并发：采用 IO 多路复用 epoll。官方测试 Nginx 能够支持 5 万并发链接，实际生产环境中可以支撑 2-4 万并发连接数。</li><li>内存消耗少：在主流的服务器中 Nginx 目前是内存消耗最小的了，比如我们用 Nginx+PHP，在 3 万并发链接下，开启 10 个 Nginx 进程消耗 150M 内存。</li><li>免费使用可以商业化：Nginx 为开源软件，采用的是 2-clause BSD-like 协议，可以免费使用，并且可以用于商业。</li><li>配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。</li></ul><p>而对于前端童鞋，在实际工作上，更倾向于用 Nodejs 来搭建服务器，进而实现一些需求，对 Nginx 有天然的疏远感。的确，Nginx 中的绝大部分功能，如果单纯的使用 Node.js 也可以满足和实现。但实际上，Nginx 和 Node.js 并不冲突，都有自己擅长的领域：Nginx 更擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长于上层具体业务逻辑的处理。如果将两者组合一起，则可以更加助力前端开发。</p><p>开始动手之前先交代下具体的系统环境：</p><blockquote><p>系统环境说明：<br>服务器：阿里云 ECS<br>操作系统： CentOS 7.4 64 位<br>Nginx 版本：nginx/1.16.1</p></blockquote><h3 id="二、Nginx-的安装"><a href="#二、Nginx-的安装" class="headerlink" title="二、Nginx 的安装"></a>二、Nginx 的安装</h3><p>首先可以查看下系统的 yum 源下是否有可用的 Nginx 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list | grep nginx</span><br></pre></td></tr></table></figure><p>如果结果类似如图内容，说明 yum 源是存在的<br><img src="http://yanxuan.nosdn.127.net/a46cc75592cd4639abc0dd6f64b5cbff.png" alt="UTOOLS1590462877021.png"></p><p>如果不存在或者没有需要的 Nginx 版本，则可以自己配一个 yum 源。</p><p>打开终端，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>往里面添加如下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/<span class="variable">$&#123;OS&#125;</span>/<span class="variable">$&#123;OSRELEASE&#125;</span>/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure><blockquote><p>需要注意：<br>OS: 操作系统名称，如：centos<br>OSRELEASE: 操作系统版本，如： 7<br>对应的 baseurl: baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/$basearch/</a></p></blockquote><p>保存修改后，就可以安装 Nginx 了，安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>安装完成后查看安装的 Nginx 版本:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure><h3 id="三、Nginx-基本配置"><a href="#三、Nginx-基本配置" class="headerlink" title="三、Nginx 基本配置"></a>三、Nginx 基本配置</h3><p>安装完 Nginx 后，需要知道系统中多了那些文件，它们都安装到了那里。可以使用下面的命令进行查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql nginx</span><br></pre></td></tr></table></figure><p>rpm 是 linux 的 rpm 包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到 nginx 的所有安装位置了。</p><p>下面重点罗列下一些重要的文件</p><p><strong>nginx.conf</strong></p><p>nginx.conf 文件是 Nginx 总配置文件，在我们搭建服务器时经常调整的文件。</p><p>进入 etc/nginx 目录下，然后用 vim 进行打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>下面是文件的详细注释:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行用户，默认即是nginx，可以不进行设置</span></span><br><span class="line">user  nginx;</span><br><span class="line"><span class="comment">#Nginx进程，一般设置为和CPU核数一样</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"><span class="comment">#错误日志存放目录</span></span><br><span class="line">error_log  /var/<span class="built_in">log</span>/nginx/error.log warn;</span><br><span class="line"><span class="comment">#进程pid存放位置</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024; <span class="comment"># 单个后台进程的最大并发数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;   <span class="comment">#文件扩展名与类型映射表</span></span><br><span class="line">    default_type  application/octet-stream;  <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#设置日志模式</span></span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;   <span class="comment">#nginx访问日志存放位置</span></span><br><span class="line"></span><br><span class="line">    sendfile        on;   <span class="comment">#开启高效传输模式</span></span><br><span class="line">    <span class="comment">#tcp_nopush     on;    #减少网络报文段的数量</span></span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;  <span class="comment">#保持连接的时间，也叫超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;  #开启gzip压缩</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf; <span class="comment">#包含的子配置项位置和文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>default.conf</strong><br>进入 conf.d 目录，打开 default.conf，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;   <span class="comment">#配置监听端口</span></span><br><span class="line">    server_name  localhost;  //配置域名</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;     <span class="comment">#服务默认启动目录</span></span><br><span class="line">        index  index.html index.htm;    <span class="comment">#默认访问文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;   # 配置404页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    error_page   500 502 503 504  /50x.html;   <span class="comment">#错误状态码的显示页面，配置后需要重启</span></span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、Nginx-常用操作"><a href="#四、Nginx-常用操作" class="headerlink" title="四、Nginx 常用操作"></a>四、Nginx 常用操作</h3><h4 id="启动-Nginx-服务"><a href="#启动-Nginx-服务" class="headerlink" title="启动 Nginx 服务"></a>启动 Nginx 服务</h4><ul><li>Nginx 直接启动（CentOS7.4 以上版本）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><ul><li>使用 systemctl 命令启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><ul><li>查看服务运行状态</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure><p><img src="http://yanxuan.nosdn.127.net/98dfae9ae9ddbe95796aa142053b583a.png" alt="UTOOLS1590464174436.png"></p><h4 id="关停-Nginx-服务"><a href="#关停-Nginx-服务" class="headerlink" title="关停 Nginx 服务"></a>关停 Nginx 服务</h4><ul><li>立即停止服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx  -s stop</span><br></pre></td></tr></table></figure><p>这种方法比较强硬，无论进程是否在工作，都直接停止进程。</p><ul><li>从容停止服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><p>这种方法较 stop 相比就比较温和一些了，需要进程完成当前工作后再停止。</p><ul><li>killall 方法杀死进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall nginx</span><br></pre></td></tr></table></figure><p>这种方法也是比较野蛮的，直接杀死进程。</p><ul><li>systemctl 停止</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop nginx.service</span><br></pre></td></tr></table></figure><h4 id="重启-Nginx-服务"><a href="#重启-Nginx-服务" class="headerlink" title="重启 Nginx 服务"></a>重启 Nginx 服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><h4 id="重新载入配置文件"><a href="#重新载入配置文件" class="headerlink" title="重新载入配置文件"></a>重新载入配置文件</h4><p>在重新编写或者修改 Nginx 的配置文件后，需要作一下重新载入，这时候可以用这个命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="查看端口号"><a href="#查看端口号" class="headerlink" title="查看端口号"></a>查看端口号</h4><p>如果 80 端口被占用，可以使用此命令查看端口占用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlnp 80</span><br></pre></td></tr></table></figure><h3 id="五、自定义错误页面以及访问控制"><a href="#五、自定义错误页面以及访问控制" class="headerlink" title="五、自定义错误页面以及访问控制"></a>五、自定义错误页面以及访问控制</h3><ul><li>多错误指向一个页面</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page   500 502 503 504  /50x.html;</span><br></pre></td></tr></table></figure><ul><li>单独为错误置顶处理方式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page 404  /404_error.html;</span><br></pre></td></tr></table></figure><ul><li>把错误码换成一个地址</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_page  404 http://kobin.top;</span><br></pre></td></tr></table></figure><ul><li>简单实现访问控制</li></ul><p>有时候我们的服务器只允许特定主机访问，比如内部 OA 系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些 IP 访问，我们可以直接在 location 里进行配置。</p><p>可以直接在 default.conf 里进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        deny   123.9.51.42;</span><br><span class="line">        allow  45.76.202.231;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>指令优先级</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        allow  45.76.202.231;</span><br><span class="line">        deny   all;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的配置表示只允许<code>45.76.202.231</code>进行访问，其他的 IP 是禁止访问的。但是如果我们把<code>deny all</code>指令，移动到 <code>allow 45.76.202.231</code>之前，会发生什么那？</p><p>会发现所有的 IP 都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（<code>也就是谁先触发，谁起作用</code>）。</p><ul><li>复杂访问控制权限匹配</li></ul><p>在工作中，访问权限的控制需求更加复杂，例如，对于网站下的 img（图片目录）是运行所有用户访问，但对于网站下的 admin 目录则只允许公司内部固定 IP 访问。这时候仅靠 deny 和 allow 这两个指令，是无法实现的。我们需要 location 块来完成相关的需求匹配。</p><p>上面的需求，配置代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location =/img&#123;</span><br><span class="line">    allow all;</span><br><span class="line">&#125;</span><br><span class="line">location =/admin&#123;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用正则表达式设置访问权限</li></ul><p>只有精确匹配(=)有时是完不成我们的工作任务的，比如现在我们要禁止访问所有 php 的页面，php 的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~\.php$ &#123;</span><br><span class="line">       deny all;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样我们再访问的时候就不能访问以 php 结尾的文件了。是不是让网站变的安全很多了那？</p><h3 id="六、Nginx-配置虚拟主机"><a href="#六、Nginx-配置虚拟主机" class="headerlink" title="六、Nginx 配置虚拟主机"></a>六、Nginx 配置虚拟主机</h3><p>虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供 Web 服务，并且互不干扰。用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上。可以大大节约服务器成本与维护成本。</p><ul><li>基于端口号配置虚拟主机</li></ul><p>基于端口号来配置虚拟主机，算是 Nginx 中最简单的一种方式了。原理就是 Nginx 监听多个端口，根据不同的端口号，来区分不同的网站</p><p>我习惯在 conf.d 里新建一个配置文件来配置新的虚拟主机，但也可以配置在主配置 <code>etc/nginx/nginx.conf</code>里，也可以配置在<code>etc/nginx/conf.d/default.conf</code>里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen 8088;</span><br><span class="line">server_name localhost;</span><br><span class="line">location / &#123;</span><br><span class="line">          root /usr/share/nginx/html/html8001;</span><br><span class="line">          index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于 IP 的虚拟主机</li></ul><p>基于 IP 和基于端口的配置几乎一样，只是把<code>server_name</code>选项，配置成 IP 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name 112.74.164.244;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html/html8001;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于域名的虚拟主机</li></ul><p>域名设置虚拟主机也非常简单，主要操作的是配置文件的 <code>server_name</code> 项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx.kobin.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name nginx2.kobin.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                root /usr/share/nginx/html/html8001;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、Nginx-反向代理的设置"><a href="#七、Nginx-反向代理的设置" class="headerlink" title="七、Nginx 反向代理的设置"></a>七、Nginx 反向代理的设置</h3><p>什么是反向代理？ 互联网应用基本都基于 CS 基本结构，即 client 端和 server 端。代理其实就是在 client 端和真正的 server 端之前增加一层提供特定服务的服务器，即代理服务器。</p><p>在了解反向代理前先了解什么是正向代理。</p><ul><li>正向代理</li></ul><p>翻墙工具就是一个典型的正向代理工具。它会把我们不能访问的墙外服务器 server 的网页请求，代理到一个可以访问该网站的代理服务器 proxy，这个代理服务器 proxy 把墙外服务器 server 上的网页内容获取，再转发给客户。具体的流程如下图。<br><img src="http://yanxuan.nosdn.127.net/20284ff2217ab7398f7ed808018b0dc0.png" alt="UTOOLS1590478206582.png"></p><p>其特点如下：</p><ul><li>客户端和代理服务器可以直接互相访问，属于一个 LAN（局域网）</li><li>代理对用户是非透明的，即用户需要自己操作或者感知得到自己的请求被发送到代理服务器</li><li>代理服务器通过代理用户端的请求来向域外服务器请求响应内容。</li></ul><blockquote><p>一句话总结： 代理的是客户端</p></blockquote><ul><li>反向代理</li></ul><p>反向代理正好相反，客户端发送的请求，想要访问 server 服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。<br><img src="http://yanxuan.nosdn.127.net/5f949b17f0ce40d745549acd519bc0ca.png" alt="UTOOLS1590478385142.png"></p><p>其特点如下：</p><ul><li>代理服务器和真正 server 服务器可以直接互相访问，属于一个 LAN（服务器内网）</li><li>代理对用户是透明的，即无感知。不论加不加这个反向代理，用户都是通过相同的请求进行的，且不需要任何额外的操作；</li><li>代理服务器通过代理内部服务器接受域外客户端的请求，并将请求发送到对应的内部服务器上。</li></ul><blockquote><p>一句话总结： 代理的是服务器</p></blockquote><ul><li><p>反向代理的好处：</p><ul><li><p>安全及权限<br>使用反向代理后，用户端将无法直接通过请求访问真正的内容服务器，而必须通过 Nginx。可以通过在 Nginx 层上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。</p></li><li><p>负载均衡<br>一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那 Nginx 可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配</p></li></ul></li><li><p>简单实现反向代理</p></li></ul><p>举个例子，我们访问 home.kobin.top 这个网站，然后反向代理到 baidu.com 上。可做如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name home.kobin.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">               proxy_pass https://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="http://yanxuan.nosdn.127.net/5f2dbe03d87bf90594f84aa9d94442de.png" alt="UTOOLS1590479272673.png"></p><p>其他常用的反向代理配置：</p><ul><li><p>proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。</p></li><li><p>proxy_connect_timeout:配置 Nginx 与后端代理服务器尝试建立连接的超时时间。</p></li><li><p>proxy_read_timeout : 配置 Nginx 向后端服务器组发出 read 请求后，等待相应的超时时间。</p></li><li><p>proxy_send_timeout：配置 Nginx 向后端服务器组发出 write 请求后，等待相应的超时时间。</p></li><li><p>proxy_redirect :用于修改后端服务器返回的响应头中的 Location 和 Refresh。</p></li></ul><h3 id="八、Nginx-适配移动端与-PC-端"><a href="#八、Nginx-适配移动端与-PC-端" class="headerlink" title="八、Nginx 适配移动端与 PC 端"></a>八、Nginx 适配移动端与 PC 端</h3><p>Nginx 通过内置变量<code>$http_user_agent</code>，可以获取到请求客户端的<code>userAgent</code>，就可以用户目前处于移动端还是 PC 端，进而展示不同的页面给用户。</p><p>在 conf.d 目录下新建一个 demo.conf 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name blog.kobin.top;</span><br><span class="line">location / &#123;</span><br><span class="line">root /yangling/app/pc; <span class="comment"># 默认展示PC端页面</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$http_user_agent</span> ~* <span class="string">'(Android|webOS|iPhone|iPod|BlackBerry)'</span>) &#123; <span class="comment"># 如果匹配到mobile端的user_agent则展示mobile页面</span></span><br><span class="line">root /yangling/app/mobile;</span><br><span class="line">&#125;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九、Nginx-实现-Gzip-压缩"><a href="#九、Nginx-实现-Gzip-压缩" class="headerlink" title="九、Nginx 实现 Gzip 压缩"></a>九、Nginx 实现 Gzip 压缩</h3><p>Gzip 是网页的一种网页压缩技术，经过 gzip 压缩后，页面大小可以变为原来的 30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip 网页压缩的实现需要浏览器和服务器的支持。</p><p>gzip 是需要服务器和浏览器同事支持的。当浏览器支持 gzip 压缩时，会在请求消息中包含 Accept-Encoding:gzip,这样 Nginx 就会向浏览器发送听过 gzip 后的内容，同时在相应信息头中加入 Content-Encoding:gzip，声明这是 gzip 后的内容，告知浏览器要先解压后才能解析输出。</p><p>gzip 配置：</p><ul><li>gzip : 该指令用于开启或 关闭 gzip 模块。</li><li>gzip_buffers : 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。</li><li>gzip_comp_level : gzip 压缩比，压缩级别是 1-9，1 的压缩级别最低，9 的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。</li><li>gzip_disable : 可以通过该指令对一些特定的 User-Agent 不使用压缩功能。</li><li>gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的 Content-length 中进行获取。</li><li>gzip_http_version：识别 HTTP 协议版本，其值可以是 1.1.或 1.0.</li><li>gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩。</li><li>gzip_vary : 用于在响应消息头中添加 Vary：Accept-Encoding,使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩。</li></ul><p>简单配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">   .....</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types text/plain application/javascript text/css;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gzip on</code>是启用 gizp 模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和 CSS 文件进行压缩输出。</p><h3 id="十、Nginx-与跨域请求"><a href="#十、Nginx-与跨域请求" class="headerlink" title="十、Nginx 与跨域请求"></a>十、Nginx 与跨域请求</h3><p>举个例子：在 a.com 页面中有请求 b.com 的接口<code>http://b.com/getHomeData</code>, 出现了跨域问题。当然这种跨域问题的处理方式很多，这里主要说下用 Nginx 如何解决。</p><p>在 a.com 启个 Nginx 服务，配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name a.com;</span><br><span class="line">  <span class="comment">#请求跨域，这里约定代理请求url path是以/apis/开头</span></span><br><span class="line">  location ^~/apis/ &#123;</span><br><span class="line">      <span class="comment"># 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配</span></span><br><span class="line">      rewrite ^/apis/(.*)$ /<span class="variable">$1</span> <span class="built_in">break</span>;</span><br><span class="line">      proxy_pass https://www.b.com/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时请求接口 URL 换成<a href="http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。" target="_blank" rel="noopener">http://a.com/apis/getHomeData，就可以正常请求到数据了。其本质还是利用了服务端不受跨域限制的原理。</a></p><h3 id="十一、Nginx-与合并请求"><a href="#十一、Nginx-与合并请求" class="headerlink" title="十一、Nginx 与合并请求"></a>十一、Nginx 与合并请求</h3><p>通过<a href="https://github.com/alibaba/nginx-http-concat" target="_blank" rel="noopener">nginx-http-concat</a>插件可以实现将多个资源请求合并为一个请求，达到性能优化目的。</p><h3 id="十二、Nginx-与图片处理"><a href="#十二、Nginx-与图片处理" class="headerlink" title="十二、Nginx 与图片处理"></a>十二、Nginx 与图片处理</h3><p>通过<a href="http://nginx.org/en/docs/http/ngx_http_image_filter_module.html" target="_blank" rel="noopener">ngx_http_image_filter_module</a>插件实现日常对图片的处理，包括缩放、裁剪、旋转、图片质量等的控制。</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全栈 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章摘录</title>
      <link href="/collection/"/>
      <url>/collection/</url>
      
        <content type="html"><![CDATA[<p>在这里记录一些看到的好文章好博客</p><a id="more"></a><p><a href="https://www.cnblogs.com/tugenhua0707" target="_blank" rel="noopener">龙恩 0707</a></p><p><a href="https://github.com/renaesop/blog/issues/1" target="_blank" rel="noopener">cdn</a></p><p><a href="https://biaochenxuying.cn/" target="_blank" rel="noopener">全栈修炼</a></p><p><a href="https://yuchengkai.cn/" target="_blank" rel="noopener">前端进阶之道</a></p><p><a href="https://lucifer.ren/fe-interview/#/" target="_blank" rel="noopener">大前端面试宝典 - 图解前端</a></p><p><a href="https://mp.weixin.qq.com/s/FwrId8d2kCJKvtGTdM2xHw" target="_blank" rel="noopener">未来可期的 TypeScript</a></p><p><a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ" target="_blank" rel="noopener">别再说虚拟 DOM 快了，要被打脸的</a></p><p><a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A" target="_blank" rel="noopener">深入理解虚拟 DOM，它真的不快</a></p><p><a href="https://juejin.im/post/5d3e3231e51d4510926a7c39" target="_blank" rel="noopener">Deep In React 之详谈 React 16 Diff 策略(二)</a></p><p><a href="https://zhuanlan.zhihu.com/p/54042084" target="_blank" rel="noopener">ReactFiber 在并发模式下的运行机制</a></p><p><a href="https://zhuanlan.zhihu.com/p/78677852" target="_blank" rel="noopener">前端浏览器输入 URL 后发生什么</a></p><p><a href="https://github.com/fouber/blog/issues/6" target="_blank" rel="noopener">大公司如何部署前端代码</a></p><p><a href="https://zhuanlan.zhihu.com/p/53599723" target="_blank" rel="noopener">Vuex、Flux、Redux、Redux-saga、Dva、MobX</a><br><a href="https://juejin.im/post/5eb3cab66fb9a043856f3987?utm_source=gold_browser_extension" target="_blank" rel="noopener">累死累活做业务，绩效还不怎么样，我只能帮你到这了……</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo搭建个人博客并使用GitHub Actions一键发布到GitHub pages &amp; 阿里云ECS</title>
      <link href="/others-hexo/"/>
      <url>/others-hexo/</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本文记录了使用 Hexo 创建个人博客并使用GitHub Actions一键发布到 GitHub pages 和 阿里云ECS上的全过程。</p><a id="more"></a><h3 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Hexo 前，请先确保您的电脑上已经安装了下列应用程序：</p><ul><li><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p><em>注： 如果您的电脑未安装 Node 或者 Git，请先安装后再阅读下面内容</em></p><h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>使用 npm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>使用 yarn:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn global add hexo-cli</span><br></pre></td></tr></table></figure><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</p><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>新建一篇文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h4 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h4><p>发表草稿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p><em>注： 更多命令见<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">官网</a></em></p><h3 id="部署-GitHub-pages"><a href="#部署-GitHub-pages" class="headerlink" title="部署 GitHub pages"></a>部署 GitHub pages</h3><p>如果您只是想部署到GitHub Actions上，那么可以直接用这节的方法。如果还想部署到阿里云等私人服务器上，那么可以跳过这步，直接看下一节。</p><h4 id="新建-GitHub-项目"><a href="#新建-GitHub-项目" class="headerlink" title="新建 GitHub 项目"></a>新建 GitHub 项目</h4><p>打开 GitHub 点击右上角的<code>new repository</code><br><img src="http://yanxuan.nosdn.127.net/e4ab3a5d71b66640072d74bd000cae04.png" alt="UTOOLS1588764262695.png"></p><p>然后在下图所示中，输入项目名称（后面一定要加.github.io 后缀），勾选 readme 初始化，点击完成创建<br><img src="http://yanxuan.nosdn.127.net/5204b23ad8733af70ec1d2132e9dacff.png" alt="UTOOLS1588764393885.png"></p><h4 id="安装-hexo-deployer-git。"><a href="#安装-hexo-deployer-git。" class="headerlink" title="安装 hexo-deployer-git。"></a>安装 hexo-deployer-git。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="修改-config-yml-配置"><a href="#修改-config-yml-配置" class="headerlink" title="修改_config.yml 配置"></a>修改_config.yml 配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:jiangawait&#x2F;jiangawait.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h4><p>执行 hexo deploy 将生成的文件部署到上一步配置的仓库对应的分支上去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><blockquote><p>至此，已经实现了个人博客的搭建并完成了一键发布到GitHub Pages的功能，如果只需要发布到GitHub Pages，那么至此已经可以愉快地写文章了。</p><p>但是由于总所周知的原因，GitHub在国内的访问速度总是时好时坏，不够畅快。</p><p>那么如果你手里恰好有闲置的云服务器，那么接下去就更进一步吧！🙂</p></blockquote><h3 id="GitHub-Actions登场"><a href="#GitHub-Actions登场" class="headerlink" title="GitHub Actions登场"></a>GitHub Actions登场</h3><p>GitHub Actions 是 GitHub 于2018年10月推出的持续集成服务。功能非常强大，具体的基础用法不赘述，可以参阅<a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">阮一峰老师的教程</a>。</p><p>这里主要介绍如何配置GitHub Actions实现自动部署功能。</p><h4 id="创建workflow-文件"><a href="#创建workflow-文件" class="headerlink" title="创建workflow 文件"></a>创建workflow 文件</h4><p>GitHub Actions 的配置文件叫做 workflow 文件, 存放在代码仓库的.github/workflows目录。</p><p>新建.github/workflows/deploy.yml, 具体配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">build</span> <span class="string">and</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span> <span class="comment"># blog分支是本人的hexo源码分支</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 切换分支</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span> <span class="comment"># If you're using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line">          <span class="comment"># checkout到你的hexo代码分支</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">blog</span></span><br><span class="line">          <span class="comment"># hexo需要加载内部子模块</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 使用 node:10</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">use</span> <span class="string">Node.js</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 安装npm包 &amp; 生成静态文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">and</span> <span class="string">publish</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 将静态文件部署到阿里云</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">aliyun</span> <span class="string">server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.0.7</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">"-avz --delete"</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">"public"</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ALIYUN_SERVER_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">"root"</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">"/code/hexo-blog"</span> <span class="comment"># 静态资源存放目录</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 将静态文件部署到github pages</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Github</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BASE_BRANCH:</span> <span class="string">blog</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure><h4 id="配置参数说明"><a href="#配置参数说明" class="headerlink" title="配置参数说明"></a>配置参数说明</h4><ul><li>ALIYUN_SERVER_HOST： 阿里云服务器公网IP；</li><li>ALIYUN_SERVER_ACCESS_TOKEN：阿里云.ssh下的私钥(id_rsa);<ul><li>如果未生成过，可以执行如下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -m PEM -t rsa -b 4096</span><br></pre></td></tr></table></figure></li><li>把公钥复制一份到authorized_keys中:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ul></li><li>ACCESS_TOKEN:  GitHub 密钥, 按照<a href="https://help.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line" target="_blank" rel="noopener">官方文档</a>生成一个秘钥。</li></ul><p>以上三个参数都保存到自己仓库-&gt;settings-&gt;Secrets里面：</p><p><img src="http://yanxuan.nosdn.127.net/682b4ddff33a7fb61d5a76ca59374e83.png" alt="UTOOLS1590676585606.png"></p><h4 id="构建结果"><a href="#构建结果" class="headerlink" title="构建结果"></a>构建结果</h4><p>将整个仓库推送到GitHub，GitHub 发现了 workflow 文件以后，就会自动运行。<br><img src="http://yanxuan.nosdn.127.net/afd80ff8efb75954b5ca1723d264e119.png" alt="UTOOLS1590679294118.png"></p><p>至此，我们已经将博客部署到GitHub Actions和阿里云上了。阿里云上我们可以使用Nginx托管静态资源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  kobin.top;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /code/hexo-blog/public; <span class="comment"># 静态资源存放目录</span></span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切大功告成！收工😄</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Event Loop详解</title>
      <link href="/javascript-event-loop/"/>
      <url>/javascript-event-loop/</url>
      
        <content type="html"><![CDATA[<p>JavaScript从诞生起就是一门单线程的语言,单线程的缺点是任务执行会阻塞，表现到网页里是：发起数据请求 –&gt; http延迟 –&gt; 等待完成，等待的过程中，其他操作无法执行，导致页面长时间无响应。</p><p>JavaScript用<strong>异步回调（asynchronous callback）</strong>去解决这些问题。实现异步回调的特性，其实是基于Event Loop（事件循环）。</p><a id="more"></a><h2 id="先了解一点基础知识"><a href="#先了解一点基础知识" class="headerlink" title="先了解一点基础知识"></a><strong>先了解一点基础知识</strong></h2><h3 id="1-JavaScript的-Engine-和-Runtime"><a href="#1-JavaScript的-Engine-和-Runtime" class="headerlink" title="1. JavaScript的 Engine 和 Runtime"></a><strong>1.</strong> JavaScript的 Engine 和 Runtime</h3><p>简单来说，为了让 JavaScript 运行起来，要完成两部分工作（当然实际比这复杂得多）：</p><p>第一部分是<strong>Engine（JS引擎）</strong>：编译并执行 JavaScript 代码，完成内存分配、垃圾回收等；<br>第二部分是<strong>是 Runtime（运行时）</strong>：为 JavaScript 提供一些对象或机制，使它能够与外界交互。</p><p>举个例子：</p><p>Chrome浏览器 和 Node.js 都使用了 V8 Engine。V8 实现并提供了 ECMAScript 标准中的所有数据类型、操作符、对象和方法（注意并没有 DOM）。 但它们的 Runtime 并不一样：Chrome 提供了 window、DOM，而 Node.js 则是 require、process 等等。</p><h3 id="2-浏览器的线程"><a href="#2-浏览器的线程" class="headerlink" title="2. 浏览器的线程"></a><strong>2. 浏览器的线程</strong></h3><p>现代浏览器的一个 tab ，其中的线程包括但不局限于：</p><ul><li>GUI 渲染线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器触发线程</li><li>异步http请求线程</li></ul><p>JavaScript中的异步回调是通过 WebAPIs 去支持的，常见的有 <code>XMLHttpRequest</code>，<code>setTimeout</code>，事件回调（<code>onclik</code>, <code>onscroll</code>等）。而这几个 API 浏览器都提供了单独的线程去运行，所以才会有合适的地方去处理定时器的计时、各种请求的回调。即当代码中出现这几个定义的异步任务，<strong>是由浏览器实现了它们与JS引擎的通信，与JS引擎不属与同一个线程</strong>。</p><p>另外，GUI 渲染和JavaScript执行是互斥的。虽然两者属于不同的线程，但是由于JavaScript执行结果可能会对页面产生影响，所以浏览器对此做了处理，大部分情况下JavaScript线程执行，执行渲染（render）的线程就会暂停，等JavaScript的同步代码执行完再去渲染。</p><h2 id="Event-loop的定义"><a href="#Event-loop的定义" class="headerlink" title="Event loop的定义"></a>Event loop的定义</h2><p>Event Loop（事件循环） 是让 JavaScript 做到既是单线程，又绝对不会阻塞的核心机制，也是 JavaScript 并发模型（Concurrency Model）的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。Event Loop的作用很简单： 监控<strong>调用栈</strong>和<strong>任务队列</strong>（见 3），如果调用栈是空的，它就会取出队列中的第一个”callback函数”，然后将它压入到调用栈中，然后执行它。</p><p>总的来说，Event Loop 是<strong>实现异步回调的一种机制</strong>而已。</p><h3 id="1-分两种"><a href="#1-分两种" class="headerlink" title="1.分两种"></a>1.分两种</h3><p>Event Loop 分为两种，一种存在于 Browsing Context 中，还有一种在 Worker 中。</p><ol><li><strong>Browsing Context</strong> 是指一种用来将 Document（文档）展现给用户的环境。例如浏览器中的 tab，window 或 iframe 等，通常都包含 Browsing Context。</li><li><strong>Worker</strong> 是指一种独立于 UI 脚本，可在后台执行脚本的 API。常用来在后台处理一些计算密集型的任务。</li></ol><p>本篇重点介绍的是 Browsing Context 中的 Event Loop，相比 Worker 中的 Event Loop，它也更加复杂一些。</p><blockquote><p>另外，Event Loop 并不是在 ECMAScript 标准中定义的，而是在 HTML 标准中定义的。在 JS引擎中（以V8为例），只是实现了 ECMAScript 标准，而并不关心什么 Event Loop。也就是说 <strong>Event Loop 是属于 JavaScript Runtime</strong> 的，是由宿主环境（比如浏览器）提供的。所以千万不要理解错了，这也是前面介绍 JavaScript Engine 和 Runtime 的原因。</p></blockquote><h3 id="2-独立"><a href="#2-独立" class="headerlink" title="2.独立"></a>2.独立</h3><p>每个”线程“都有自己的 Event Loop。所以，每个 web worker 拥有独立的 Event Loop，它们都可以独立运行；<a href="https://html.spec.whatwg.org/#similar-origin-window-agent" target="_blank" rel="noopener">同源的 windows</a> 共享一个 Event Loop，它们之间可以互相通信。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>从 JavaScript 内存模型的角度，我们可以将内存划分为调用栈（Call Stack）、堆（Heap）以及任务队列（Queue）等几个部分：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfczoqm41bj308b07n74l.jpg" alt=""></p><h3 id="1-调用栈"><a href="#1-调用栈" class="headerlink" title="1. 调用栈"></a>1. 调用栈</h3><p>调用栈会记录所有的函数调用信息，当我们调用某个函数时，会将其参数与局部变量等以栈帧的形式压入栈中（入栈）；在执行完毕后，会弹出栈顶的帧。让我们来看一看下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>当程序开始执行的时候，调用栈是空的，然后，步骤如下：</p><p><img src="../.gitbook/assets/image%20%2817%29.png" alt=""></p><h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h3><p>堆则则存放了大量的非结构化数据，譬如程序分配的变量与对象。</p><h3 id="3-任务队列"><a href="#3-任务队列" class="headerlink" title="3. 任务队列"></a>3. 任务队列</h3><p>任务队列包含了一系列待处理的信息与相关联的回调函数。任务队列又分为 <strong>MacroTask Queue</strong> 和 <strong>MicroTask Queue</strong> 两种。</p><h2 id="MacroTask-和-MicroTask"><a href="#MacroTask-和-MicroTask" class="headerlink" title="MacroTask 和 MicroTask"></a>MacroTask 和 MicroTask</h2><h3 id="1-MacroTask-Queue（宏任务队列）"><a href="#1-MacroTask-Queue（宏任务队列）" class="headerlink" title="1. MacroTask Queue（宏任务队列）"></a>1. MacroTask Queue（宏任务队列）</h3><p>Event Loop 会有一个或多个 MacroTask Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 <strong>Task Source</strong>（任务源）的 Task（也即MacroTask）。</p><blockquote><p>关于 Task，常有人通俗地称它为 MarcoTask，但其实 HTML 标准中并没有这种说法。然而，为了方便理解，本书仍沿用通俗的称谓MacroTask。</p></blockquote><p>在 HTML 标准中，定义了几种常见的 Task Source：</p><ul><li>DOM manipulation（DOM 操作）；</li><li>User interaction（用户交互）；</li><li>Networking（网络请求）；</li><li>History traversal（History API 操作）。</li></ul><p>MacroTask Source 的定义非常的宽泛，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），以及定时器相关的 setTimeout、setInterval 等等都属于 Task Source，所有来自这些 MacroTask Source 的 MacroTask 都会被放到对应的 MacroTask Queue 中等待处理。</p><p>对于 MacroTask、MacroTask Queue 和 Task Source，有如下规定：</p><ol><li>来自相同 Task Source 的 MacroTask，必须放在同一个 MacroTask Queue 中；</li><li>来自不同 Task Source 的 MacroTask，可以放在不同的 MacroTask Queue 中；</li><li>同一个 MacroTask Queue 内的 MacroTask 是按顺序执行的；</li><li>但对于不同的 MacroTask Queue（Task Source），浏览器会进行调度，允许优先执行来自特定 Task Source 的 MacroTask。</li></ol><blockquote><p>例如，鼠标、键盘事件和网络请求都有各自的 MacroTask Queue，当两者同时存时，浏览器可以优先从用户交互相关的 MacroTask Queue 中挑选 MacroTask 并执行，比如这里的鼠标、键盘事件，从而保证流畅的用户体验。</p></blockquote><h3 id="2-MicroTask-Queue（微任务队列）"><a href="#2-MicroTask-Queue（微任务队列）" class="headerlink" title="2. MicroTask Queue（微任务队列）"></a>2. MicroTask Queue（微任务队列）</h3><p>MicroTask Queue 与 MacroTask Queue 类似，也是一个有序列表。不同之处在于，<strong>一个 Event Loop 只有一个 MicroTask Queue</strong>。</p><p>在 HTML 标准中，并没有明确规定 MicroTask Source，通常认为有以下几种：</p><ul><li>Promise</li></ul><blockquote><p>在 Promises/A+ Note 3.1 中提到了 then、onFulfilled、onRejected 的实现方法，但 Promise 本身属于平台代码，由具体实现来决定是否使用 Microtask，因此在不同浏览器上可能会出现执行顺序不一致的问题。不过好在目前的共识是用 Microtask 来实现事件队列。</p></blockquote><ul><li>MutationObserver</li><li>Object.observe (已废弃)</li></ul><p>这里要特别提一下：网上有很多文章把 Node.js 的 <code>process.nextTick</code> 和 Microtask 混为一谈，事实上虽然两者层级（运行时机）非常接近，但并不是同一个东西。<code>process.nextTick</code> 是 Node.js 自身定义实现的一种机制，有自己的 nextTickQueue，与 HTML 标准中的 MicroTask 不是一回事。在 Node.js 中，<code>process.nextTick</code> 会先于 Microtask Queue 被执行。</p><h3 id="3-二者关系图例"><a href="#3-二者关系图例" class="headerlink" title="3. 二者关系图例"></a>3. 二者关系图例</h3><p>Event Loop中，每一次循环称为tick，每一次tick的任务细节如下：</p><ul><li>调用栈选择最先进入队列的MacroTask（通常是script整体代码），如果有则执行；</li><li>检查是否存在 MicroTask，如果存在则不停的执行，直至清空 MicroTask Queue；</li><li>浏览器更新渲染（render），每一次事件循环，浏览器都可能会去更新渲染；</li><li>重复以上步骤。</li></ul><p>MacroTask Queue和MicroTask Queue二者的关系如下图：</p><p><img src="https://pic1.zhimg.com/80/v2-a24e582fda37065755f10bd4dc5a3dc0_hd.jpg" alt=""></p><p>如图所示，二者互相穿插：MacroTask –&gt; MicroTask Queue –&gt; MacroTask。</p><p><strong>一个Event Loop会有一个或多个 MacroTask Queue，而 Event Loop 仅有一个 MicroTask Queue。</strong></p><p>这句话可能比较令人费解，因为图中似乎有2 个MicroTask Queue！</p><p>其实是这样的，每个 MacroTask Queue 都保证按照回调函数（callback）入队列的顺序依次执行MacroTask，在 MacroTask 或者 MicroTask 中产生的新 MicroTask 会被压入到 MicroTask Queue中并执行。而在 执行两个MacroTask之间，也即在执行下一个MacroTask之前，<strong>会优先执行完所有MicroTask，也即会优先清空已有的 MicroTask Queue</strong>。</p><p>因此，图中第二个MicroTask Queue产生的时候，第一个MicroTask Queue其实已经被清空了。所以Event Loop实际上仅有一个MicroTask Queue。</p><h2 id="JavaScript-Runtime-的运行机制"><a href="#JavaScript-Runtime-的运行机制" class="headerlink" title="JavaScript Runtime 的运行机制"></a>JavaScript Runtime 的运行机制</h2><p>了解了 Event Loop 和任务队列的基本概念后，就可以从相对宏观的角度先了解一下 JavaScript Runtime 的运行机制了，简化后的步骤如下：</p><ol><li><p>主线程不断循环；</p></li><li><p>对于<strong>同步任务</strong>，创建执行上下文（Execution Context），按顺序进入调用栈；</p></li><li><p>对于<strong>异步任务</strong>：</p><ul><li>与步骤 2 相同，同步执行这段代码；</li><li>将相应的 MacroTask（或 Microtask）添加到任务队列；</li><li>由其他线程来执行具体的异步操作。</li></ul></li></ol><blockquote><p>其他线程是指：尽管 JavaScript 是单线程的，但浏览器内核是多线程的，它会将 GUI 渲染、定时器触发、HTTP 请求等工作交给专门的线程来处理。另外，在 Node.js 中，异步操作会优先由 OS 或第三方系统提供的<strong>异步接口</strong>来执行，然后才由线程池处理。</p></blockquote><ol start="4"><li>当主线程执行完当前调用栈中的所有任务，就会去读取 Event Loop 的任务队列，取出并执行任务；</li><li>重复以上步骤。</li></ol><p>用一张简图来表示一下这种运行机制：</p><p><img src="https://pic4.zhimg.com/80/v2-64476c110e4efcd85df76dc49b510abb_hd.jpg" alt=""></p><p>还是拿 setTimeout 举例：</p><ol><li>主线程同步执行这个 setTimeout 函数本身。</li><li>将负责执行这个 setTimeout 的回调函数的 MacroTask 添加到 MacroTask Queue。</li><li>定时器开始工作（实际上是靠 Event Loop 不断循环检查系统时间来判断是否已经到达指定的时间点）。</li><li>主线程继续执行其他任务。</li><li>当调用栈为空，且定时器触发时，主线程取出 MacroTask 并执行相应的回调函数。</li></ol><p>很明显，执行 setTimeout 不会导致阻塞。当然，如果主线程很忙的话（调用栈一直非空），就会出现明明时间已经到了，却也不执行回调的现象，所以类似 setTimeout 这样的回调函数都是没法保证执行时机的。</p><blockquote><p>setTimeout和setInterval取的时间是不准确的，因为当调用栈若不为空，它们的回调函数永远不会别执行。所以，我们会经常碰到setTimeout和setInterval用来做动画的时候，很不流畅或者卡顿。</p></blockquote><h2 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h2><p>在面试中我们常常会碰到如下类似的代码题，面试官要你写出输出结果，其要目的是考察对JavaScript不同任务的执行先后顺序的理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行顺序问题，考察频率挺高</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>根据本文的解析，我们可以得到：</p><ol><li>先执行同步代码<ul><li>首先，执行<code>new Promise</code>中的<code>console.log(2)</code>，then后面的属于MicroTask所以跳过；</li><li>然后，执行<code>console.log(4)</code>。</li></ul></li><li>执行完script这个MacroTask后，执行MicroTask（也即<code>Promise.then</code>） 中的<code>console.log(val)</code>，此时<code>val</code>的值由<code>resolve(3)</code>传递过来，值为<code>3</code>。后面无其他微任务。</li><li>执行另一个MacroTask也即定时器<code>setTimeout</code>中的<code>console.log(1)</code>。 根据本文的内容，可以很轻松，且有理有据的猜出写出正确答案：2，4，3，1。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript的继承实现</title>
      <link href="/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/"/>
      <url>/javascript-javascript%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>抛开JavaScript自带的class语法糖实现类的继承，如果用原生JavaScript实现类的继承，有以下六种方式，其实现代码与优缺点分析如下</p><a id="more"></a><h2 id="01-类式继承-classical-inheritance"><a href="#01-类式继承-classical-inheritance" class="headerlink" title="01.类式继承(classical inheritance)"></a>01.类式继承(classical inheritance)</h2><p> 实现本质：重写子类的原型，代之以父类的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.username = username ? username : <span class="string">"Unknown"</span>;</span><br><span class="line">   <span class="keyword">this</span>.books = [<span class="string">"coffe"</span>, <span class="string">"1891"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (username)</span><br><span class="line">      <span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键</span></span><br><span class="line">CoffeUser.prototype = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser();</span><br><span class="line"><span class="keyword">const</span> user2 = <span class="keyword">new</span> CoffeUser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//instanceof是检测某个对象是否是某个类的实例</span></span><br><span class="line"><span class="built_in">console</span>.log(user1 <span class="keyword">instanceof</span> User);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接访问原型链上的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.username);<span class="comment">//&gt;&gt; Unknown</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.books); <span class="comment">//&gt;&gt; ["coffe", "1891"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改来自原型上的引用类型的属性，则有副作用：会影响到所有实例</span></span><br><span class="line">user1.books.push(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user1.books); <span class="comment">//&gt;&gt; ["coffe", "1891", "hello"]</span></span><br><span class="line"><span class="built_in">console</span>.log(user2.books); <span class="comment">//&gt;&gt; ["coffe", "1891", "hello"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改来自原型上的值类型的属性，无副作用</span></span><br><span class="line">user1.username = <span class="string">'U'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(user1.username, user2.username); <span class="comment">//&gt;&gt; U Unknown</span></span><br></pre></td></tr></table></figure><p>缺陷：</p><ul><li><strong>引用类型属性的误修改。</strong>原型属性中的引用类型属性会被所有实例共享，若子类实例更改从父类原型继承来的引用类型的共有属性，会影响其他子类。</li><li><strong>无法传递参数。</strong>在创建子类型的实例时，不能向父类的构造函数中传递参数。这点如过不好理解的话，接着看下面的“构造函数式继承”。</li></ul><p>综上，我们在实际开发中很少单独使用类式继承。</p><h2 id="02-构造函数式继承"><a href="#02-构造函数式继承" class="headerlink" title="02.构造函数式继承"></a>02.构造函数式继承</h2><p>通过call/apply调用来实现继承：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.password = password;</span><br><span class="line">   <span class="keyword">this</span>.username = username;</span><br><span class="line">   User.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.username + <span class="string">'要登录Github，密码是'</span> + <span class="keyword">this</span>.password);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   User.call(<span class="keyword">this</span>, username, password);<span class="comment">//通过call向父类的构造函数传递参数</span></span><br><span class="line">   <span class="keyword">this</span>.articles = <span class="number">3</span>; <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser(<span class="string">'coffe1891'</span>, <span class="string">'123456'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1 <span class="keyword">instanceof</span> User);<span class="comment">//&gt;&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.username, user1.password); <span class="comment">//&gt;&gt; coffe1891 123456</span></span><br><span class="line"><span class="built_in">console</span>.log(user1.login()); <span class="comment">// TypeError: user1.login is not a function</span></span><br></pre></td></tr></table></figure><p>存在明显的缺陷：</p><ul><li>无法通过instanceof的测试；</li><li>并没有继承父类原型上的方法。</li></ul><h2 id="03-组合式继承"><a href="#03-组合式继承" class="headerlink" title="03.组合式继承"></a>03.组合式继承</h2><p>既然上述两种方法各有缺点，但是又各有所长，那么我们是否可以将其结合起来使用呢？即原型链继承方法，而在构造函数继承属性，这种继承方式就叫做“组合式继承”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.password = password;</span><br><span class="line">   <span class="keyword">this</span>.username = username;</span><br><span class="line">   User.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.username + <span class="string">'要登录Github，密码是'</span> + <span class="keyword">this</span>.password);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   User.call(<span class="keyword">this</span>, username, password); <span class="comment">// 第2次执行 User 的构造函数</span></span><br><span class="line">   <span class="keyword">this</span>.articles = <span class="number">3</span>; <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CoffeUser.prototype = <span class="keyword">new</span> User(); <span class="comment">// 第1次执行 User 的构造函数</span></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser(<span class="string">"coffe1891"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user1 <span class="keyword">instanceof</span> User);<span class="comment">//&gt;&gt; true</span></span><br><span class="line">user1.login();<span class="comment">//&gt;&gt; coffe1891要登录Github，密码是123456</span></span><br></pre></td></tr></table></figure><p>虽然这种方式弥补了上述两种方式的一些缺陷，但有些问题仍然存在：</p><ul><li>父类的构造函数被调用了两次，显得多余；</li><li><strong>污染：</strong>若再添加一个子类型，给其原型单独添加一个方法，那么其他子类型也同时拥有了这个方法。</li></ul><p>综上，组合式继承也不是我们最终想要的。</p><h2 id="04-原型继承-prototypal-inheritance"><a href="#04-原型继承-prototypal-inheritance" class="headerlink" title="04.原型继承(prototypal inheritance)"></a>04.原型继承(prototypal inheritance)</h2><p>原型继承实际上是对类式继承的一种封装，只不过其独特之处在于，定义了一个干净的中间类，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建临时类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改类的原型为o, 于是f的实例都将继承o上的方法</span></span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不就是ES5的 <code>Object.create</code> 吗？没错，你可以认为是如此。</p><p>既然只是类式继承的一种封装，其使用方式自然如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoffeUser.prototype &#x3D; createObject(User)</span><br></pre></td></tr></table></figure><p>也就仍然没有解决类式继承的一些问题。从这个角度而言，原型继承和类式继承应该直接归为一种继承。</p><h2 id="05-寄生式继承"><a href="#05-寄生式继承" class="headerlink" title="05.寄生式继承"></a>05.寄生式继承</h2><p>寄生式继承是与原型继承紧密相关的一种思路，它依托于一个内部对象而生成一个新对象，因此称之为寄生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserSample = &#123;</span><br><span class="line">   username: <span class="string">"coffe1891"</span>,</span><br><span class="line">   password: <span class="string">"123456"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj);<span class="comment">//o继承obj的原型</span></span><br><span class="line">   o.__proto__.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//扩展方法</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Read article'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> CoffeUser(UserSample);</span><br><span class="line">user.readArticle();<span class="comment">//&gt;&gt; Read article</span></span><br><span class="line"><span class="built_in">console</span>.log(user.username, user.password);<span class="comment">//&gt;&gt; coffe1891 123456</span></span><br></pre></td></tr></table></figure><h2 id="06-寄生组合式继承"><a href="#06-寄生组合式继承" class="headerlink" title="06.寄生组合式继承"></a>06.寄生组合式继承</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寄生组合式继承的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 继承父类的原型</span></span><br><span class="line">   <span class="keyword">const</span> p = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">   <span class="comment">// 重写子类的原型</span></span><br><span class="line">   child.prototype = p;</span><br><span class="line">   <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">   p.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User, 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> _password = password</span><br><span class="line">   <span class="keyword">this</span>.username = username</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype.login = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.username + <span class="string">'要登录Github，密码是'</span> + _password);</span><br><span class="line">   <span class="comment">//&gt;&gt; ReferenceError: _password is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CoffeUser, 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoffeUser</span>(<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">   User.call(<span class="keyword">this</span>, username, password) <span class="comment">// 继承属性</span></span><br><span class="line">   <span class="keyword">this</span>.articles = <span class="number">3</span> <span class="comment">// 文章数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line">inherit(CoffeUser, User);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原型上添加新方法</span></span><br><span class="line">CoffeUser.prototype.readArticle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Read article'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user1 = <span class="keyword">new</span> CoffeUser(<span class="string">"Coffe1891"</span>, <span class="string">"123456"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(user1);</span><br></pre></td></tr></table></figure><p>观察chrome浏览器的输出结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcxvt27izj309k03j3yv.jpg" alt=""></p><p>简单说明一下：</p><ul><li>子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性；</li><li>子类可以传递动态参数给父类；</li><li>父类的构造函数只执行了一次。</li></ul><p>Nice！这才是我们想要的继承方法。然而，仍然存在一个美中不足的问题：</p><ul><li>子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话若是已经存在的两个类，就不好办了。</li></ul><p>所以，我们可以将其优化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承父类的原型</span></span><br><span class="line">    <span class="keyword">const</span> parentPrototype = <span class="built_in">Object</span>.create(parent.prototype)</span><br><span class="line">    <span class="comment">// 将父类原型和子类原型合并，并赋值给子类的原型</span></span><br><span class="line">    child.prototype = <span class="built_in">Object</span>.assign(parentPrototype, child.prototype)</span><br><span class="line">    <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">    p.constructor = child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，使用<code>Object.assign</code> 来进行 copy 仍然不是最好的方法。因为上述的继承方法只适用于 copy 原型链上可枚举的方法，而ES6中，类的方法默认都是不可枚举的。此外，如果子类本身已经继承自某个类，以上的继承将不能满足要求。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" target="_blank" rel="noopener">Inheritance in JavaScript</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/javascript-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>在ES6之前，JavaScript 中除了基础类型外的数据类型都是对象（引用类型），没有类（class），为了实现类似继承以便复用代码的能力，JavaScript选择了原型和原型链。甚至在ES6之后，JavaScript也没有真正的类（class）。ES6虽然提供了class关键字让我么可以伪造一个“类”，但其实只是语法糖而已，本质上仍然是一个对象。ES6实现的继承，本质仍是基于原型和原型链。</p><a id="more"></a><h2 id="原型、prototype、-proto"><a href="#原型、prototype、-proto" class="headerlink" title="原型、prototype、__proto__"></a>原型、prototype、__<strong>proto__</strong></h2><ol><li><p><strong>原型</strong>是一个对象。</p></li><li><p><strong><code>prototype</code>是函数的一个属性而已，也是一个对象，它和原型没有绝对的关系</strong>（很多书、很多网络文章都模糊地将prototype表述为原型，这是严重不对的）。JavaScript里函数也是一种对象，每个对象都有一个原型，但不是所有对象都有<code>prototype</code>属性，实际上只有函数才有这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数才有prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(a.prototype);<span class="comment">//&gt;&gt; function()&#123;&#125;</span></span><br><span class="line"><span class="comment">//非函数，没有prototype属性</span></span><br><span class="line"><span class="built_in">console</span>.log(b.prototype);<span class="comment">//&gt;&gt; undefined</span></span><br></pre></td></tr></table></figure></li><li><p>每个对象(实例)都有一个属性<code>__proto__</code>，指向他的构造函数（constructor）的<code>prototype</code>属性。</p></li><li><p><strong>一个对象的原型就是它的构造函数的<code>prototype</code>属性的值</strong>，因此<strong><code>__proto__</code>也即原型的代名词</strong>。</p></li><li><p>对象的<code>__proto__</code>也有自己的<code>__proto__</code>，层层向上，直到<code>__proto__</code>为null。换句话说，原型本身也有自己的原型。这种由原型层层链接起来的数据结构成为 <strong>原型链</strong>。因为null不再有原型，所以原型链的末端是null。</p></li></ol><p>让我们用更多代码来验证一下以上结论：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//a的构造函数是「Function函数」</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ == <span class="built_in">Function</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"><span class="comment">//b的构造函数是「Array函数」</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__ == <span class="built_in">Array</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为「Function函数」和「Array函数」又都是对象，其构造函数</span></span><br><span class="line"><span class="comment">//是「Object函数」，所以，a和b的原型的原型都是Object.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__.__proto__ === <span class="built_in">Object</span>.prototype);<span class="comment">//&gt;&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Object作为顶级对象的构造函数，它实例的原型本身就不再有原型了，因此它原型</span></span><br><span class="line"><span class="comment">//的__proto__属性为null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Object</span>().__proto__.__proto__);<span class="comment">//&gt;&gt; null</span></span><br><span class="line"><span class="comment">//也即Object类型对象，其原型（Object.prototype）的__proto__为null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);<span class="comment">//&gt;&gt; null</span></span><br></pre></td></tr></table></figure><p>三者关系图如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcvmzv17tj30go0aymxi.jpg" alt=""></p><blockquote><p>使用<code>__proto__</code>是有争议的，也不鼓励使用它。因为它从来没有被包括在EcmaScript语言规范中，但是现代浏览器都实现了它。<code>__proto__</code>属性已在ECMAScript 6语言规范中标准化，用于确保Web浏览器的兼容性，因此它未来将被支持。但是，它已被<strong>不推荐使用</strong>，现在更推荐使用<code>Object.getPrototypeOf</code>/<code>Reflect.getPrototypeOf</code> 和<code>Object.setPrototypeOf</code>/<code>Reflect.setPrototypeOf</code>（尽管如此，设置对象的原型是一个缓慢的操作，如果性能要求很高，应该避免设置对象的原型）。</p></blockquote><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>使用最新的方法<code>Object.setPrototypeOf</code>（类似<code>Reflect.setPrototypeOf</code>）可以很方便地给对象设置原型，这个对象会继承该原型所有属性和方法。</p><p>但是，<code>setPrototypeOf</code>的性能很差，我们应该尽量使用 <code>Object.create()</code>来为某个对象设置原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj的原型是Object.prototype</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    methodA()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"coffe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(obj);<span class="comment">//以obj为原型创建一个新的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//methodA实际上是newObj原型对象obj上的方法。也即newObj继承了它的原型对象obj的属性和方法。</span></span><br><span class="line">newObj.methodA();<span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h2 id="类-class）的prototype和proto"><a href="#类-class）的prototype和proto" class="headerlink" title="类(class）的prototype和proto"></a>类(class）的prototype和<strong>proto</strong></h2><p>ES6之后，类(class)也有了prototype属性，为什么呢，因为class本质上是构造函数的语法糖.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> A;<span class="comment">//&gt;&gt; "function"</span></span><br></pre></td></tr></table></figure><p>说明class本质上也是函数，所以它带有prototype属性是十分正常的事。<br>然后，在Chrome浏览器里调试如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype;</span><br></pre></td></tr></table></figure><p>得到的结果如下图:<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcw0uwfizj308003xaa0.jpg" alt=""></p><p>上面代码说明类的prototype是一个对象，它包含有constructor属性。这和函数的prototype属性表现具有一致性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A===A.prototype.constructor;<span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure><p>上面代码说明一个重要结论：类指向自身构造函数。<br>而且，事实上，类的所有方法都定义在类的prototype属性上面。同样可以通过Chrome调试验证。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcw622mnij308b09nmxg.jpg" alt=""></p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">//&gt;&gt; true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">//&gt;&gt; true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/javascript-%E9%97%AD%E5%8C%85/"/>
      <url>/javascript-%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>闭包是JavaScript的强大的特性，很多强大JavaScript库比如jQuery、Vue.js都使用了闭包的特性来实现的，同时，闭包也是js里的理解难点之一。</p><a id="more"></a><h2 id="热身：循环中的闭包"><a href="#热身：循环中的闭包" class="headerlink" title="热身：循环中的闭包"></a>热身：循环中的闭包</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">//&gt;&gt; 6 6 6 6 6</span></span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本意是想每隔一秒依次输出“1 2 3 4 5”，结果变成输出“6 6 6 6 6 ”。为什么会这样呢，根据作用域链上变量查找机制，<code>setTimeout</code>第一个参数的函数体内的<code>i</code>引用了去全局作用域里面的<code>i</code>，当for循环完毕后，<code>i</code>的值为6，所以输出了“6 6 6 6 6 ”。</p><p>如何实现正确的输出呢？</p><p>其实用闭包就能轻松解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;<span class="comment">//包了一层IIFE形式的函数，这个函数是闭包</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;<span class="comment">//函数体内的j引用了外层匿名函数的参数j</span></span><br><span class="line">      <span class="built_in">console</span>.log(j); <span class="comment">//&gt;&gt; 1 2 3 4 5</span></span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><h3 id="1-闭包的定义"><a href="#1-闭包的定义" class="headerlink" title="1. 闭包的定义"></a>1. 闭包的定义</h3><p>关于JavaScript闭包的定义有很多种，每本书、每个作者都有不完全相同的描述，虽然笔者认为<strong>函数就是闭包</strong>这个定义才是最简单最直白的，但其实笔者看到过不下十种定义，到现在一种都记不住。鉴于此，我们干脆不要记住这些五花八门的定义了，只要记住了产生闭包的时机会更实际一些，面试时，把闭包产生的时机告诉面试官就可以了：</p><h4 id="内层的作用域访问它外层函数作用域里的参数-变量-函数时，闭包就产生了。"><a href="#内层的作用域访问它外层函数作用域里的参数-变量-函数时，闭包就产生了。" class="headerlink" title="内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。"></a>内层的作用域访问它外层函数作用域里的参数/变量/函数时，闭包就产生了。</h4><p>让我们用代码来说事儿吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;<span class="comment">//func1引用了它外层的变量a，因此func成为了闭包</span></span><br><span class="line">    <span class="keyword">let</span> a=<span class="string">"coffe"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);<span class="comment">//访问了外层函数func体内的变量a</span></span><br><span class="line">        <span class="keyword">debugger</span>;<span class="comment">//断点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>我们在chrome浏览器的“开发者工具”里面的控制台，运行上面的代码，可以很方便看到闭包。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfctlwy6ipj30lq0bqdhc.jpg" alt="image1"></p><p>看上面这个图，Closure出现在Scope一栏里面，所以可以认为闭包也是一种作用域。既然闭包也是一种作用域，闭包能够解决经典的“循环中的闭包”的问题，那是不是利用作用域就能解决问题？这让人想到了关键字let，试试看吧，把本文开头的代码改造一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">let</span> j = i;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(j) <span class="comment">//&gt;&gt; 1 2 3 4 5</span></span><br><span class="line">       &#125;, j * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，用<code>let</code>关键字包上一个作用域，也能和闭包一样解决问题达成目的。因此可以说，<strong>闭包是一种作用域，它拷贝了一套外层函数作用域中被访问的参数、变量/函数</strong>，这个拷贝都是浅拷贝</p><h3 id="2-写成闭包形式有什么好处呢？"><a href="#2-写成闭包形式有什么好处呢？" class="headerlink" title="2. 写成闭包形式有什么好处呢？"></a>2. 写成闭包形式有什么好处呢？</h3><p>当然有好处！还是以之前的代码为例，变量<code>a</code>类似于高级语言的私有属性，无法被<code>func</code>外部作用域访问和修改，只有<code>func</code>内部的作用域（含嵌套作用域）可以访问。这样可以实现软件设计上的<strong>封装</strong>，设计出很强大的类库、框架，比如我们常用的jQuery、AngularJS、Vue.js。</p><p>看一个ES6出现之前最常见的模块化封装的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有属性</span></span><br><span class="line">  <span class="keyword">let</span> name = n;</span><br><span class="line">  <span class="comment">//私有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getModuleName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//私有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">someMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"coffe1891"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//以一个对象的形式返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getModuleName: getModuleName,</span><br><span class="line">    getXXX: someMethod</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myapp = <span class="built_in">module</span>(<span class="string">"myModule"</span>);<span class="comment">//定义一个模块</span></span><br><span class="line"><span class="built_in">console</span>.log(myapp.getModuleName()); <span class="comment">//&gt;&gt; myModule</span></span><br><span class="line"><span class="built_in">console</span>.log(myapp.getXXX()); <span class="comment">//&gt;&gt; coffe1891</span></span><br></pre></td></tr></table></figure><h3 id="3-闭包有什么缺点吗？"><a href="#3-闭包有什么缺点吗？" class="headerlink" title="3. 闭包有什么缺点吗？"></a>3. 闭包有什么缺点吗？</h3><p>javascript中的垃圾回收（GC）规则是这样的：如果对象不再被引用，或者对象互相引用形成数据孤岛后且没有被孤岛之外的其他对象引用，那么这些对象将会被JS引擎的垃圾回收器回收；反之，这些对象一直会保存在内存中。</p><p>由于闭包会引用包含它的外层函数作用域里的变量/函数，因此会比其他非闭包形式的函数占用更多内存。当外层函数执行完毕退出函数调用栈（call stack）的时候，外层函数作用域里变量因为被引用着，可能并不会被JS引擎的垃圾回收器回收，因而会引起内存泄漏。过度使用闭包，会导致内存占用过多，甚至内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       count ++;</span><br><span class="line">       <span class="built_in">console</span>.log(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;<span class="comment">//函数B保持了对count的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = A();</span><br><span class="line">b();<span class="comment">//&gt;&gt; 1</span></span><br><span class="line">b();<span class="comment">//&gt;&gt; 2</span></span><br><span class="line">b();<span class="comment">//&gt;&gt; 3</span></span><br></pre></td></tr></table></figure><p><code>count</code>是函数A中的一个变量，它的值在函数B中被改变，B每执行一次，<code>count</code>的值就在原来的基础上累加1。因此，函数A中的<code>count</code>一直保存在内存中，并没有因为函数A执行完毕退出函数调用栈后被JS引擎的垃圾回收器回收掉。</p><p>避免闭包导致内存泄漏的解决方法是，在函数A执行完毕退出函数调用栈之前，将不再使用的局部变量全部删除或者赋值为null。</p><h2 id="其他使用场景介绍"><a href="#其他使用场景介绍" class="headerlink" title="其他使用场景介绍"></a>其他使用场景介绍</h2><p>除了上面介绍过的循环中的闭包、模块化封装之外，闭包还有一些其他写法。</p><h3 id="1-返回一个新函数"><a href="#1-返回一个新函数" class="headerlink" title="1. 返回一个新函数"></a>1. 返回一个新函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">"Hello "</span> + name; <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> sayAlert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(text);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sayAlert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> say2 = sayHello2(<span class="string">"coffe1891"</span>);</span><br><span class="line">say2(); <span class="comment">//&gt;&gt; Hello coffe1891</span></span><br></pre></td></tr></table></figure><p>调用<code>sayHello2()</code>函数返回了<code>sayAlert</code>，赋值给<code>say2</code>。注意<code>say2</code>是一个引用变量，指向一个函数本身，而不是指向一个变量。</p><h3 id="2-扩展全局对象的方法"><a href="#2-扩展全局对象的方法" class="headerlink" title="2. 扩展全局对象的方法"></a>2. 扩展全局对象的方法</h3><p>下面这种利用闭包扩展全局对象，可以有效地保护私有变量，形成一定的封装、持久性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupSomeGlobals</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    gAlertNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//没有用var和let关键字声明，会成为全局对象的方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gIncreaseNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    gSetNumber = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">        num = x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupSomeGlobals();</span><br><span class="line">gAlertNumber(); <span class="comment">//&gt;&gt; 666</span></span><br><span class="line"></span><br><span class="line">gIncreaseNumber();</span><br><span class="line">gAlertNumber(); <span class="comment">//&gt;&gt; 667</span></span><br><span class="line"></span><br><span class="line">gSetNumber(<span class="number">1891</span>);</span><br><span class="line">gAlertNumber(); <span class="comment">//&gt;&gt; 1891</span></span><br></pre></td></tr></table></figure><p>三个全局函数<code>gAlertNumber</code>，<code>gIncreaseNumber</code>，<code>gSetNumber</code>指向了同一个闭包，因为它们是在同一次<code>setupSomeGlobals()</code>调用中声明的。它们所指向的闭包是与<code>setupSomeGlobals()</code>函数关联一个作用域，该作用域包括了<code>num</code>变量的拷贝。也就是说，这三个函数操作的是同一个<code>num</code>变量。</p><h3 id="3-延长局部变量的生命"><a href="#3-延长局部变量的生命" class="headerlink" title="3. 延长局部变量的生命"></a>3. 延长局部变量的生命</h3><p>日常开发时，Image对象经常被用于数据统计的上报，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = src;</span><br><span class="line">&#125;</span><br><span class="line">report(<span class="string">'http://www.xxx.com/getClientInfo'</span>);<span class="comment">//把客户端信息上报数据</span></span><br></pre></td></tr></table></figure><p>这段代码在运行时，发现在一些低版本浏览器上存在bug，会丢失部分数据上报。原因是Image对象是<code>report</code>函数中的局部变量，当<code>report</code>函数调用结束后，Image对象随即被JS引擎垃圾回收器回收，而此时可能还没来得及发出http请求，所以可能导致此次上报数据的请求失败。</p><p>怎么办呢？我们可以使用闭包把Image对象封闭起来，就可以解决数据丢失的问题，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> report = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> imgs = [];<span class="comment">//在内存里持久化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        imgs.push(img);<span class="comment">//引用局部变量imgs</span></span><br><span class="line">        img.src = src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br><span class="line">report(<span class="string">'http://www.xxx.com/getClientInfo'</span>);<span class="comment">//把客户端信息上报数据</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全理解javascript里的this</title>
      <link href="/javascript-javascript%E9%87%8C%E7%9A%84this/"/>
      <url>/javascript-javascript%E9%87%8C%E7%9A%84this/</url>
      
        <content type="html"><![CDATA[<p><code>this</code>是JavaScript世界最让人迷惑的关键字之一，很多人对它一知半解，本文希望详细的把<code>this</code>说明白。</p><h2 id="为什么要有this？"><a href="#为什么要有this？" class="headerlink" title="为什么要有this？"></a>为什么要有this？</h2><p>JavaScript 允许在函数体内部，引用当前执行上下文的其他变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，函数<code>func</code>引用了当前执行上下文的变量<code>a</code>，问题是这个函数<code>func</code>可以在任意其他执行上下文中被调用，因此这个<code>a</code>可能就指向不同了。正因为如此，JS引擎需要有一个机制，可以依靠其</p><blockquote><p><strong>优雅地、准确地指向当前代码运行时所处的上下文环境</strong>（context）。</p></blockquote><p>因此便催生了“this”。</p><h3 id="何谓”优雅地“？"><a href="#何谓”优雅地“？" class="headerlink" title="何谓”优雅地“？"></a>何谓”优雅地“？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有个对象名字很长，而且有可能会改名</span></span><br><span class="line"><span class="keyword">var</span> iAmALongLongLongNameObject=&#123;</span><br><span class="line">    name:<span class="string">"coffe"</span>,</span><br><span class="line">    func1()&#123;</span><br><span class="line">        <span class="keyword">return</span> iAmALongLongLongNameObject.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    func2()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iAmALongLongLongNameObject</code>的方法<code>func2</code>使用了<code>this</code>关键字，是不是优雅多了？然后即使以后对象名字变化，<code>func2</code>内部的代码也不用改变。<code>func1</code>这种确实也可以实现与<code>func2</code>同样的功能，但是就显得丑陋、不灵活了。</p><h3 id="何谓“准确地”？"><a href="#何谓“准确地”？" class="headerlink" title="何谓“准确地”？"></a>何谓“准确地”？</h3><p><code>this</code>可以准确地指向（某个对象）而不会产生歧义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> iAmALongLongLongNameObject = &#123;</span><br><span class="line">  name: <span class="string">"1891"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//局部变量</span></span><br><span class="line">  <span class="keyword">var</span> iAmALongLongLongNameObject = &#123;</span><br><span class="line">    name: <span class="string">"coffe"</span>,</span><br><span class="line">    func1() &#123;</span><br><span class="line">      <span class="comment">//如果光看代码，是不是容易看成调用了全局变量的name？</span></span><br><span class="line">      <span class="keyword">return</span> iAmALongLongLongNameObject.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    func2() &#123;</span><br><span class="line">      <span class="comment">//这里光看代码就很准确地知道是调用了局部变量的name！</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(iAmALongLongLongNameObject.func1());<span class="comment">//&gt;&gt; coffe</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>与“Java等高级语言的<code>this</code>会指向对象的实例本身”不同，JavaScript的<code>this</code>指向函数的<strong>调用位置</strong>的对象<strong>，也即调用该函数的对象</strong>。你需要知道，JavaScript中所有的函数都有属性，就如对象有属性一样。函数执行阶段（也即执行上下文的执行阶段）会获取<code>this</code>属性的值，此时<code>this</code>就是一个变量，<strong>储存着调用该函数的对象的值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"coffe"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">func();<span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>func</code>的调用者未通过点操作符<code>.</code>指明，那它的调用者就是默认的全局对象<code>window</code>，<code>func</code>函数作为<code>window</code>的一个方法，其体内的<code>this.a</code>就是明确指代<code>window</code>中属性<code>a</code>，这种指向是准确而清晰的，不会有歧义。<code>this</code>的这种灵活性在设计API的时候，会变得很方便和容易被复用。</p><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><p>调用位置就是函数在代码中被调用的位置，而不是声明的位置。研究调用位置，也即搞清“由谁在哪调用了这个函数”的问题。搞清楚了调用位置，才能准确地找到<code>this</code>的指向。</p><p>要找到调用位置，最重要的是要分析是<strong>被谁、在哪</strong>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="string">"1891"</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.getX());<span class="comment">//&gt;&gt; 1891</span></span><br><span class="line"><span class="keyword">var</span> getX = <span class="built_in">module</span>.getX;<span class="comment">//注意：getX和module.getX都是指向内存中函数的地址而已，它们并没有被“()”以便执行</span></span><br><span class="line">                       <span class="comment">//这里实际上是【间接引用】的模式，见文尾【壹.2.3.6】解释</span></span><br><span class="line"><span class="built_in">console</span>.log(getX()); <span class="comment">//&gt;&gt; undefined</span></span><br></pre></td></tr></table></figure><p>如上代码，要找到函数<code>getX</code>的调用位置，需要先看哪儿调用了它，很明显，有函数有两处位置调用了函数<code>getX()</code>，接下来分析是谁调用了它。</p><ul><li>作为<code>module</code>对象的<code>getX</code>方法被调用。 这种情况被谁调用？很明显是被对象<code>module</code>调用，this是指向<code>module</code>。<code>module</code>对象里面有一个属性<code>x</code>，它的值是<code>1891</code>，因此<code>console.log(module.getX())</code>输出<code>1891</code>。</li><li>作为全局函数<code>getX</code>被调用。 这种情况是被谁调用？我们都知道全局函数可以看作为<code>window</code>对象的方法，那么，很明显现在<code>getX</code>是被当做全局对象<code>window</code>的一个方法被调用。</li></ul><p>我们搞清楚了调用位置之后，接下来就会着手判断this的指向。</p><h2 id="先看看很多人对this指向的一些误解"><a href="#先看看很多人对this指向的一些误解" class="headerlink" title="先看看很多人对this指向的一些误解"></a>先看看很多人对this指向的一些误解</h2><p><code>this</code> 既不指向函数自身也不指向函数的作用域，这之前是很多前端工程师容易误解的地方，现在澄清一下。</p><ol><li><code>this</code>的指向，<strong>是在函数被调用的时候确定的</strong>，也就是执行上下文被创建时确定的；</li><li><code>this</code> 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置（也即由谁、在什么地方调用这个函数）；</li><li>正因为在执行上下文的创建阶段<code>this</code>的指向就已经被确定了，在执行阶段<code>this</code>指向不可再被更改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"1891"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span> = obj; <span class="comment">//报错，因为在执行阶段试图修改this的指向</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><h2 id="this的指向规则"><a href="#this的指向规则" class="headerlink" title="this的指向规则"></a>this的指向规则</h2><h3 id="1-默认指向"><a href="#1-默认指向" class="headerlink" title="1. 默认指向"></a><strong>1. 默认指向</strong></h3><p>独立函数调用（无法应用后面其他指向规则时），<code>this</code>指向全局对象<code>window</code><strong>。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a ); <span class="comment">// this指向全局对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">func(); <span class="comment">//&gt;&gt; 2</span></span><br></pre></td></tr></table></figure><p>对于<strong>默认指向</strong>来说，决定<code>this</code>指向对象的并不是<strong>调用位置</strong>是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，<code>this</code>会指向<code>undefined</code>，否则<code>this</code>会指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;<span class="comment">//函数体处于严格模式下，this指向undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"1891"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">//&gt;&gt; 报错</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"1891"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  func(); <span class="comment">//&gt;&gt; 1891</span></span><br><span class="line">  <span class="comment">//这里输出 1891 而不是报错，是因为严格模式下，this的指向与func的调用位置无关</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>还有一种默认指向，就是在SetTimeout或SetInterval结合使用时。代码示例如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">    func1()&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"setTimeout:"</span>+<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    func2()&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line">obj.func();<span class="comment">//&gt;&gt; 1　             输出的是obj.num</span></span><br><span class="line">obj.func1()<span class="comment">//&gt;&gt; setTimeout:0　  输出的是window.num</span></span><br><span class="line">obj.func2()<span class="comment">//&gt;&gt; 0 0 0 0 ……　    输出的是window.num</span></span><br></pre></td></tr></table></figure><p>可以发现在setInterval和setTimeout中传入函数时，函数中的this会指向window对象。</p><h3 id="2-隐式指向"><a href="#2-隐式指向" class="headerlink" title="2. 隐式指向"></a><strong>2. 隐式指向</strong></h3><p>隐式指向是日常开发中最常见的指向。</p><p>函数体内<code>this</code>的指向由调用位置的调用者决定。<strong>如果调用者调用的函数，为某以个对象的方法，那么该函数在被调用时，其内部的<code>this</code>指向该对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  func: func</span><br><span class="line">&#125;;</span><br><span class="line">obj.func(); <span class="comment">//&gt;&gt; 2</span></span><br><span class="line"><span class="comment">// 找到调用位置，由 obj 对象来调用函数func，</span></span><br><span class="line"><span class="comment">// 此时可以说函数func被调用时，obj 对象“拥有”或者“包含”func函数，</span></span><br><span class="line"><span class="comment">// 所以此时的 this 指向调用 func 函数的 obj 对象。</span></span><br></pre></td></tr></table></figure><p><strong>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</strong>，也就是说<code>this</code>指向最终调用函数的对象。这句话可能说得比较拗口，其实简单通俗地说，<code>this</code>指向最靠近被调用函数的对象，离得远的不是。举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="string">"1891"</span>,</span><br><span class="line">  func: func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="string">"coffe"</span>,</span><br><span class="line">  obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时的 this 指向 obj2 对象，因为obj2离得近！</span></span><br><span class="line">obj1.obj2.func(); <span class="comment">//&gt;&gt; 1891</span></span><br></pre></td></tr></table></figure><p>再来看看<strong>隐式丢失：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">"coffe1891"</span>,</span><br><span class="line">    func: func</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.func; <span class="comment">// 间接引用,见本文【壹.2.3.6】。此时bar和obj.func其实</span></span><br><span class="line">                    <span class="comment">// 都指向内存中的函数func本身。</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象window的属性，也是全局变量</span></span><br><span class="line">bar(); <span class="comment">//&gt;&gt; oops, global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然 bar 是 obj.func 的一个引用，但是实际上，它引用的是func函数本身，</span></span><br><span class="line"><span class="comment">// 因此此时的 bar() 其实是一个不带任何定语的独立函数调用，应用【默认指向】规则,</span></span><br><span class="line"><span class="comment">// 因此函数体内的this指向window，this.a指向window的属性a（全局变量a）</span></span><br></pre></td></tr></table></figure><h3 id="3-显式指向"><a href="#3-显式指向" class="headerlink" title="3. 显式指向"></a>3. 显式指向</h3><p>JavaScript内置对象<code>Function</code>的三个原型方法<code>call()</code>、<code>apply()</code>和<code>bind()</code>，它们的第一个参数是一个对象，它们会把这个对象绑定到<code>this</code>，接着在调用函数时让<code>this</code>指向这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"makai"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="string">"coffe1891"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func.call(obj); <span class="comment">//&gt;&gt; coffe1891</span></span><br><span class="line"><span class="comment">// 在调用 func 时强制把它的 this 绑定到 obj 上</span></span><br></pre></td></tr></table></figure><p>另外，使用<code>bind</code>可以修正SetTimeout和SetInterval的this指向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(num)&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    func()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">    func1()&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"setTimeout:"</span>+<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>), <span class="number">1000</span>);<span class="comment">//bind</span></span><br><span class="line">    &#125;</span><br><span class="line">    func2()&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>), <span class="number">2000</span>);<span class="comment">//bind</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="number">1</span>);</span><br><span class="line">obj.func();<span class="comment">//&gt;&gt; 1　             输出的是obj.num</span></span><br><span class="line">obj.func1()<span class="comment">//&gt;&gt; setTimeout:1　  输出的是obj.num</span></span><br><span class="line">obj.func2()<span class="comment">//&gt;&gt; 1 1 1 1 ……　    输出的是obj.num</span></span><br></pre></td></tr></table></figure><h3 id="4-“new”操作符指向"><a href="#4-“new”操作符指向" class="headerlink" title="4. “new”操作符指向"></a>4. “new”操作符指向</h3><p>在JavaScript 中，<strong>构造函数</strong>只是一些<strong>使用<code>new</code>操作符时被调用的函数</strong>。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能算是一种特殊的类型（class），它们<strong>只是被<code>new</code>操作符调用的普通函数而已</strong>。</p><p>使用<code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建（或者说构造）一个全新的对象；</li><li>将构造函数的作用域赋给新对象（因此<code>this</code>就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性、方法等）；</li><li>如果函数没有返回其他对象，那么返回这个新对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> func(<span class="string">"coffe1891"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">//&gt;&gt; coffe1891</span></span><br><span class="line"><span class="comment">// 使用new 来调用func(..)时，我们会构造一个新对象并把它绑定到func(..)调用中的this上</span></span><br></pre></td></tr></table></figure><p>可以将函数的返回值分成三种情况：</p><ul><li>返回一个对象</li><li>没有返回值，即默认返回undefined</li><li>返回基本数据类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、返回一个对象</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"kobin"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、没有返回值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"kobin"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// kobin</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、返回基本数据类型</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="string">"kobin"</span>,<span class="string">"18"</span>);</span><br><span class="line"></span><br><span class="line">bar.name; <span class="comment">// kobin</span></span><br><span class="line"></span><br><span class="line">bar.age; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>所以使用new绑定时，需要判断函数返回的值是否为一个对象，如果是对象，那么this会绑定到返回的对象上</p></blockquote><h2 id="如何利用规则判断this的指向"><a href="#如何利用规则判断this的指向" class="headerlink" title="如何利用规则判断this的指向"></a>如何利用规则判断this的指向</h2><p><code>this</code>的指向判断，可以按照下面的优先级顺序来判断函数在某个调用位置应用的是哪条规则</p><h3 id="1-函数是否在new-中被调用（new-操作符指向）？"><a href="#1-函数是否在new-中被调用（new-操作符指向）？" class="headerlink" title="1. 函数是否在new 中被调用（new 操作符指向）？"></a>1. 函数是否在<code>new</code> 中被调用（<code>new</code> 操作符指向）？</h3><p>如果是的话，<strong><code>this</code> 绑定的是新创建的对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> func(<span class="string">"coffe"</span>); <span class="comment">//this会指向obj</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h3 id="2-函数是否通过call、apply、bind显式指向？"><a href="#2-函数是否通过call、apply、bind显式指向？" class="headerlink" title="2. 函数是否通过call、apply、bind显式指向？"></a>2. 函数是否通过<code>call</code>、<code>apply</code>、<code>bind</code>显式指向？</h3><p>如果是的话，<strong><code>this</code>指向的是call、apply、bind三个方法的第一个参数指定的对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"coffe"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//这里的this本来指向window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = func.call(obj1); <span class="comment">//改变了func函数里面this的指向，指向obj1</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h3 id="3-函数是否被当做某个对象的方法而调用（隐式指向）？"><a href="#3-函数是否被当做某个对象的方法而调用（隐式指向）？" class="headerlink" title="3. 函数是否被当做某个对象的方法而调用（隐式指向）？"></a>3. 函数是否被当做某个对象的方法而调用（隐式指向）？</h3><p>如果是的话，<code>this</code>指向的是这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">"coffe"</span>,</span><br><span class="line">  func() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; <span class="comment">//指向obj1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的obj1.func()，表明func函数被obj1调用，因此func中的this指向obj1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.func()); <span class="comment">//&gt;&gt; coffe</span></span><br></pre></td></tr></table></figure><h3 id="4-若以上都不是的话，使用默认绑定。"><a href="#4-若以上都不是的话，使用默认绑定。" class="headerlink" title="4. 若以上都不是的话，使用默认绑定。"></a>4. 若以上都不是的话，使用默认绑定。</h3><p>如果在严格模式下，就绑定到<code>undefined</code>，否则绑定到<strong>全局对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"coffe"</span>; <span class="comment">//为全局对象window添加一个属性a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;<span class="comment">//开启严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//严格模式下，this指向undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">//&gt;&gt; TypeError</span></span><br></pre></td></tr></table></figure><h2 id="几个例外情况"><a href="#几个例外情况" class="headerlink" title="几个例外情况"></a>几个例外情况</h2><h3 id="1-被忽略的this"><a href="#1-被忽略的this" class="headerlink" title="1. 被忽略的this"></a><strong>1.</strong> 被忽略的this</h3><p><code>null</code> 或者<code>undefined</code>作为<code>this</code>指向的对象传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是<strong>默认指向规则</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">func.call(<span class="literal">null</span>); <span class="comment">//&gt;&gt; 2</span></span><br><span class="line">                 <span class="comment">//this指向了window</span></span><br></pre></td></tr></table></figure><h3 id="2-间接引用"><a href="#2-间接引用" class="headerlink" title="2. 间接引用"></a>2. 间接引用</h3><p>间接引用最容易在赋值时发生；间接引用时，调用这个函数会应用<strong>默认指向规则</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">func</span>: func &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line">o.func(); <span class="comment">//&gt;&gt; 3</span></span><br><span class="line">(p.func = o.func)(); <span class="comment">//&gt;&gt; 2</span></span><br><span class="line"><span class="comment">// 赋值表达式 p.func=o.func 的返回值是目标函数的引用，也就是 func 函数的引用</span></span><br><span class="line"><span class="comment">// 因此调用位置是 func() 而不是 p.func() 或者 o.func()</span></span><br></pre></td></tr></table></figure><h3 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a>3. 箭头函数</h3><p>箭头函数并不是使用<code>function</code>关键字定义的，而是使用被称为“胖箭头”的操作符 <code>=&gt;</code> 定 义的。</p><p>箭头函数不遵守<code>this</code>的四种指向规则，而是<strong>根据函数定义时的作用域来决定 <code>this</code> 的指向。</strong>何谓“定义时的作用域”？就是你定义这个箭头函数的时候，该箭头函数在哪个函数里，那么箭头函数体内的this就是它父函数的this。</p><p>看下面代码加深理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个箭头函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//this 继承自 func()</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = func.call(obj1);</span><br><span class="line">bar.call(obj2); <span class="comment">//&gt;&gt; 2         不是 3 ！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func() 内部创建的箭头函数会捕获调用时 func() 的 this。</span></span><br><span class="line"><span class="comment">// 由于 func() 的 this 绑定到 obj1， bar（引用箭头函数）的 this 也会绑定到 obj1，</span></span><br><span class="line"><span class="comment">// this一旦被确定，就不可更改，所以箭头函数的绑定无法被修改。（new 也不行！）</span></span><br></pre></td></tr></table></figure><p>这个特性甚至被mozilla的MDN称作“<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">没有this</a>”，这种说法很费解。其实应该这么理解：一般而言，this的指向是在函数运行之后才确定的，而箭头函数的this指向在定义时也即调用之前就定死了，在运行之后无法更改，那相当于当成一个固定值的变量，此时this失去了原来作为“指向当前代码运行时所处的上下文环境（context）”的意义，所以MDN说箭头函数没有了this，我觉得翻译成“把this阉割了”更贴切 🤣 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word-wrap,word-break,white-space强制换行和不换行总结</title>
      <link href="/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/"/>
      <url>/css-%E5%BC%BA%E5%88%B6%E6%8D%A2%E8%A1%8C%E4%B8%8E%E4%B8%8D%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>我们一般控制换行所用到的 CSS 属性一共有三个：word-wrap; word-break; white-space。这三个属性可以说是专为了文字断行而创造出来的</p><a id="more"></a><h3 id="word-wrap-语法："><a href="#word-wrap-语法：" class="headerlink" title="word-wrap 语法："></a>word-wrap 语法：</h3><blockquote><p>word-wrap: normal(默认) | break-word</p></blockquote><ul><li>normal: 允许内容顶开指定的容器边界</li><li>break-word: 内容将在边界内换行。必要时会触发 word-break</li></ul><p><strong>说明</strong><br>word-wrap 是控制是否“为词断行”的，设置或检索当前行超过指定容器的边界时是否断开转行。中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。</p><p><strong>范例</strong><br>congratulation 这个单词属于长串英文，word-wrap:break-word 整个单词看成一个整体，如果该行末端宽度不够显示整个单词，它会自动把整个单词放到下一行，而不会把单词截断，这就是对于长串文字不起作用的解释。word-wrap:normal 是默认情况，英文单词不被拆开。</p><p><strong>结论</strong><br>作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（如果为 td,th 加上宽度 word-wrap 在 IE 下是能够发挥效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。</p><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><blockquote><p>word-break: normal(默认) | break-all | keep-all</p></blockquote><ul><li>normal: 依照亚洲语言和非亚洲语言的文本规则，允许在字内换行。</li><li>break-all: 该行为与亚洲语言的 normal 相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本。</li><li>keep-all: 与所有非亚洲语言的 normal 相同。对于中文，韩文，日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。</li></ul><p><strong>说明</strong><br>word-break:break-all，是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题（恰恰弥补了上面 word-wrap:break-word 对于长串文字不起作用的缺陷）</p><p><strong>范例</strong><br>继续以上面 congratulation 这个单词属于长串英文，word-break:break-all 它会把单词截断，该行末端就会变成类似 conra(congratulation 的前端部分)，下一行为 tulation（conguatulation）的后端部分了。<br>word-break:keep-all，是指 Chinese, Japanese, and Korean 不断词。即只用此时，不用 word-wrap，中文就不会换行了。（英文语句正常。）</p><p><strong>结论</strong><br>作用范围仅为 div 这类标准块级元素，th,td 这类 table 元素虽然识别但是没有效果（经测试 Chrome 下 word-break:break-all 是有效果的，但根据完全兼容性方便记忆角度上来说还是以前面的结论为准）。Firefox,Opera 是无法识别 word-break 的，更不用提 Firefox 下的 th,td 中使用 word-break 的效果了。</p><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><blockquote><p>white-space: normal(默认) | pre | nowrap</p></blockquote><ul><li>normal: 默认。空白会被浏览器忽略。</li><li>pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签</li><li>nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。</li></ul><p><strong>说明</strong></p><ul><li>对于 pre 属性，其实就是 HTML 中连续的多个空白符会被合并，然后为了不让他合并（最常用的场合就是表示代码文字缩进）让其中的空白符继续保留而不需要我们增加额外的样式和标签来控制它的缩进和换行。pre 标签的原理也是一样的内部默认有了个 white-space:pre。</li><li>对于 nowrap 属性，这个是强制不换行核心，一般强制不换行就是利用这个属性。Firefox 的 div 和 td 中，以及 IE 的 div 中，均没有问题。唯一的瑕疵就是在 IE 的 td 中会有一个问题，如果 td 没有指定宽度，则 nowrap 仍然有效，如果 td 有宽度，并且文字中无标点、无空格（例如中文长串文字），nowrap 则不再有效。解决方式就是可以加 word-break:keep-all;可以解决此问题。</li></ul><h3 id="总结强制换行"><a href="#总结强制换行" class="headerlink" title="总结强制换行"></a>总结强制换行</h3><ul><li>div（块级元素）<ul><li>word-wrap:break-word; word-break:break-all;</li></ul></li><li>td,th 这类 table 元素<ul><li>先为 table 设定 table-layout:fixed，基本上设定完这个属性后基本的换行问题都能够解决而不会出现 table 中 td,th 因为里面各个内容的多寡发生抢夺其他 td,th 宽度的情形发生。这时如果你依旧有强制换行问题，那么在此 td 中内部加一层 div，那么情况就会像上面讨论的方式来解决。</li></ul></li></ul><h3 id="总结强制不换行"><a href="#总结强制不换行" class="headerlink" title="总结强制不换行"></a>总结强制不换行</h3><ul><li>white-space:nowrap<ul><li>在文字与 td 之间再套一层 div，然后使用 nowrap</li></ul></li><li>overflow:hidden<ul><li>防止文字溢出</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
